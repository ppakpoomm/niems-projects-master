ğŸ“ Master Plan: à¸ˆà¸²à¸ Excel VBA â†’ GitHub â†’ Modern Web ApplicationğŸ“‹ Table of ContentsData Tree Structure & SchemaLearning Roadmap (12 Weeks)GitHub Migration StrategyTechnology Stack Decision MatrixImplementation Phases---<a name="schema"></a>ğŸŒ³ Part 1: Complete Data Tree Structure & SchemaConceptual Data Model```SMART4CUSM Systemâ”‚â”œâ”€â”€ ğŸ“Š STRATEGIC ANALYSIS DOMAIN (Menu 1)â”‚   â”‚â”‚   â”œâ”€â”€ 1. Organization Contextâ”‚   â”‚   â”œâ”€â”€ BasicInfoâ”‚   â”‚   â”‚   â”œâ”€â”€ org_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ org_nameâ”‚   â”‚   â”‚   â”œâ”€â”€ org_type (enum: govt/private/ngo)â”‚   â”‚   â”‚   â”œâ”€â”€ industry_sectorâ”‚   â”‚   â”‚   â”œâ”€â”€ lifecycle_stage (enum: 1-5)â”‚   â”‚   â”‚   â”œâ”€â”€ planning_period_start (date)â”‚   â”‚   â”‚   â”œâ”€â”€ planning_period_end (date)â”‚   â”‚   â”‚   â””â”€â”€ created_atâ”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ Visionâ”‚   â”‚   â”‚   â”œâ”€â”€ vision_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ org_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ vision_statement (text)â”‚   â”‚   â”‚   â”œâ”€â”€ target_year (int)â”‚   â”‚   â”‚   â””â”€â”€ versionâ”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ Missionâ”‚   â”‚   â”‚   â”œâ”€â”€ mission_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ org_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ mission_statement (text)â”‚   â”‚   â”‚   â””â”€â”€ versionâ”‚   â”‚   â”‚â”‚   â”‚   â””â”€â”€ CoreValuesâ”‚   â”‚       â”œâ”€â”€ value_id (PK)â”‚   â”‚       â”œâ”€â”€ org_id (FK)â”‚   â”‚       â”œâ”€â”€ value_name (varchar[50])â”‚   â”‚       â”œâ”€â”€ value_description (text)â”‚   â”‚       â””â”€â”€ display_order (int)â”‚   â”‚â”‚   â”œâ”€â”€ 2. SWOT Analysisâ”‚   â”‚   â”œâ”€â”€ SWOTFactorâ”‚   â”‚   â”‚   â”œâ”€â”€ factor_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ org_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ factor_code (varchar[10]) -- "S01", "W12", "O05", "T08"â”‚   â”‚   â”‚   â”œâ”€â”€ factor_category (enum: S/W/O/T)â”‚   â”‚   â”‚   â”œâ”€â”€ factor_description (text)â”‚   â”‚   â”‚   â”œâ”€â”€ created_by (FK â†’ User)â”‚   â”‚   â”‚   â””â”€â”€ created_atâ”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ DelphiRoundâ”‚   â”‚   â”‚   â”œâ”€â”€ round_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ org_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ round_number (int: 1-5)â”‚   â”‚   â”‚   â”œâ”€â”€ round_status (enum: draft/active/closed)â”‚   â”‚   â”‚   â”œâ”€â”€ start_dateâ”‚   â”‚   â”‚   â””â”€â”€ end_dateâ”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ DelphiScoreâ”‚   â”‚   â”‚   â”œâ”€â”€ score_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ factor_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ round_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ expert_id (FK â†’ User)â”‚   â”‚   â”‚   â”œâ”€â”€ importance_score (decimal: 0-5)â”‚   â”‚   â”‚   â”œâ”€â”€ feasibility_score (decimal: 0-5)â”‚   â”‚   â”‚   â”œâ”€â”€ urgency_score (decimal: 0-5)â”‚   â”‚   â”‚   â”œâ”€â”€ comment (text)â”‚   â”‚   â”‚   â””â”€â”€ scored_atâ”‚   â”‚   â”‚â”‚   â”‚   â””â”€â”€ SWOTAnalyticsSummary (View/Materialized)â”‚   â”‚       â”œâ”€â”€ factor_id (FK)â”‚   â”‚       â”œâ”€â”€ avg_score_all_rounds (calculated)â”‚   â”‚       â”œâ”€â”€ weight_normalized (calculated)â”‚   â”‚       â”œâ”€â”€ weighted_score (calculated)â”‚   â”‚       â”œâ”€â”€ rank_in_category (calculated)â”‚   â”‚       â””â”€â”€ consensus_level (calculated: std_dev)â”‚   â”‚â”‚   â”œâ”€â”€ 3. Strategic Positionâ”‚   â”‚   â”œâ”€â”€ SFASMatrixâ”‚   â”‚   â”‚   â”œâ”€â”€ sfas_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ org_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ analysis_dateâ”‚   â”‚   â”‚   â”œâ”€â”€ strengths_total (decimal)â”‚   â”‚   â”‚   â”œâ”€â”€ weaknesses_total (decimal)â”‚   â”‚   â”‚   â”œâ”€â”€ opportunities_total (decimal)â”‚   â”‚   â”‚   â”œâ”€â”€ threats_total (decimal)â”‚   â”‚   â”‚   â”œâ”€â”€ internal_factor_score (S-W)â”‚   â”‚   â”‚   â”œâ”€â”€ external_factor_score (O-T)â”‚   â”‚   â”‚   â””â”€â”€ strategic_position (enum: SO/ST/WO/WT)â”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ CoreCompetency (VRIO)â”‚   â”‚   â”‚   â”œâ”€â”€ competency_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ org_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ resource_nameâ”‚   â”‚   â”‚   â”œâ”€â”€ value_score (1-5)â”‚   â”‚   â”‚   â”œâ”€â”€ rarity_score (1-5)â”‚   â”‚   â”‚   â”œâ”€â”€ inimitability_score (1-5)â”‚   â”‚   â”‚   â”œâ”€â”€ organization_score (1-5)â”‚   â”‚   â”‚   â”œâ”€â”€ vrio_classification (calculated)â”‚   â”‚   â”‚   â””â”€â”€ competitive_advantage_typeâ”‚   â”‚   â”‚â”‚   â”‚   â””â”€â”€ StrategicChallengeâ”‚   â”‚       â”œâ”€â”€ challenge_id (PK)â”‚   â”‚       â”œâ”€â”€ sfas_id (FK)â”‚   â”‚       â”œâ”€â”€ challenge_descriptionâ”‚   â”‚       â”œâ”€â”€ challenge_type (enum: internal/external)â”‚   â”‚       â”œâ”€â”€ priority_score (1-10)â”‚   â”‚       â””â”€â”€ linked_factors (JSON: [factor_ids])â”‚   â”‚â”‚   â”œâ”€â”€ 4. Blue Ocean Strategy (BOSS)â”‚   â”‚   â”œâ”€â”€ FourActionGridâ”‚   â”‚   â”‚   â”œâ”€â”€ action_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ org_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ factor_nameâ”‚   â”‚   â”‚   â”œâ”€â”€ action_type (enum: eliminate/reduce/raise/create)â”‚   â”‚   â”‚   â”œâ”€â”€ current_level (decimal)â”‚   â”‚   â”‚   â”œâ”€â”€ target_level (decimal)â”‚   â”‚   â”‚   â”œâ”€â”€ rationale (text)â”‚   â”‚   â”‚   â””â”€â”€ innovation_score (calculated)â”‚   â”‚   â”‚â”‚   â”‚   â””â”€â”€ ValueCurveâ”‚   â”‚       â”œâ”€â”€ curve_id (PK)â”‚   â”‚       â”œâ”€â”€ org_id (FK)â”‚   â”‚       â”œâ”€â”€ curve_type (enum: current/proposed)â”‚   â”‚       â”œâ”€â”€ factors (JSON array)â”‚   â”‚       â””â”€â”€ curve_data (JSON: [{factor, score}])â”‚   â”‚â”‚   â””â”€â”€ 5. POSE Frameworkâ”‚       â”œâ”€â”€ POSEAssessmentâ”‚       â”‚   â”œâ”€â”€ pose_id (PK)â”‚       â”‚   â”œâ”€â”€ org_id (FK)â”‚       â”‚   â”œâ”€â”€ moderation_score (decimal)â”‚       â”‚   â”œâ”€â”€ reasonableness_score (decimal)â”‚       â”‚   â”œâ”€â”€ self_immunity_score (decimal)â”‚       â”‚   â”œâ”€â”€ knowledge_condition (bool)â”‚       â”‚   â”œâ”€â”€ virtue_condition (bool)â”‚       â”‚   â””â”€â”€ pose_index (calculated)â”‚       â”‚â”‚       â””â”€â”€ POSEEvidenceâ”‚           â”œâ”€â”€ evidence_id (PK)â”‚           â”œâ”€â”€ pose_id (FK)â”‚           â”œâ”€â”€ principle (enum: moderation/reasonableness/immunity)â”‚           â”œâ”€â”€ evidence_descriptionâ”‚           â””â”€â”€ supporting_docs (JSON: file_refs)â”‚â”œâ”€â”€ ğŸ¯ STRATEGIC EXECUTION DOMAIN (Menu 2)â”‚   â”‚â”‚   â”œâ”€â”€ 6. TOWS Strategyâ”‚   â”‚   â”œâ”€â”€ TOWSStrategyâ”‚   â”‚   â”‚   â”œâ”€â”€ strategy_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ org_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ strategy_code (varchar[10]) -- "SO1", "WO2", "ST3", "WT1"â”‚   â”‚   â”‚   â”œâ”€â”€ strategy_type (enum: SO/WO/ST/WT)â”‚   â”‚   â”‚   â”œâ”€â”€ strategy_description (text)â”‚   â”‚   â”‚   â”œâ”€â”€ linked_strengths (JSON: [factor_ids])â”‚   â”‚   â”‚   â”œâ”€â”€ linked_weaknesses (JSON: [factor_ids])â”‚   â”‚   â”‚   â”œâ”€â”€ linked_opportunities (JSON: [factor_ids])â”‚   â”‚   â”‚   â”œâ”€â”€ linked_threats (JSON: [factor_ids])â”‚   â”‚   â”‚   â”œâ”€â”€ priority_score (decimal)â”‚   â”‚   â”‚   â”œâ”€â”€ status (enum: proposed/approved/active/archived)â”‚   â”‚   â”‚   â””â”€â”€ versionâ”‚   â”‚   â”‚â”‚   â”‚   â””â”€â”€ StrategyRationaleâ”‚   â”‚       â”œâ”€â”€ rationale_id (PK)â”‚   â”‚       â”œâ”€â”€ strategy_id (FK)â”‚   â”‚       â”œâ”€â”€ rationale_text (text)â”‚   â”‚       â”œâ”€â”€ supporting_data (JSON)â”‚   â”‚       â””â”€â”€ approval_statusâ”‚   â”‚â”‚   â”œâ”€â”€ 7. Balanced Scorecard (BSC)â”‚   â”‚   â”œâ”€â”€ BSCPerspectiveâ”‚   â”‚   â”‚   â”œâ”€â”€ perspective_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ perspective_name (enum: financial/customer/internal/learning)â”‚   â”‚   â”‚   â”œâ”€â”€ display_order (int: 1-4)â”‚   â”‚   â”‚   â””â”€â”€ descriptionâ”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ StrategicObjectiveâ”‚   â”‚   â”‚   â”œâ”€â”€ objective_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ org_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ perspective_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ objective_code (varchar[10]) -- "F1", "C2", "I3", "L1"â”‚   â”‚   â”‚   â”œâ”€â”€ objective_nameâ”‚   â”‚   â”‚   â”œâ”€â”€ objective_description (text)â”‚   â”‚   â”‚   â”œâ”€â”€ linked_strategies (JSON: [strategy_ids])â”‚   â”‚   â”‚   â”œâ”€â”€ target_year (int)â”‚   â”‚   â”‚   â”œâ”€â”€ weight_percentage (decimal)â”‚   â”‚   â”‚   â””â”€â”€ statusâ”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ KPIâ”‚   â”‚   â”‚   â”œâ”€â”€ kpi_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ objective_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ kpi_code (varchar[20])â”‚   â”‚   â”‚   â”œâ”€â”€ kpi_nameâ”‚   â”‚   â”‚   â”œâ”€â”€ kpi_description (text)â”‚   â”‚   â”‚   â”œâ”€â”€ measurement_unitâ”‚   â”‚   â”‚   â”œâ”€â”€ measurement_formula (text)â”‚   â”‚   â”‚   â”œâ”€â”€ data_sourceâ”‚   â”‚   â”‚   â”œâ”€â”€ baseline_value (decimal)â”‚   â”‚   â”‚   â”œâ”€â”€ baseline_year (int)â”‚   â”‚   â”‚   â”œâ”€â”€ target_value (decimal)â”‚   â”‚   â”‚   â”œâ”€â”€ target_year (int)â”‚   â”‚   â”‚   â”œâ”€â”€ kpi_type (enum: lagging/leading)â”‚   â”‚   â”‚   â”œâ”€â”€ polarity (enum: higher_better/lower_better)â”‚   â”‚   â”‚   â””â”€â”€ weight_percentage (decimal)â”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ KPITargetâ”‚   â”‚   â”‚   â”œâ”€â”€ target_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ kpi_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ year (int)â”‚   â”‚   â”‚   â”œâ”€â”€ quarter (int: 1-4)â”‚   â”‚   â”‚   â”œâ”€â”€ target_value (decimal)â”‚   â”‚   â”‚   â”œâ”€â”€ stretch_target (decimal)â”‚   â”‚   â”‚   â””â”€â”€ minimum_acceptable (decimal)â”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ KPIActualâ”‚   â”‚   â”‚   â”œâ”€â”€ actual_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ kpi_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ measurement_dateâ”‚   â”‚   â”‚   â”œâ”€â”€ actual_value (decimal)â”‚   â”‚   â”‚   â”œâ”€â”€ data_quality_score (1-5)â”‚   â”‚   â”‚   â”œâ”€â”€ notes (text)â”‚   â”‚   â”‚   â”œâ”€â”€ verified_by (FK â†’ User)â”‚   â”‚   â”‚   â””â”€â”€ verified_atâ”‚   â”‚   â”‚â”‚   â”‚   â””â”€â”€ BSCPerformance (View)â”‚   â”‚       â”œâ”€â”€ kpi_idâ”‚   â”‚       â”œâ”€â”€ current_valueâ”‚   â”‚       â”œâ”€â”€ target_valueâ”‚   â”‚       â”œâ”€â”€ achievement_percentage (calculated)â”‚   â”‚       â”œâ”€â”€ traffic_light (enum: green/yellow/red)â”‚   â”‚       â”œâ”€â”€ trend (enum: improving/stable/declining)â”‚   â”‚       â””â”€â”€ objective_rollup_scoreâ”‚   â”‚â”‚   â”œâ”€â”€ 8. Strategy Mapâ”‚   â”‚   â”œâ”€â”€ StrategyMapNodeâ”‚   â”‚   â”‚   â”œâ”€â”€ node_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ objective_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ position_x (int)â”‚   â”‚   â”‚   â”œâ”€â”€ position_y (int)â”‚   â”‚   â”‚   â”œâ”€â”€ node_colorâ”‚   â”‚   â”‚   â””â”€â”€ display_labelâ”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ CausalRelationshipâ”‚   â”‚   â”‚   â”œâ”€â”€ relationship_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ source_objective_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ target_objective_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ relationship_type (enum: enables/influences/supports)â”‚   â”‚   â”‚   â”œâ”€â”€ strength (decimal: 0-1)â”‚   â”‚   â”‚   â”œâ”€â”€ evidence (text)â”‚   â”‚   â”‚   â””â”€â”€ validated (bool)â”‚   â”‚   â”‚â”‚   â”‚   â””â”€â”€ ImpactAnalysis (Calculated)â”‚   â”‚       â”œâ”€â”€ objective_idâ”‚   â”‚       â”œâ”€â”€ direct_dependencies_countâ”‚   â”‚       â”œâ”€â”€ indirect_dependencies_countâ”‚   â”‚       â”œâ”€â”€ influence_score (calculated)â”‚   â”‚       â””â”€â”€ critical_path_indicator (bool)â”‚   â”‚â”‚   â”œâ”€â”€ 9. Hoshin Kanri (X-Matrix)â”‚   â”‚   â”œâ”€â”€ LongTermGoalâ”‚   â”‚   â”‚   â”œâ”€â”€ ltg_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ org_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ goal_nameâ”‚   â”‚   â”‚   â”œâ”€â”€ goal_descriptionâ”‚   â”‚   â”‚   â”œâ”€â”€ target_year (int)â”‚   â”‚   â”‚   â”œâ”€â”€ linked_vision (FK â†’ Vision)â”‚   â”‚   â”‚   â””â”€â”€ priority_rank (int)â”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ AnnualObjectiveâ”‚   â”‚   â”‚   â”œâ”€â”€ annual_obj_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ org_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ fiscal_year (int)â”‚   â”‚   â”‚   â”œâ”€â”€ objective_nameâ”‚   â”‚   â”‚   â”œâ”€â”€ objective_descriptionâ”‚   â”‚   â”‚   â”œâ”€â”€ linked_ltg (FK â†’ LongTermGoal)â”‚   â”‚   â”‚   â””â”€â”€ completion_percentage (decimal)â”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ ImprovementPriorityâ”‚   â”‚   â”‚   â”œâ”€â”€ priority_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ org_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ priority_nameâ”‚   â”‚   â”‚   â”œâ”€â”€ priority_descriptionâ”‚   â”‚   â”‚   â”œâ”€â”€ linked_annual_obj (FK)â”‚   â”‚   â”‚   â””â”€â”€ resource_allocation_percentageâ”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ XMatrixCorrelationâ”‚   â”‚   â”‚   â”œâ”€â”€ correlation_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ ltg_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ annual_obj_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ priority_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ correlation_strength (enum: 9/3/1/0)â”‚   â”‚   â”‚   â””â”€â”€ justification (text)â”‚   â”‚   â”‚â”‚   â”‚   â””â”€â”€ ResponsibleTeamâ”‚   â”‚       â”œâ”€â”€ assignment_id (PK)â”‚   â”‚       â”œâ”€â”€ annual_obj_id (FK)â”‚   â”‚       â”œâ”€â”€ team_id (FK)â”‚   â”‚       â”œâ”€â”€ role (enum: owner/contributor/consulted/informed)â”‚   â”‚       â””â”€â”€ accountability_level (1-5)â”‚   â”‚â”‚   â”œâ”€â”€ 10. Logical Framework (LFA)â”‚   â”‚   â”œâ”€â”€ LogframeHierarchyâ”‚   â”‚   â”‚   â”œâ”€â”€ level_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ level_name (enum: ultimate_outcome/outcome/output/activity/input)â”‚   â”‚   â”‚   â”œâ”€â”€ level_order (int: 1-5)â”‚   â”‚   â”‚   â””â”€â”€ descriptionâ”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ LogframeElementâ”‚   â”‚   â”‚   â”œâ”€â”€ element_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ org_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ project_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ level_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ parent_element_id (FK: self-reference)â”‚   â”‚   â”‚   â”œâ”€â”€ element_code (varchar[20]) -- "UO1", "OC2", "OP3"â”‚   â”‚   â”‚   â”œâ”€â”€ narrative_summary (text)â”‚   â”‚   â”‚   â”œâ”€â”€ display_order (int)â”‚   â”‚   â”‚   â””â”€â”€ statusâ”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ IndicatorOVIâ”‚   â”‚   â”‚   â”œâ”€â”€ ovi_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ element_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ indicator_description (text)â”‚   â”‚   â”‚   â”œâ”€â”€ baseline_value (decimal)â”‚   â”‚   â”‚   â”œâ”€â”€ target_value (decimal)â”‚   â”‚   â”‚   â”œâ”€â”€ measurement_method (text)â”‚   â”‚   â”‚   â””â”€â”€ disaggregation (JSON: {gender, age, location})â”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ MeansOfVerificationâ”‚   â”‚   â”‚   â”œâ”€â”€ mov_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ ovi_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ data_source (text)â”‚   â”‚   â”‚   â”œâ”€â”€ collection_frequency (enum: daily/weekly/monthly/quarterly/annual)â”‚   â”‚   â”‚   â”œâ”€â”€ responsible_partyâ”‚   â”‚   â”‚   â””â”€â”€ data_quality_rating (1-5)â”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ Assumptionâ”‚   â”‚   â”‚   â”œâ”€â”€ assumption_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ element_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ assumption_description (text)â”‚   â”‚   â”‚   â”œâ”€â”€ assumption_type (enum: assumption/risk)â”‚   â”‚   â”‚   â”œâ”€â”€ likelihood (enum: low/medium/high)â”‚   â”‚   â”‚   â”œâ”€â”€ impact (enum: low/medium/high)â”‚   â”‚   â”‚   â”œâ”€â”€ risk_score (calculated: likelihood Ã— impact)â”‚   â”‚   â”‚   â””â”€â”€ mitigation_strategy (text)â”‚   â”‚   â”‚â”‚   â”‚   â””â”€â”€ TheoryOfChange (Visualization)â”‚   â”‚       â”œâ”€â”€ toc_id (PK)â”‚   â”‚       â”œâ”€â”€ project_id (FK)â”‚   â”‚       â”œâ”€â”€ toc_diagram (JSON: nodes & edges)â”‚   â”‚       â”œâ”€â”€ causal_pathways (JSON)â”‚   â”‚       â””â”€â”€ evidence_base (text)â”‚   â”‚â”‚   â”œâ”€â”€ 11. Project Portfolioâ”‚   â”‚   â”œâ”€â”€ Projectâ”‚   â”‚   â”‚   â”œâ”€â”€ project_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ org_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ project_code (varchar[20])â”‚   â”‚   â”‚   â”œâ”€â”€ project_nameâ”‚   â”‚   â”‚   â”œâ”€â”€ project_description (text)â”‚   â”‚   â”‚   â”œâ”€â”€ linked_strategies (JSON: [strategy_ids])â”‚   â”‚   â”‚   â”œâ”€â”€ linked_objectives (JSON: [objective_ids])â”‚   â”‚   â”‚   â”œâ”€â”€ project_manager_id (FK â†’ User)â”‚   â”‚   â”‚   â”œâ”€â”€ project_status (enum: proposed/approved/active/on_hold/completed/cancelled)â”‚   â”‚   â”‚   â”œâ”€â”€ start_dateâ”‚   â”‚   â”‚   â”œâ”€â”€ end_dateâ”‚   â”‚   â”‚   â”œâ”€â”€ total_budget (decimal)â”‚   â”‚   â”‚   â”œâ”€â”€ budget_spent (decimal)â”‚   â”‚   â”‚   â”œâ”€â”€ completion_percentage (decimal)â”‚   â”‚   â”‚   â””â”€â”€ risk_level (enum: low/medium/high/critical)â”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ WBSElementâ”‚   â”‚   â”‚   â”œâ”€â”€ wbs_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ project_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ parent_wbs_id (FK: self-reference)â”‚   â”‚   â”‚   â”œâ”€â”€ wbs_code (varchar[20]) -- "1.2.3"â”‚   â”‚   â”‚   â”œâ”€â”€ element_nameâ”‚   â”‚   â”‚   â”œâ”€â”€ element_type (enum: phase/deliverable/activity/task)â”‚   â”‚   â”‚   â”œâ”€â”€ description (text)â”‚   â”‚   â”‚   â”œâ”€â”€ assigned_to (FK â†’ User)â”‚   â”‚   â”‚   â”œâ”€â”€ start_dateâ”‚   â”‚   â”‚   â”œâ”€â”€ end_dateâ”‚   â”‚   â”‚   â”œâ”€â”€ duration_days (int)â”‚   â”‚   â”‚   â”œâ”€â”€ progress_percentage (decimal)â”‚   â”‚   â”‚   â”œâ”€â”€ budget_allocated (decimal)â”‚   â”‚   â”‚   â””â”€â”€ statusâ”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ Dependencyâ”‚   â”‚   â”‚   â”œâ”€â”€ dependency_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ predecessor_wbs_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ successor_wbs_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ dependency_type (enum: FS/SS/FF/SF)â”‚   â”‚   â”‚   â”œâ”€â”€ lag_days (int)â”‚   â”‚   â”‚   â””â”€â”€ is_critical_path (bool)â”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ Milestoneâ”‚   â”‚   â”‚   â”œâ”€â”€ milestone_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ project_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ milestone_nameâ”‚   â”‚   â”‚   â”œâ”€â”€ milestone_descriptionâ”‚   â”‚   â”‚   â”œâ”€â”€ target_dateâ”‚   â”‚   â”‚   â”œâ”€â”€ actual_dateâ”‚   â”‚   â”‚   â”œâ”€â”€ status (enum: pending/achieved/missed)â”‚   â”‚   â”‚   â””â”€â”€ importance_level (1-5)â”‚   â”‚   â”‚â”‚   â”‚   â””â”€â”€ ProjectRiskâ”‚   â”‚       â”œâ”€â”€ risk_id (PK)â”‚   â”‚       â”œâ”€â”€ project_id (FK)â”‚   â”‚       â”œâ”€â”€ risk_description (text)â”‚   â”‚       â”œâ”€â”€ risk_category (enum: scope/schedule/cost/quality/resource)â”‚   â”‚       â”œâ”€â”€ probability (decimal: 0-1)â”‚   â”‚       â”œâ”€â”€ impact (decimal: 0-10)â”‚   â”‚       â”œâ”€â”€ risk_score (calculated)â”‚   â”‚       â”œâ”€â”€ mitigation_plan (text)â”‚   â”‚       â”œâ”€â”€ contingency_plan (text)â”‚   â”‚       â””â”€â”€ owner_id (FK â†’ User)â”‚   â”‚â”‚   â”œâ”€â”€ 12. Activity-Based Costing (ABC)â”‚   â”‚   â”œâ”€â”€ ActivityPoolâ”‚   â”‚   â”‚   â”œâ”€â”€ activity_pool_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ org_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ activity_nameâ”‚   â”‚   â”‚   â”œâ”€â”€ activity_descriptionâ”‚   â”‚   â”‚   â”œâ”€â”€ activity_category (enum: value_added/non_value_added/support)â”‚   â”‚   â”‚   â””â”€â”€ total_cost (decimal)â”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ CostDriverâ”‚   â”‚   â”‚   â”œâ”€â”€ driver_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ activity_pool_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ driver_nameâ”‚   â”‚   â”‚   â”œâ”€â”€ driver_unit (varchar[50]) -- "hours", "transactions", "sq.meters"â”‚   â”‚   â”‚   â”œâ”€â”€ total_quantity (decimal)â”‚   â”‚   â”‚   â””â”€â”€ cost_per_unit (calculated)â”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ CostAllocationâ”‚   â”‚   â”‚   â”œâ”€â”€ allocation_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ activity_pool_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ project_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ wbs_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ driver_quantity_used (decimal)â”‚   â”‚   â”‚   â”œâ”€â”€ allocated_cost (calculated)â”‚   â”‚   â”‚   â””â”€â”€ allocation_dateâ”‚   â”‚   â”‚â”‚   â”‚   â”œâ”€â”€ OverheadCostâ”‚   â”‚   â”‚   â”œâ”€â”€ overhead_id (PK)â”‚   â”‚   â”‚   â”œâ”€â”€ org_id (FK)â”‚   â”‚   â”‚   â”œâ”€â”€ cost_category (enum: admin/facilities/utilities/it)â”‚   â”‚   â”‚   â”œâ”€â”€ cost_amount (decimal)â”‚   â”‚   â”‚   â”œâ”€â”€ allocation_basis (text)â”‚   â”‚   â”‚   â”œâ”€â”€ fiscal_year (int)â”‚   â”‚   â”‚   â””â”€â”€ fiscal_quarter (int)â”‚   â”‚   â”‚â”‚   â”‚   â””â”€â”€ CostAnalysis (View)â”‚   â”‚       â”œâ”€â”€ project_idâ”‚   â”‚       â”œâ”€â”€ total_direct_costâ”‚   â”‚       â”œâ”€â”€ total_indirect_costâ”‚   â”‚       â”œâ”€â”€ overhead_allocationâ”‚   â”‚       â”œâ”€â”€ full_project_cost (calculated)â”‚   â”‚       â””â”€â”€ cost_variance_percentageâ”‚   â”‚â”‚   â””â”€â”€ 13. OKR Systemâ”‚       â”œâ”€â”€ OKRCycleâ”‚       â”‚   â”œâ”€â”€ cycle_id (PK)â”‚       â”‚   â”œâ”€â”€ org_id (FK)â”‚       â”‚   â”œâ”€â”€ cycle_name (varchar[50]) -- "2025-Q1", "FY2025"â”‚       â”‚   â”œâ”€â”€ cycle_type (enum: quarterly/annual)â”‚       â”‚   â”œâ”€â”€ start_dateâ”‚       â”‚   â”œâ”€â”€ end_dateâ”‚       â”‚   â”œâ”€â”€ status (enum: planning/active/review/closed)â”‚       â”‚   â””â”€â”€ parent_cycle_id (FK: for quarterly â†’ annual)â”‚       â”‚â”‚       â”œâ”€â”€ OKRâ”‚       â”‚   â”œâ”€â”€ okr_id (PK)â”‚       â”‚   â”œâ”€â”€ cycle_id (FK)â”‚       â”‚   â”œâ”€â”€ owner_id (FK â†’ User/Team/Org)â”‚       â”‚   â”œâ”€â”€ owner_type (enum: organization/team/individual)â”‚       â”‚   â”œâ”€â”€ parent_okr_id (FK: for cascading)â”‚       â”‚   â”œâ”€â”€ objective_text (text)â”‚       â”‚   â”œâ”€â”€ objective_type (enum: committed/aspirational)â”‚       â”‚   â”œâ”€â”€ linked_strategy_id (FK)â”‚       â”‚   â”œâ”€â”€ confidence_level (decimal: 0-10)â”‚       â”‚   â””â”€â”€ status (enum: draft/active/at_risk/achieved/missed)â”‚       â”‚â”‚       â”œâ”€â”€ KeyResultâ”‚       â”‚   â”œâ”€â”€ kr_id (PK)â”‚       â”‚   â”œâ”€â”€ okr_id (FK)â”‚       â”‚   â”œâ”€â”€ kr_number (int: 1-5)â”‚       â”‚   â”œâ”€â”€ kr_description (text)â”‚       â”‚   â”œâ”€â”€ kr_type (enum: metric/milestone/binary)â”‚       â”‚   â”œâ”€â”€ baseline_value (decimal)â”‚       â”‚   â”œâ”€â”€ target_value (decimal)â”‚       â”‚   â”œâ”€â”€ current_value (decimal)â”‚       â”‚   â”œâ”€â”€ unit_of_measureâ”‚       â”‚   â”œâ”€â”€ measurement_frequency (enum: weekly/monthly)â”‚       â”‚   â”œâ”€â”€ weight_percentage (decimal)â”‚       â”‚   â””â”€â”€ grade (calculated: current/target)â”‚       â”‚â”‚       â”œâ”€â”€ OKRUpdateâ”‚       â”‚   â”œâ”€â”€ update_id (PK)â”‚       â”‚   â”œâ”€â”€ okr_id (FK)â”‚       â”‚   â”œâ”€â”€ kr_id (FK)â”‚       â”‚   â”œâ”€â”€ update_dateâ”‚       â”‚   â”œâ”€â”€ progress_value (decimal)â”‚       â”‚   â”œâ”€â”€ confidence_level (decimal: 0-10)â”‚       â”‚   â”œâ”€â”€ status_comment (text)â”‚       â”‚   â”œâ”€â”€ blockers (text)â”‚       â”‚   â””â”€â”€ updated_by (FK â†’ User)â”‚       â”‚â”‚       â”œâ”€â”€ OKRAlignmentâ”‚       â”‚   â”œâ”€â”€ alignment_id (PK)â”‚       â”‚   â”œâ”€â”€ child_okr_id (FK)â”‚       â”‚   â”œâ”€â”€ parent_okr_id (FK)â”‚       â”‚   â”œâ”€â”€ alignment_type (enum: direct/indirect/supports)â”‚       â”‚   â”œâ”€â”€ contribution_percentage (decimal)â”‚       â”‚   â””â”€â”€ alignment_notes (text)â”‚       â”‚â”‚       â””â”€â”€ OKRPerformance (View)â”‚           â”œâ”€â”€ okr_idâ”‚           â”œâ”€â”€ objective_achievement_rate (calculated)â”‚           â”œâ”€â”€ avg_kr_grade (calculated)â”‚           â”œâ”€â”€ on_track_kr_countâ”‚           â”œâ”€â”€ at_risk_kr_countâ”‚           â”œâ”€â”€ off_track_kr_countâ”‚           â”œâ”€â”€ overall_health (enum: healthy/needs_attention/critical)â”‚           â””â”€â”€ team_confidence_avgâ”‚â””â”€â”€ ğŸ” SYSTEM MANAGEMENT DOMAIN    â”‚    â”œâ”€â”€ User Management    â”‚   â”œâ”€â”€ User    â”‚   â”‚   â”œâ”€â”€ user_id (PK)    â”‚   â”‚   â”œâ”€â”€ username (unique)    â”‚   â”‚   â”œâ”€â”€ email (unique)    â”‚   â”‚   â”œâ”€â”€ password_hash    â”‚   â”‚   â”œâ”€â”€ full_name    â”‚   â”‚   â”œâ”€â”€ position_title    â”‚   â”‚   â”œâ”€â”€ department_id (FK)    â”‚   â”‚   â”œâ”€â”€ user_role (enum: admin/manager/contributor/viewer)    â”‚   â”‚   â”œâ”€â”€ is_active (bool)    â”‚   â”‚   â”œâ”€â”€ last_login_at    â”‚   â”‚   â””â”€â”€ created_at    â”‚   â”‚    â”‚   â”œâ”€â”€ Team    â”‚   â”‚   â”œâ”€â”€ team_id (PK)    â”‚   â”‚   â”œâ”€â”€ org_id (FK)    â”‚   â”‚   â”œâ”€â”€ team_name    â”‚   â”‚   â”œâ”€â”€ parent_team_id (FK: self-reference)    â”‚   â”‚   â”œâ”€â”€ team_lead_id (FK â†’ User)    â”‚   â”‚   â””â”€â”€ team_type (enum: functional/cross_functional/project)    â”‚   â”‚    â”‚   â”œâ”€â”€ TeamMembership    â”‚   â”‚   â”œâ”€â”€ membership_id (PK)    â”‚   â”‚   â”œâ”€â”€ team_id (FK)    â”‚   â”‚   â”œâ”€â”€ user_id (FK)    â”‚   â”‚   â”œâ”€â”€ role_in_team (varchar[50])    â”‚   â”‚   â”œâ”€â”€ join_date    â”‚   â”‚   â””â”€â”€ is_active (bool)    â”‚   â”‚    â”‚   â””â”€â”€ Permission    â”‚       â”œâ”€â”€ permission_id (PK)    â”‚       â”œâ”€â”€ user_id (FK)    â”‚       â”œâ”€â”€ resource_type (enum: org/project/okr/bsc)    â”‚       â”œâ”€â”€ resource_id (int)    â”‚       â”œâ”€â”€ permission_level (enum: read/write/admin)    â”‚       â””â”€â”€ granted_at    â”‚    â”œâ”€â”€ Audit & Logging    â”‚   â”œâ”€â”€ AuditLog    â”‚   â”‚   â”œâ”€â”€ log_id (PK)    â”‚   â”‚   â”œâ”€â”€ user_id (FK)    â”‚   â”‚   â”œâ”€â”€ action_type (enum: create/update/delete/view)    â”‚   â”‚   â”œâ”€â”€ entity_type (varchar[50])    â”‚   â”‚   â”œâ”€â”€ entity_id (int)    â”‚   â”‚   â”œâ”€â”€ old_value (JSON)    â”‚   â”‚   â”œâ”€â”€ new_value (JSON)    â”‚   â”‚   â”œâ”€â”€ ip_address    â”‚   â”‚   â”œâ”€â”€ user_agent    â”‚   â”‚   â””â”€â”€ timestamp    â”‚   â”‚    â”‚   â””â”€â”€ ChangeHistory    â”‚       â”œâ”€â”€ change_id (PK)    â”‚       â”œâ”€â”€ entity_type    â”‚       â”œâ”€â”€ entity_id    â”‚       â”œâ”€â”€ field_name    â”‚       â”œâ”€â”€ old_value    â”‚       â”œâ”€â”€ new_value    â”‚       â”œâ”€â”€ changed_by (FK â†’ User)    â”‚       â”œâ”€â”€ change_reason (text)    â”‚       â””â”€â”€ changed_at    â”‚    â”œâ”€â”€ Document Management    â”‚   â”œâ”€â”€ Document    â”‚   â”‚   â”œâ”€â”€ document_id (PK)    â”‚   â”‚   â”œâ”€â”€ document_name    â”‚   â”‚   â”œâ”€â”€ document_type (enum: pdf/docx/xlsx/pptx)    â”‚   â”‚   â”œâ”€â”€ file_size_bytes (bigint)    â”‚   â”‚   â”œâ”€â”€ file_path (varchar[500])    â”‚   â”‚   â”œâ”€â”€ linked_entity_type    â”‚   â”‚   â”œâ”€â”€ linked_entity_id    â”‚   â”‚   â”œâ”€â”€ uploaded_by (FK â†’ User)    â”‚   â”‚   â”œâ”€â”€ upload_date    â”‚   â”‚   â””â”€â”€ version_number    â”‚   â”‚    â”‚   â””â”€â”€ DocumentVersion    â”‚       â”œâ”€â”€ version_id (PK)    â”‚       â”œâ”€â”€ document_id (FK)    â”‚       â”œâ”€â”€ version_number    â”‚       â”œâ”€â”€ file_path    â”‚       â”œâ”€â”€ change_notes (text)    â”‚       â”œâ”€â”€ created_by (FK â†’ User)    â”‚       â””â”€â”€ created_at    â”‚    â”œâ”€â”€ Workflow & Approval    â”‚   â”œâ”€â”€ WorkflowTemplate    â”‚   â”‚   â”œâ”€â”€ template_id (PK)    â”‚   â”‚   â”œâ”€â”€ workflow_name    â”‚   â”‚   â”œâ”€â”€ entity_type (enum: strategy/okr/project/budget)    â”‚   â”‚   â”œâ”€â”€ workflow_steps (JSON: [{step, approver_role, conditions}])    â”‚   â”‚   â””â”€â”€ is_active (bool)    â”‚   â”‚    â”‚   â”œâ”€â”€ ApprovalRequest    â”‚   â”‚   â”œâ”€â”€ request_id (PK)    â”‚   â”‚   â”œâ”€â”€ workflow_template_id (FK)    â”‚   â”‚   â”œâ”€â”€ entity_type    â”‚   â”‚   â”œâ”€â”€ entity_id    â”‚   â”‚   â”œâ”€â”€ requested_by (FK â†’ User)    â”‚   â”‚   â”œâ”€â”€ current_step (int)    â”‚   â”‚   â”œâ”€â”€ status (enum: pending/approved/rejected/cancelled)    â”‚   â”‚   â”œâ”€â”€ requested_at    â”‚   â”‚   â””â”€â”€ completed_at    â”‚   â”‚    â”‚   â””â”€â”€ ApprovalAction    â”‚       â”œâ”€â”€ action_id (PK)    â”‚       â”œâ”€â”€ request_id (FK)    â”‚       â”œâ”€â”€ step_number (int)    â”‚       â”œâ”€â”€ approver_id (FK â†’ User)    â”‚       â”œâ”€â”€ action (enum: approve/reject/request_changes)    â”‚       â”œâ”€â”€ comments (text)    â”‚       â””â”€â”€ action_date    â”‚    â”œâ”€â”€ Notification System    â”‚   â”œâ”€â”€ NotificationTemplate    â”‚   â”‚   â”œâ”€â”€ template_id (PK)    â”‚   â”‚   â”œâ”€â”€ event_type (enum: okr_due/approval_needed/milestone_achieved)    â”‚   â”‚   â”œâ”€â”€ template_title    â”‚   â”‚   â”œâ”€â”€ template_body (text with placeholders)    â”‚   â”‚   â”œâ”€â”€ channels (JSON: [email, sms, in_app])    â”‚   â”‚   â””â”€â”€ is_active (bool)    â”‚   â”‚    â”‚   â””â”€â”€ Notification    â”‚       â”œâ”€â”€ notification_id (PK)    â”‚       â”œâ”€â”€ user_id (FK)    â”‚       â”œâ”€â”€ template_id (FK)    â”‚       â”œâ”€â”€ notification_title    â”‚       â”œâ”€â”€ notification_body (text)    â”‚       â”œâ”€â”€ priority (enum: low/medium/high)    â”‚       â”œâ”€â”€ status (enum: unread/read/dismissed)    â”‚       â”œâ”€â”€ link_url    â”‚       â”œâ”€â”€ sent_at    â”‚       â””â”€â”€ read_at    â”‚    â”œâ”€â”€ Reporting & Analytics    â”‚   â”œâ”€â”€ Report    â”‚   â”‚   â”œâ”€â”€ report_id (PK)    â”‚   â”‚   â”œâ”€â”€ report_name    â”‚   â”‚   â”œâ”€â”€ report_type (enum: bsc/okr/project/financial)    â”‚   â”‚   â”œâ”€â”€ report_query (JSON: filter criteria)    â”‚   â”‚   â”œâ”€â”€ visualization_config (JSON)    â”‚   â”‚   â”œâ”€â”€ created_by (FK â†’ User)    â”‚   â”‚   â”œâ”€â”€ is_public (bool)    â”‚   â”‚   â””â”€â”€ created_at    â”‚   â”‚    â”‚   â”œâ”€â”€ Dashboard    â”‚   â”‚   â”œâ”€â”€ dashboard_id (PK)    â”‚   â”‚   â”œâ”€â”€ dashboard_name    â”‚   â”‚   â”œâ”€â”€ owner_id (FK â†’ User)    â”‚   â”‚   â”œâ”€â”€ layout_config (JSON: widget positions)    â”‚   â”‚   â”œâ”€â”€ refresh_interval (int: minutes)    â”‚   â”‚   â””â”€â”€ is_default (bool)    â”‚   â”‚    â”‚   â””â”€â”€ DashboardWidget    â”‚       â”œâ”€â”€ widget_id (PK)    â”‚       â”œâ”€â”€ dashboard_id (FK)    â”‚       â”œâ”€â”€ widget_type (enum: chart/table/kpi_card/gauge)    â”‚       â”œâ”€â”€ data_source_query (JSON)    â”‚       â”œâ”€â”€ widget_config (JSON: colors, thresholds)    â”‚       â”œâ”€â”€ position_x (int)    â”‚       â”œâ”€â”€ position_y (int)    â”‚       â”œâ”€â”€ width (int)    â”‚       â””â”€â”€ height (int)    â”‚    â””â”€â”€ Integration & API        â”œâ”€â”€ APIKey        â”‚   â”œâ”€â”€ key_id (PK)        â”‚   â”œâ”€â”€ user_id (FK)        â”‚   â”œâ”€â”€ key_name        â”‚   â”œâ”€â”€ api_key_hash        â”‚   â”œâ”€â”€ scope (JSON: [permissions])        â”‚   â”œâ”€â”€ rate_limit (int: requests/hour)        â”‚   â”œâ”€â”€ is_active (bool)        â”‚   â”œâ”€â”€ created_at        â”‚   â””â”€â”€ expires_at        â”‚        â”œâ”€â”€ Webhook        â”‚   â”œâ”€â”€ webhook_id (PK)        â”‚   â”œâ”€â”€ webhook_name        â”‚   â”œâ”€â”€ event_type (enum: okr_update/project_complete)        â”‚   â”œâ”€â”€ target_url        â”‚   â”œâ”€â”€ http_method (enum: POST/PUT)        â”‚   â”œâ”€â”€ headers (JSON)        â”‚   â”œâ”€â”€ payload_template (JSON)        â”‚   â”œâ”€â”€ is_active (bool)        â”‚   â””â”€â”€ created_by (FK â†’ User)        â”‚        â””â”€â”€ IntegrationLog            â”œâ”€â”€ log_id (PK)            â”œâ”€â”€ integration_type (enum: api/webhook/import/export)            â”œâ”€â”€ status (enum: success/failed)            â”œâ”€â”€ request_payload (JSON)            â”œâ”€â”€ response_payload (JSON)            â”œâ”€â”€ error_message (text)            â”œâ”€â”€ execution_time_ms (int)            â””â”€â”€ timestamp```---<a name="roadmap"></a>ğŸ“š Part 2: Learning Roadmap (12 Weeks)Phase 1: Foundation (Weeks 1-3)Week 1: Excel VBA Basics```Day 1-2: VBA Environment Setupâ”œâ”€ Enable Developer Tabâ”œâ”€ Record & Edit Macrosâ”œâ”€ VBA Editor (Alt+F11)â”œâ”€ Immediate Window (Ctrl+G)â””â”€ Debug ToolsDay 3-4: VBA Syntax Fundamentalsâ”œâ”€ Variables & Data Types (Dim, String, Integer, Double)â”œâ”€ Control Structures (If...Then, For...Next, Do...Loop)â”œâ”€ Functions & Subsâ””â”€ Error Handling (On Error Resume Next)Day 5-7: Excel Object Modelâ”œâ”€ Workbooks, Worksheets, Range objectsâ”œâ”€ Cells, Rows, Columns manipulationâ”œâ”€ Named Rangesâ””â”€ Events (Workbook_Open, Worksheet_Change)ğŸ¯ Mini Project: Create a simple data entry form with validation```Week 2: Advanced Excel Features```Day 1-2: Power Query (M Language)â”œâ”€ Data Import from multiple sourcesâ”œâ”€ Transform & Clean dataâ”œâ”€ Merge & Append queriesâ””â”€ Create reusable functionsDay 3-4: Pivot Tables & Chartsâ”œâ”€ Dynamic Pivot Tablesâ”œâ”€ Calculated Fieldsâ”œâ”€ Chart Types & Customizationâ””â”€ Dashboard design principlesDay 5-7: Advanced Formulasâ”œâ”€ Array Formulas (Ctrl+Shift+Enter)â”œâ”€ XLOOKUP, FILTER, SORT (Excel 365)â”œâ”€ Dynamic Named Rangesâ””â”€ Conditional Formatting rulesğŸ¯ Mini Project: Build a self-updating dashboard```Week 3: Version Control & Git```Day 1-3: Git Fundamentalsâ”œâ”€ Install Git & GitHub Desktopâ”œâ”€ Basic commands (init, add, commit, push, pull)â”œâ”€ Branch & Merge conceptsâ”œâ”€ .gitignore for Excel filesâ””â”€ README.md writingDay 4-5: GitHub Workflowâ”œâ”€ Create repositoryâ”œâ”€ Issues & Project boardsâ”œâ”€ Pull Requests & Code Reviewâ””â”€ GitHub Actions basicsDay 6-7: Excel + Git Integrationâ”œâ”€ Export VBA to .bas filesâ”œâ”€ Version control strategy for Excelâ”œâ”€ Diff tools for Excel filesâ””â”€ CI/CD concepts for Excel-based projectsğŸ¯ Mini Project: Migrate SMART4CUSM to GitHub```---Phase 2: Database & Backend (Weeks 4-6)Week 4: SQL & Database Design```Day 1-2: SQL Basics (PostgreSQL)â”œâ”€ SELECT, WHERE, ORDER BY, GROUP BYâ”œâ”€ JOINs (INNER, LEFT, RIGHT, FULL)â”œâ”€ Aggregate functions (COUNT, SUM, AVG)â””â”€ Subqueries & CTEsDay 3-4: Database Designâ”œâ”€ Normalization (1NF, 2NF, 3NF)â”œâ”€ Primary & Foreign Keysâ”œâ”€ Indexes & Performanceâ””â”€ Transactions & ACIDDay 5-7: Advanced SQLâ”œâ”€ Window Functions (ROW_NUMBER, RANK, LAG, LEAD)â”œâ”€ Views & Materialized Viewsâ”œâ”€ Stored Procedures & Functionsâ””â”€ Query optimizationğŸ¯ Mini Project: Create SMART4CUSM database schema```Week 5: Python/TypeScript Basics```Day 1-3: Python for Data (Choose this if data-heavy)â”œâ”€ Variables, Lists, Dictionariesâ”œâ”€ Pandas for data manipulationâ”œâ”€ SQLAlchemy ORMâ””â”€ FastAPI basicsORTypeScript Foundations (Choose this if web-focused)â”œâ”€ Types, Interfaces, Genericsâ”œâ”€ Async/Await, Promisesâ”œâ”€ Node.js basicsâ””â”€ tRPC or Express.jsDay 4-7: API Developmentâ”œâ”€ RESTful API designâ”œâ”€ CRUD operationsâ”œâ”€ Authentication (JWT)â””â”€ API documentation (Swagger/OpenAPI)ğŸ¯ Mini Project: Build SWOT Analysis API endpoint```Week 6: Prisma ORM & Database Integration```Day 1-2: Prisma Setupâ”œâ”€ Install & Initializeâ”œâ”€ Schema definitionâ”œâ”€ Migrationsâ””â”€ Prisma StudioDay 3-5: CRUD with Prismaâ”œâ”€ Create operationsâ”œâ”€ Read (findMany, findUnique, where, include)â”œâ”€ Update & Upsertâ”œâ”€ Delete & Soft Deleteâ””â”€ Relations & Nested writesDay 6-7: Advanced Prismaâ”œâ”€ Transactionsâ”œâ”€ Raw queriesâ”œâ”€ Performance optimizationâ””â”€ Seeding datağŸ¯ Mini Project: Implement full SWOT CRUD API```---Phase 3: Frontend Development (Weeks 7-9)Week 7: React Foundations```Day 1-2: React Basicsâ”œâ”€ Components & Propsâ”œâ”€ State & Hooks (useState, useEffect)â”œâ”€ Event Handlingâ””â”€ Conditional RenderingDay 3-4: React Advancedâ”œâ”€ Context API & useContextâ”œâ”€ Custom Hooksâ”œâ”€ useCallback, useMemoâ””â”€ Error BoundariesDay 5-7: Next.js 14â”œâ”€ App Routerâ”œâ”€ Server & Client Componentsâ”œâ”€ Dynamic Routesâ”œâ”€ API Routesâ””â”€ Server ActionsğŸ¯ Mini Project: Build Organization Profile form```Week 8: UI/UX with Tailwind & shadcn/ui```Day 1-2: Tailwind CSSâ”œâ”€ Utility-first conceptsâ”œâ”€ Responsive design (sm:, md:, lg:)â”œâ”€ Dark modeâ””â”€ Custom configurationsDay 3-5: shadcn/ui Componentsâ”œâ”€ Button, Input, Selectâ”œâ”€ Dialog, Sheet, Popoverâ”œâ”€ Table, DataTableâ”œâ”€ Form with react-hook-form + zodâ””â”€ Toast notificationsDay 6-7: Complex Layoutsâ”œâ”€ Dashboard layoutsâ”œâ”€ Sidebar navigationâ”œâ”€ Multi-step formsâ””â”€ Drag-and-drop interfacesğŸ¯ Mini Project: SWOT Analysis UI with Delphi rounds```Week 9: Data Visualization```Day 1-3: Rechartsâ”œâ”€ Line, Bar, Area chartsâ”œâ”€ Pie, Radar chartsâ”œâ”€ Composed chartsâ””â”€ Responsive containersDay 4-5: D3.js Basicsâ”œâ”€ SVG fundamentalsâ”œâ”€ Scales & Axesâ”œâ”€ Force-directed graphsâ””â”€ Tree & Network diagramsDay 6-7: Custom Visualizationsâ”œâ”€ Strategy Map (custom D3)â”œâ”€ X-Matrix visualizationâ”œâ”€ Gantt Chartâ””â”€ Interactive dashboardsğŸ¯ Mini Project: Build BSC Dashboard with multiple charts```---Phase 4: Integration & Deployment (Weeks 10-12)Week 10: State Management & Real-time Features```Day 1-3: Zustand for Stateâ”œâ”€ Store creationâ”œâ”€ Actions & Selectorsâ”œâ”€ Persist middlewareâ””â”€ DevTools integrationDay 4-5: Real-time with Supabase (or Socket.io)â”œâ”€ Real-time subscriptionsâ”œâ”€ Presence (who's online)â”œâ”€ Broadcast messagesâ””â”€ Optimistic updatesDay 6-7: Authenticationâ”œâ”€ NextAuth.js setupâ”œâ”€ OAuth providers (Google, GitHub)â”œâ”€ Role-based access control (RBAC)â””â”€ Protected routesğŸ¯ Mini Project: Collaborative OKR editing with real-time updates```Week 11: Testing & CI/CD```Day 1-2: Unit Testingâ”œâ”€ Jest basicsâ”œâ”€ React Testing Libraryâ”œâ”€ Mock data & API callsâ””â”€ Coverage reportsDay 3-4: E2E Testingâ”œâ”€ Playwright setupâ”œâ”€ User flow testsâ”œâ”€ Visual regression testingâ””â”€ Test automationDay 5-7: CI/CD Pipelineâ”œâ”€ GitHub Actions workflowâ”œâ”€ Automated testingâ”œâ”€ Build & Deploy to Vercelâ”œâ”€ Database migrationsâ””â”€ Environment managementğŸ¯ Mini Project: Complete CI/CD pipeline for SMART4CUSM```Week 12: Production Deployment```Day 1-2: Production Readinessâ”œâ”€ Environment variablesâ”œâ”€ Error monitoring (Sentry)â”œâ”€ Performance monitoring (PostHog)â”œâ”€ SEO & meta tagsâ””â”€ Security headersDay 3-4: Deploymentâ”œâ”€ Deploy frontend to Vercelâ”œâ”€ Deploy backend to Railway/Fly.ioâ”œâ”€ Database on Supabase/Neonâ”œâ”€ File storage (S3/MinIO)â””â”€ CDN setupDay 5-7: Documentation & Handoffâ”œâ”€ API documentationâ”œâ”€ User manualâ”œâ”€ Admin guideâ”œâ”€ Video tutorialsâ””â”€ Training materialsğŸ¯ Final Project: Full SMART4CUSM app deployed to production```---<a name="github"></a>ğŸš€ Part 3: GitHub Migration StrategyRepository Structure```smart4cusm-platform/â”‚â”œâ”€â”€ .github/â”‚   â”œâ”€â”€ workflows/â”‚   â”‚   â”œâ”€â”€ ci.ymlâ”‚   â”‚   â”œâ”€â”€ deploy-frontend.ymlâ”‚   â”‚   â”œâ”€â”€ deploy-backend.ymlâ”‚   â”‚   â””â”€â”€ db-migrate.ymlâ”‚   â”œâ”€â”€ ISSUE_TEMPLATE/â”‚   â”‚   â”œâ”€â”€ bug_report.mdâ”‚   â”‚   â”œâ”€â”€ feature_request.mdâ”‚   â”‚   â””â”€â”€ improvement.mdâ”‚   â””â”€â”€ pull_request_template.mdâ”‚â”œâ”€â”€ packages/â”‚   â”œâ”€â”€ database/â”‚   â”‚   â”œâ”€â”€ prisma/â”‚   â”‚   â”‚   â”œâ”€â”€ schema.prismaâ”‚   â”‚   â”‚   â”œâ”€â”€ migrations/â”‚   â”‚   â”‚   â””â”€â”€ seed.tsâ”‚   â”‚   â”œâ”€â”€ src/â”‚   â”‚   â”‚   â”œâ”€â”€ client.tsâ”‚   â”‚   â”‚   â””â”€â”€ types.tsâ”‚   â”‚   â””â”€â”€ package.jsonâ”‚   â”‚â”‚   â”œâ”€â”€ api/â”‚   â”‚   â”œâ”€â”€ src/â”‚   â”‚   â”‚   â”œâ”€â”€ routes/â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ swot.tsâ”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ bsc.tsâ”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ okr.tsâ”‚   â”‚   â”‚   â”‚   â””â”€â”€ projects.tsâ”‚   â”‚   â”‚   â”œâ”€â”€ middleware/â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ auth.tsâ”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ validation.tsâ”‚   â”‚   â”‚   â”‚   â””â”€â”€ error-handler.tsâ”‚   â”‚   â”‚   â”œâ”€â”€ services/â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ swot.service.tsâ”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ tows.service.tsâ”‚   â”‚   â”‚   â”‚   â””â”€â”€ calculation.service.tsâ”‚   â”‚   â”‚   â””â”€â”€ server.tsâ”‚   â”‚   â”œâ”€â”€ tests/â”‚   â”‚   â””â”€â”€ package.jsonâ”‚   â”‚â”‚   â”œâ”€â”€ web/â”‚   â”‚   â”œâ”€â”€ app/â”‚   â”‚   â”‚   â”œâ”€â”€ (auth)/â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ login/â”‚   â”‚   â”‚   â”‚   â””â”€â”€ register/â”‚   â”‚   â”‚   â”œâ”€â”€ (dashboard)/â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ layout.tsxâ”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsxâ”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ swot/â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ tows/â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ bsc/â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ strategy-map/â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ x-matrix/â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ logframe/â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ projects/â”‚   â”‚   â”‚   â”‚   â””â”€â”€ okrs/â”‚   â”‚   â”‚   â””â”€â”€ api/â”‚   â”‚   â”œâ”€â”€ components/â”‚   â”‚   â”‚   â”œâ”€â”€ ui/ (shadcn/ui)â”‚   â”‚   â”‚   â”œâ”€â”€ charts/â”‚   â”‚   â”‚   â”œâ”€â”€ forms/â”‚   â”‚   â”‚   â””â”€â”€ layouts/â”‚   â”‚   â”œâ”€â”€ lib/â”‚   â”‚   â”‚   â”œâ”€â”€ utils.tsâ”‚   â”‚   â”‚   â”œâ”€â”€ api-client.tsâ”‚   â”‚   â”‚   â””â”€â”€ validations/â”‚   â”‚   â”œâ”€â”€ hooks/â”‚   â”‚   â”œâ”€â”€ stores/â”‚   â”‚   â””â”€â”€ package.jsonâ”‚   â”‚â”‚   â””â”€â”€ shared/â”‚       â”œâ”€â”€ types/â”‚       â”œâ”€â”€ constants/â”‚       â””â”€â”€ utils/â”‚â”œâ”€â”€ docs/â”‚   â”œâ”€â”€ api/â”‚   â”‚   â””â”€â”€ swagger.yamlâ”‚   â”œâ”€â”€ architecture/â”‚   â”‚   â”œâ”€â”€ data-model.mdâ”‚   â”‚   â””â”€â”€ system-design.mdâ”‚   â”œâ”€â”€ user-guide/â”‚   â”‚   â”œâ”€â”€ getting-started.mdâ”‚   â”‚   â”œâ”€â”€ swot-analysis.mdâ”‚   â”‚   â””â”€â”€ okr-management.mdâ”‚   â””â”€â”€ developer/â”‚       â”œâ”€â”€ setup.mdâ”‚       â”œâ”€â”€ contributing.mdâ”‚       â””â”€â”€ deployment.mdâ”‚â”œâ”€â”€ legacy/â”‚   â”œâ”€â”€ excel-files/â”‚   â”‚   â””â”€â”€ SMART4CUSM6831_original.xlsxâ”‚   â”œâ”€â”€ vba-export/â”‚   â”‚   â”œâ”€â”€ Module1.basâ”‚   â”‚   â”œâ”€â”€ Module2.basâ”‚   â”‚   â””â”€â”€ UserForm1.frmâ”‚   â””â”€â”€ migration-notes.mdâ”‚â”œâ”€â”€ scripts/â”‚   â”œâ”€â”€ migrate-excel-data.pyâ”‚   â”œâ”€â”€ seed-demo-data.tsâ”‚   â””â”€â”€ backup-db.shâ”‚â”œâ”€â”€ .env.exampleâ”œâ”€â”€ .gitignoreâ”œâ”€â”€ docker-compose.ymlâ”œâ”€â”€ package.json (root - for workspaces)â”œâ”€â”€ pnpm-workspace.yamlâ”œâ”€â”€ turbo.json (if using Turborepo)â”œâ”€â”€ README.mdâ””â”€â”€ LICENSE```---<a name="techstack"></a>ğŸ› ï¸ Part 4: Technology Stack Decision MatrixOption A: Python-Based Stack (Best for Data-Heavy Operations)```yamlFrontend:  - Next.js 14 (App Router)  - React 18  - Tailwind CSS + shadcn/ui  - Recharts + D3.js  - Zustand (state)Backend:  - FastAPI (Python 3.11+)  - SQLAlchemy ORM  - Pydantic (validation)  - Alembic (migrations)Database:  - PostgreSQL 15+  - Redis (caching)Infrastructure:  - Frontend: Vercel  - Backend: Railway / Fly.io  - DB: Supabase / Neon  - Storage: AWS S3 / MinIOPros:  âœ… Excellent for data analysis & calculations  âœ… Rich ecosystem (Pandas, NumPy, Scipy)  âœ… Easy Excel integration (openpyxl)  âœ… Great for ML/AI features later  âœ… Familiar to data scientistsCons:  âš ï¸ Two languages (Python + TypeScript)  âš ï¸ Deployment complexity  âš ï¸ Type safety across stack```Option B: Full TypeScript Stack (Best for Modern Web Development)```yamlFrontend:  - Next.js 14 (App Router)  - React 18  - Tailwind CSS + shadcn/ui  - Recharts + D3.js  - Zustand (state)Backend:  - Next.js API Routes / tRPC  - Prisma ORM  - Zod (validation)Database:  - PostgreSQL 15+  - Redis (caching)Infrastructure:  - All-in-one: Vercel  - OR separate: Frontend (Vercel) + Backend (Fly.io)  - DB: Supabase / PlanetScale  - Storage: Vercel Blob / Cloudflare R2Pros:  âœ… End-to-end type safety  âœ… Single language (TypeScript)  âœ… Simpler deployment  âœ… Great DX (Developer Experience)  âœ… Strong ecosystemCons:  âš ï¸ Less powerful for heavy data processing  âš ï¸ Need libraries for complex calculations```ğŸ¯ Recommended: Option B (Full TypeScript)à¹€à¸«à¸•à¸¸à¸œà¸¥:à¸„à¸¸à¸“à¹€à¸à¸´à¹ˆà¸‡à¹€à¸£à¸´à¹ˆà¸¡à¹€à¸£à¸µà¸¢à¸™ â†’ à¹€à¸£à¸µà¸¢à¸™à¸ à¸²à¸©à¸²à¹€à¸”à¸µà¸¢à¸§à¸‡à¹ˆà¸²à¸¢à¸à¸§à¹ˆà¸²Type safety â†’ à¸¥à¸” bugsPrisma â†’ à¹€à¸£à¸µà¸¢à¸™à¸£à¸¹à¹‰à¸‡à¹ˆà¸²à¸¢à¸à¸§à¹ˆà¸² SQLAlchemyDeployment à¸‡à¹ˆà¸²à¸¢à¸à¸§à¹ˆà¸² â†’ Vercel one-clickCommunity à¹ƒà¸«à¸à¹ˆ â†’ à¸«à¸²à¸„à¸§à¸²à¸¡à¸Šà¹ˆà¸§à¸¢à¹€à¸«à¸¥à¸·à¸­à¸‡à¹ˆà¸²à¸¢---<a name="phases"></a>ğŸ“… Part 5: Implementation PhasesPhase 0: Preparation (Week 1-2)```Tasks:â˜ Setup development environment  â”œâ”€ Install VS Code + Extensions  â”œâ”€ Install Node.js 20+ & pnpm  â”œâ”€ Install PostgreSQL (local or Docker)  â”œâ”€ Install Git & GitHub CLI  â””â”€ Create GitHub account (if needed)â˜ Create GitHub repository  â”œâ”€ Initialize with README  â”œâ”€ Add .gitignore (Node, Excel, etc.)  â”œâ”€ Setup branch protection  â””â”€ Create project boardâ˜ Export Excel VBA  â”œâ”€ Export all modules to .bas files  â”œâ”€ Document all named ranges  â”œâ”€ Export sample data to CSV  â””â”€ Document formulas & dependenciesDeliverable: Clean repo with legacy Excel documented```Phase 1: Database Foundation (Week 3-4)```Tasks:â˜ Design database schema  â”œâ”€ Create Prisma schema.prisma  â”œâ”€ Define all models (see schema above)  â”œâ”€ Setup relations & indexes  â””â”€ Review & refineâ˜ Create migrations  â”œâ”€ Run prisma migrate dev  â”œâ”€ Verify schema in DB  â””â”€ Seed demo dataâ˜ Build seed script  â”œâ”€ Sample organizations  â”œâ”€ SWOT factors  â”œâ”€ Delphi rounds data  â””â”€ Test data integrityDeliverable: Working database with sample data```Phase 2: API Development (Week 5-7)```Tasks:â˜ Setup Next.js with tRPC  â”œâ”€ Initialize Next.js 14 project  â”œâ”€ Configure tRPC router  â”œâ”€ Setup Prisma client  â””â”€ Create base proceduresâ˜ Build core routers  â”œâ”€ org.router.ts (CRUD organizations)  â”œâ”€ swot.router.ts (SWOT analysis)  â”œâ”€ delphi.router.ts (Delphi rounds)  â”œâ”€ sfas.router.ts (SFAS calculations)  â””â”€ tows.router.ts (TOWS strategies)â˜ Implement calculations  â”œâ”€ SWOT weighted scores  â”œâ”€ SFAS matrix  â”œâ”€ Strategic position  â”œâ”€ VRIO analysis  â””â”€ TOWS priority rankingâ˜ Add authentication  â”œâ”€ NextAuth.js setup  â”œâ”€ Google OAuth  â”œâ”€ Session management  â””â”€ Protected proceduresDeliverable: Full API with auth```Phase 3: Frontend (Menu 1) (Week 8-10)```Tasks:â˜ Setup UI foundation  â”œâ”€ Install shadcn/ui  â”œâ”€ Configure Tailwind  â”œâ”€ Create base layouts  â””â”€ Setup navigationâ˜ Build Menu 1 pages  â”œâ”€ /dashboard (overview)  â”œâ”€ /organization (1GenInfo)  â”œâ”€ /swot (2SWOT with Delphi)  â”œâ”€ /analysis (3Data - SFAS)  â”œâ”€ /position (4S.Position)  â”œâ”€ /challenge (5Challenge - POSE/BOSS)  â””â”€ /action-grid (6ActGrid)â˜ Implement interactive features  â”œâ”€ Delphi round wizard  â”œâ”€ SWOT factor editing  â”œâ”€ Real-time score calculation  â”œâ”€ SFAS matrix visualization  â”œâ”€ Strategic position quadrant  â””â”€ Four Action Grid drag-dropDeliverable: Full Menu 1 functionality```Phase 4: Frontend (Menu 2) (Week 11-13)```Tasks:â˜ Build Menu 2 pages  â”œâ”€ /tows (7TOWS matrix)  â”œâ”€ /vision-mission (8-9 VMS)  â”œâ”€ /bsc (10BSC - all perspectives)  â”œâ”€ /strategy-map (11SMap)  â”œâ”€ /x-matrix (12Xmatrix)  â”œâ”€ /logframe (13Logframe)  â”œâ”€ /projects (14Projects + Gantt)  â””â”€ /okrs (15OKRs cascade)â˜ Advanced visualizations  â”œâ”€ Strategy Map (D3.js force-directed)  â”œâ”€ X-Matrix correlation heatmap  â”œâ”€ Gantt chart with critical path  â”œâ”€ BSC dashboard with gauges  â””â”€ OKR progress treesâ˜ Collaborative features  â”œâ”€ Multi-user Delphi  â”œâ”€ Comments & discussions  â”œâ”€ Approval workflows  â””â”€ Real-time notificationsDeliverable: Full Menu 2 functionality```Phase 5: Integration & Polish (Week 14-15)```Tasks:â˜ Data migration  â”œâ”€ Excel â†’ CSV export  â”œâ”€ CSV â†’ DB import script  â”œâ”€ Data validation  â””â”€ Verify calculations matchâ˜ Testing  â”œâ”€ Unit tests (API routes)  â”œâ”€ Integration tests  â”œâ”€ E2E tests (Playwright)  â””â”€ Performance testingâ˜ Polish  â”œâ”€ Loading states  â”œâ”€ Error handling  â”œâ”€ Toast notifications  â”œâ”€ Empty states  â””â”€ Mobile responsivenessâ˜ Documentation  â”œâ”€ API docs (tRPC auto-docs)  â”œâ”€ User guide  â”œâ”€ Video tutorials  â””â”€ Admin manualDeliverable: Production-ready app```Phase 6: Deployment & Launch (Week 16)```Tasks:â˜ Setup production infrastructure  â”œâ”€ Vercel project  â”œâ”€ Supabase database  â”œâ”€ Environment variables  â””â”€ Domain & SSLâ˜ CI/CD pipeline  â”œâ”€ GitHub Actions  â”œâ”€ Automated testing  â”œâ”€ Preview deployments  â””â”€ Production deploymentâ˜ Monitoring  â”œâ”€ Sentry (errors)  â”œâ”€ PostHog (analytics)  â”œâ”€ Uptime monitoring  â””â”€ Performance trackingâ˜ Launch  â”œâ”€ Soft launch (beta users)  â”œâ”€ Gather feedback  â”œâ”€ Fix critical issues  â””â”€ Public launchDeliverable: Live production system```---ğŸ“ Recommended Learning ResourcesFree Resources```Excel VBA:- Excel VBA Programming For Dummies (YouTube)- Wise Owl Tutorials (YouTube channel)TypeScript:- TypeScript Handbook (official docs)- Total TypeScript (Matt Pocock - free course)React & Next.js:- Next.js official tutorial- React docs (new beta docs)- shadcn/ui documentationDatabase:- SQL Zoo (interactive)- Prisma documentation- PostgreSQL tutorialFull Stack:- T3 Stack tutorial (tRPC + Next.js + Prisma)- Josh tried coding (YouTube)```Paid Resources (Worth it)```- Frontend Masters ($39/month)  â†’ Complete Intro to React  â†’ TypeScript Fundamentals  - Wes Bos courses  â†’ React for Beginners  â†’ Advanced React  - Level Up Tutorials  â†’ Full stack tutorials```---ğŸ“ Next Steps - Start TODAYWeek 1 Action Plan```Day 1 (Today):â˜ Read this entire documentâ˜ Install VS Codeâ˜ Install Node.js 20 LTSâ˜ Install Gitâ˜ Create GitHub accountDay 2:â˜ Open Excel fileâ˜ Alt+F11 â†’ explore VBA codeâ˜ Record a simple macroâ˜ Edit the macro codeâ˜ Run it againDay 3:â˜ Export one VBA module to .basâ˜ Create GitHub repo "smart4cusm-learning"â˜ Upload the .bas fileâ˜ Write first commit messageDay 4:â˜ Follow Next.js tutorial (1 hour)â˜ Create your first Next.js appâ˜ Push to GitHubDay 5:â˜ Create Prisma schema for Organizationâ˜ Run first migrationâ˜ Insert data via Prisma StudioDay 6-7:â˜ Build simple API endpointâ˜ Create form to submit dataâ˜ See data in databaseâ˜ Celebrate! ğŸ‰```---à¸à¸£à¹‰à¸­à¸¡à¹€à¸£à¸´à¹ˆà¸¡à¹à¸¥à¹‰à¸§à¹€à¸«à¸£à¸­à¸„à¸£à¸±à¸š? à¸œà¸¡à¸ˆà¸° guide à¸—à¸µà¸¥à¸° step à¸•à¸±à¹‰à¸‡à¹à¸•à¹ˆ Day 1 à¹€à¸¥à¸¢ à¸«à¸£à¸·à¸­à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¹ƒà¸«à¹‰à¹€à¸£à¸´à¹ˆà¸¡à¸ˆà¸²à¸à¸ªà¹ˆà¸§à¸™à¹„à¸«à¸™à¸à¹ˆà¸­à¸™?à¹€à¸£à¸´à¹ˆà¸¡à¹€à¸£à¸µà¸¢à¸™ VBA à¸ˆà¸²à¸à¹„à¸Ÿà¸¥à¹Œ Excel à¸—à¸µà¹ˆà¸¡à¸µà¸­à¸¢à¸¹à¹ˆà¹€à¸¥à¸¢?à¸«à¸£à¸·à¸­à¸‚à¹‰à¸²à¸¡ VBA à¹„à¸›à¹€à¸£à¸µà¸¢à¸™ TypeScript + React à¹€à¸¥à¸¢?à¸«à¸£à¸·à¸­à¸­à¸¢à¸²à¸à¹€à¸«à¹‡à¸™ database schema à¹€à¸›à¹‡à¸™ SQL à¸ˆà¸£à¸´à¸‡à¹† à¸à¹ˆà¸­à¸™?à¸šà¸­à¸à¸¡à¸²à¹„à¸”à¹‰à¹€à¸¥à¸¢à¸„à¸£à¸±à¸š à¹à¸¥à¹‰à¸§à¹€à¸£à¸²à¹€à¸£à¸´à¹ˆà¸¡à¸à¸±à¸™à¸—à¸±à¸™à¸—à¸µ! ğŸš€---ğŸ¤– Google AI Studio Prompt Template for SMART NIEMS SystemğŸ“‹ Complete Prompt for Google AI Studio```markdown# SMART NIEMS Web Application Development## ContextYou are an expert full-stack developer specializing in strategic planning and performance management systems. I'm building a modern web application called "SMART NIEMS" (Strategic Management Analysis Reporting Tool for National Institute for Emergency Medicine) to replace an Excel-based strategic planning system.## Attached Files- SMART4CUSM6831_original.xlsx (legacy Excel system with VBA macros)- [Optional: 01CUSM6741.pdf - system documentation]## Your MissionAnalyze the attached Excel file and help me design and develop a comprehensive web application with the following requirements:---## Phase 1: System Analysis & Architecture### Task 1.1: Excel File AnalysisAnalyze the attached Excel file and provide:1. **Data Structure Mapping**   - List all sheets and their purposes   - Identify data entities and relationships   - Map out the navigation flow (Menu 1 â†’ Menu 2)   - Document all named ranges and their dependencies2. **Business Logic Extraction**   - Extract all calculation formulas (SWOT scores, SFAS, BSC calculations)   - Document VBA macro functionalities   - Identify workflow processes (Delphi rounds, approvals)   - List all validation rules3. **Feature Inventory**   Create a comprehensive list of features including:   - Organization profile management   - SWOT Analysis with Delphi methodology   - TOWS Matrix generation   - Balanced Scorecard (4 perspectives)   - Strategy Map with causal relationships   - Hoshin Kanri (X-Matrix)   - Logical Framework Analysis (LFA)   - Project management with Gantt charts   - OKR cascading (Organization â†’ Team â†’ Individual)   - Activity-Based Costing (ABC)### Task 1.2: Technology Stack RecommendationRecommend a modern technology stack considering:- Full TypeScript for type safety- Next.js 14+ with App Router- Prisma ORM with PostgreSQL- tRPC for end-to-end type-safe APIs- Authentication & authorization- Real-time collaboration features- Data visualization libraries (Recharts, D3.js)Provide pros/cons and architecture diagram (Mermaid format).---## Phase 2: Database Design### Task 2.1: Complete Prisma SchemaGenerate a comprehensive Prisma schema that includes:**Core Domains:**1. **Organization Context**   - Organization, Vision, Mission, CoreValues   2. **SWOT Analysis**   - SWOTFactor, DelphiRound, DelphiScore, SWOTAnalyticsSummary   3. **Strategic Position**   - SFASMatrix, CoreCompetency (VRIO), StrategicChallenge   4. **Strategic Frameworks**   - FourActionGrid (BOSS), ValueCurve, POSEAssessment   5. **TOWS Strategy**   - TOWSStrategy, StrategyRationale   6. **Balanced Scorecard**   - BSCPerspective, StrategicObjective, KPI, KPITarget, KPIActual, BSCPerformance   7. **Strategy Map**   - StrategyMapNode, CausalRelationship, ImpactAnalysis   8. **Hoshin Kanri**   - LongTermGoal, AnnualObjective, ImprovementPriority, XMatrixCorrelation   9. **Logical Framework**   - LogframeHierarchy, LogframeElement, IndicatorOVI, MeansOfVerification, Assumption   10. **Project Management**    - Project, WBSElement, Dependency, Milestone, ProjectRisk    11. **Activity-Based Costing**    - ActivityPool, CostDriver, CostAllocation, OverheadCost    12. **OKR System**    - OKRCycle, OKR, KeyResult, OKRUpdate, OKRAlignment, OKRPerformance**System Management:**13. **User Management**    - User, Team, TeamMembership, Permission    14. **Audit Trail** (Required Feature)    - AuditLog, ChangeHistory    15. **Document Management**    - Document, DocumentVersion    16. **Workflow & Approval**    - WorkflowTemplate, ApprovalRequest, ApprovalAction    17. **Notification System**    - NotificationTemplate, Notification    18. **Reporting & Analytics**    - Report, Dashboard, DashboardWidget    19. **Integration & API**    - APIKey, Webhook, IntegrationLog**Requirements:**- Use proper Prisma relations (@relation)- Add appropriate indexes (@@index)- Include timestamps (createdAt, updatedAt)- Add soft delete where applicable (deletedAt)- Use enums for constrained values- Add unique constraints (@@unique)- Include cascade rules for deletions### Task 2.2: Sample Data Seed ScriptCreate a TypeScript seed script with:- 1 sample organization (NIEMS)- 10 SWOT factors (3S, 3W, 2O, 2T)- 1 complete Delphi round with 5 expert scores- 5 strategic objectives across BSC perspectives- 3 KPIs with targets and actuals- 2 projects with WBS- 1 OKR cascade (Org â†’ Team â†’ Individual)---## Phase 3: Role-Based Access Control (RBAC)### Task 3.1: Permission System DesignDesign a comprehensive RBAC system with these roles:**Role Definitions:**1. **Super Admin**   - Full system access   - User management   - System configuration   - Audit log access   - Organization CRUD2. **Organization Admin**   - Manage organization data   - Approve strategies   - View all reports   - Manage teams   - Cannot access system settings3. **Strategic Planner (Manager)**   - Create/edit SWOT, TOWS, BSC   - Manage projects   - Set KPI targets   - Approve OKRs   - View analytics4. **Project Manager**   - Create/edit projects   - Manage WBS and tasks   - Update milestones   - View project reports   - Cannot edit strategies5. **Team Lead (Contributor)**   - Update KPI actuals   - Update OKR progress   - Submit project updates   - Comment on strategies   - Cannot delete data6. **Team Member**   - Update own OKR progress   - View assigned tasks   - Submit activity reports   - Read-only on strategies7. **Viewer (Stakeholder)**   - Read-only access   - View dashboards   - Export reports   - No write permissions**Permission Matrix:**Create a detailed permission matrix table covering:- Domain: Organization, SWOT, TOWS, BSC, Projects, OKRs- Actions: Create, Read, Update, Delete, Approve, Export- Resource-level permissions (own vs. team vs. organization)### Task 3.2: Prisma Schema for RBACExtend the User model with:```model User {id            String         @id @default(cuid())email         String         @uniquerole          UserRolepermissions   Permission[]createdAt     DateTime       @default(now())updatedAt     DateTime       @updatedAt}enum UserRole {SUPER_ADMINORG_ADMINSTRATEGIC_PLANNERPROJECT_MANAGERTEAM_LEADTEAM_MEMBERVIEWER}model Permission {id              String           @id @default(cuid())userId          Stringuser            User             @relation(fields: [userId], references: [id])resourceType    ResourceTyperesourceId      String?          // null = all resourcesactions         PermissionAction[]grantedAt       DateTime         @default(now())grantedBy       StringexpiresAt       DateTime?}enum ResourceType {ORGANIZATIONSWOT_FACTORSTRATEGYKPIPROJECTOKRREPORT}enum PermissionAction {CREATEREADUPDATEDELETEAPPROVEEXPORT}```### Task 3.3: Authorization MiddlewareCreate Next.js middleware/tRPC procedures for:1. Route-level protection2. Resource-level authorization checks3. Permission verification functions4. Role hierarchy enforcementExample:```export const requirePermission = (resourceType: ResourceType,action: PermissionAction) => {return async (ctx: Context) => {// Check if user has permissionconst hasPermission = await checkPermission(ctx.user.id,resourceType,action,ctx.resourceId);    if (!hasPermission) {      throw new TRPCError({ code: 'FORBIDDEN' });    }    };};```---## Phase 4: Audit Trail & Change History### Task 4.1: Audit System DesignDesign a comprehensive audit trail system that:**Captures:**1. **Who**: User ID, username, role2. **What**: Action (CREATE/UPDATE/DELETE/VIEW)3. **When**: Timestamp with timezone4. **Where**: IP address, user agent, endpoint5. **Why**: Optional reason/comment6. **Changes**: Old value vs. New value (JSON diff)**Tracked Entities:**- Organizations- SWOT Factors- Strategies (TOWS)- Strategic Objectives- KPIs (targets and actuals)- Projects- OKRs- User permissions- Approval actions### Task 4.2: Prisma Schema for Audit Trail```model AuditLog {id            String       @id @default(cuid())userId        Stringuser          User         @relation(fields: [userId], references: [id])action        AuditActionentityType    String       // "KPI", "Project", "OKR"entityId      StringentityName    String?      // For displayoldValue      Json?        // Previous statenewValue      Json?        // New statechanges       Json?        // Diff array: [{field, oldVal, newVal}]reason        String?      // Optional commentipAddress     String?userAgent     String?sessionId     String?createdAt     DateTime     @default(now())@@index([userId, createdAt])@@index([entityType, entityId])@@index([action, createdAt])}enum AuditAction {CREATEUPDATEDELETEVIEW_SENSITIVEEXPORTAPPROVEREJECTLOGINLOGOUT}model ChangeHistory {id            String       @id @default(cuid())entityType    StringentityId      StringfieldName     StringoldValue      String?newValue      String?changedBy     StringchangedByUser User         @relation(fields: [changedBy], references: [id])changeReason  String?changedAt     DateTime     @default(now())version       Int          @default(1)@@index([entityType, entityId, changedAt])@@index([changedBy, changedAt])}```### Task 4.3: Audit Middleware ImplementationCreate Prisma middleware to automatically capture changes:```prisma.$use(async (params, next) => {const result = await next(params);// Capture CREATE/UPDATE/DELETE operationsif (['create', 'update', 'delete'].includes(params.action)) {await captureAuditLog({action: params.action,model: params.model,args: params.args,result: result,context: getCurrentContext()});}return result;});```### Task 4.4: Audit Trail UI ComponentsGenerate React components for:1. Audit log viewer (table with filters)2. Change history timeline for entities3. Diff viewer (side-by-side comparison)4. Activity feed dashboard5. Export audit logs to Excel/PDF---## Phase 5: Core Feature Implementation### Task 5.1: SWOT Analysis with Delphi MethodGenerate complete implementation:**Backend (tRPC):**```// swot.router.tsexport const swotRouter = router({// List all SWOT factorslist: publicProcedure.input(z.object({ orgId: z.string() })).query(async ({ input, ctx }) => {// Implementation with audit log}),// Create SWOT factorcreate: protectedProcedure.input(SWOTFactorSchema).mutation(async ({ input, ctx }) => {// Check permission// Create factor// Log audit trail}),// Start Delphi roundstartDelphiRound: protectedProcedure.input(z.object({ orgId: z.string(), roundNumber: z.number() })).mutation(async ({ input, ctx }) => {// Create round// Send notifications to experts// Log action}),// Submit expert scoresubmitScore: protectedProcedure.input(DelphiScoreSchema).mutation(async ({ input, ctx }) => {// Validate expert role// Save score// Check if round complete// Calculate consensus}),// Get SFAS summarygetSFAS: publicProcedure.input(z.object({ orgId: z.string() })).query(async ({ input, ctx }) => {// Calculate weighted scores// Determine strategic position// Return SO/ST/WO/WT quadrant})});```**Frontend (React Component):**```// app/(dashboard)/swot/page.tsxexport default function SWOTAnalysisPage() {// Component with:// - Factor list with inline editing// - Delphi round wizard (multi-step form)// - Score submission interface// - Real-time consensus indicator// - SFAS matrix visualization// - Audit trail sidebar}```### Task 5.2: Balanced Scorecard (BSC)Generate complete implementation:**Features:**- 4 perspectives (Financial, Customer, Internal Process, Learning & Growth)- Strategic objectives hierarchy- KPI management with targets/actuals- Traffic light indicators (ğŸŸ¢ğŸŸ¡ğŸ”´)- Strategy map with causal links- Performance dashboard**Backend:**```// bsc.router.tsexport const bscRouter = router({createObjective: protectedProcedure.input(ObjectiveSchema).mutation(async ({ input, ctx }) => { /* ... */ }),createKPI: protectedProcedure.input(KPISchema).mutation(async ({ input, ctx }) => { /* ... */ }),updateKPIActual: protectedProcedure.input(KPIActualSchema).mutation(async ({ input, ctx }) => {// Check permission (Team Lead+)// Update actual value// Calculate achievement %// Trigger notification if threshold crossed// Log change history}),getPerformanceDashboard: publicProcedure.input(z.object({ orgId: z.string() })).query(async ({ input, ctx }) => {// Aggregate all KPI achievements// Calculate perspective scores// Return traffic light status})});```**Frontend:**```// app/(dashboard)/bsc/page.tsx// - Perspective tabs// - Objective cards with KPIs// - KPI progress bars// - Quick update modal// - Performance charts (Recharts)```### Task 5.3: OKR Cascading SystemGenerate complete implementation:**Features:**- Organization OKRs â†’ Team OKRs â†’ Individual OKRs- Alignment visualization (tree view)- Check-in workflow (weekly/monthly)- Confidence level tracking- Grade calculation (0.0 - 1.0)**Backend:**```// okr.router.tsexport const okrRouter = router({createOKR: protectedProcedure.input(OKRSchema).mutation(async ({ input, ctx }) => {// Validate cascading rules// Check if parent OKR exists// Create OKR// Create alignment record}),updateKeyResult: protectedProcedure.input(KeyResultUpdateSchema).mutation(async ({ input, ctx }) => {// Check ownership// Update progress// Calculate grade// Trigger parent OKR recalculation// Send notification to manager}),getAlignmentTree: publicProcedure.input(z.object({ orgId: z.string() })).query(async ({ input, ctx }) => {// Build hierarchical OKR tree// Include progress and health status})});```**Frontend:**```// app/(dashboard)/okrs/page.tsx// - OKR tree visualization (D3.js)// - Create OKR wizard with parent selection// - Key result progress tracking// - Check-in modal// - Alignment map```---## Phase 6: Advanced Features### Task 6.1: Strategy Map VisualizationGenerate D3.js component for:- Force-directed graph showing objectives- Causal relationship arrows- Color-coded by perspective- Interactive drag-and-drop- Zoom and pan### Task 6.2: Project Management with Gantt ChartGenerate implementation:- WBS tree structure- Gantt chart with dependencies- Critical path highlighting- Milestone markers- Resource allocation view### Task 6.3: Real-time CollaborationImplement using Supabase Realtime:- Live cursors (who's viewing what)- Collaborative editing- Comment threads- @mentions with notifications### Task 6.4: Reporting & ExportGenerate:- Executive summary report- BSC performance report- Project status report- OKR progress report- Export to PDF (react-pdf)- Export to Excel (exceljs)---## Phase 7: Testing & Documentation### Task 7.1: Test SuiteGenerate:- Unit tests for calculations (Jest)- API integration tests- E2E tests for critical flows (Playwright)- Permission boundary tests### Task 7.2: DocumentationGenerate:- API documentation (tRPC auto-docs)- User manual (Markdown)- Admin guide- Deployment guide- Database ER diagram (Mermaid)---## Deliverables ChecklistPlease provide:â˜ Complete Prisma schema (prisma/schema.prisma)â˜ Seed script (prisma/seed.ts)â˜ All tRPC routers with audit trail integrationâ˜ RBAC middleware and permission checksâ˜ React components for all major featuresâ˜ D3.js visualizations (Strategy Map, OKR Tree)â˜ Audit log viewer UIâ˜ Change history UIâ˜ Sample test suiteâ˜ Deployment instructionsâ˜ Architecture diagram (Mermaid)â˜ API documentation---## Output FormatPlease structure your response as follows:1. **Executive Summary**: High-level overview of the system2. **Architecture Decisions**: Tech stack rationale3. **Database Schema**: Complete Prisma schema with comments4. **RBAC Implementation**: Role definitions and middleware5. **Audit Trail Implementation**: Schema + middleware + UI6. **Feature Implementation**: Code for each major feature7. **Deployment Guide**: Step-by-step instructions8. **Next Steps**: Prioritized implementation roadmapFor each code file, use this format:```// File: path/to/file.ts// Purpose: Brief description// Dependencies: List of imports[Complete code here]```---## Additional Instructions- Use TypeScript with strict mode- Follow Next.js 14 App Router conventions- Use tRPC v11 with proper error handling- Implement proper loading and error states- Add proper TypeScript types for all functions- Include comments for complex logic- Follow Prisma best practices- Ensure mobile responsiveness- Add proper SEO meta tags- Implement proper caching strategies---## Questions for ClarificationBefore you start, please clarify:1. Should we use Supabase or raw PostgreSQL?2. Do you need multi-tenancy support?3. What's the expected user scale (10/100/1000+ users)?4. Do you need offline capability?5. Any specific compliance requirements (GDPR, etc.)?---Begin your analysis and implementation now.```---ğŸ“„ Additional Files to AttachFile 1: `requirements.md````markdown# SMART NIEMS System Requirements## Functional Requirements### FR1: User Management- FR1.1: User registration and authentication- FR1.2: Role-based access control (7 roles)- FR1.3: Team management- FR1.4: Permission assignment### FR2: Strategic Analysis- FR2.1: Organization profile management- FR2.2: SWOT analysis with Delphi methodology- FR2.3: TOWS matrix generation- FR2.4: VRIO analysis for core competencies- FR2.5: POSE framework assessment- FR2.6: Blue Ocean Strategy (BOSS) four actions### FR3: Strategic Execution- FR3.1: Balanced Scorecard (4 perspectives)- FR3.2: Strategy map with causal links- FR3.3: Hoshin Kanri (X-Matrix)- FR3.4: Logical Framework Analysis (LFA)- FR3.5: Project portfolio management- FR3.6: OKR cascading (Org â†’ Team â†’ Individual)### FR4: Audit & Compliance- FR4.1: Complete audit trail for all actions- FR4.2: Change history with diff view- FR4.3: Export audit logs- FR4.4: Compliance reporting### FR5: Collaboration- FR5.1: Real-time updates- FR5.2: Comments and discussions- FR5.3: Approval workflows- FR5.4: Notifications## Non-Functional Requirements### NFR1: Performance- Page load time < 2 seconds- API response time < 500ms- Support 100 concurrent users### NFR2: Security- HTTPS encryption- JWT authentication- SQL injection prevention- XSS protection- CSRF tokens### NFR3: Usability- Mobile responsive- Accessibility (WCAG AA)- Multi-language support (Thai/English)### NFR4: Reliability- 99.9% uptime- Automated backups- Disaster recovery plan```File 2: `user-stories.md````markdown# User Stories for SMART NIEMS## Strategic Planner Persona**Name**: Dr. Somchai (Strategic Planning Director)**Goal**: Create comprehensive strategic plan for NIEMS### User Stories:1. As a Strategic Planner, I want to conduct a SWOT analysis using the Delphi method so that I can gather expert opinions systematically.2. As a Strategic Planner, I want to see the SFAS matrix automatically calculated so that I can identify our strategic position quickly.3. As a Strategic Planner, I want to generate TOWS strategies automatically so that I can develop action plans efficiently.4. As a Strategic Planner, I want to create a strategy map with causal relationships so that I can visualize how objectives link together.5. As a Strategic Planner, I want to track who made changes to strategies so that I can maintain accountability.## Project Manager Persona**Name**: Khun Nida (Project Management Office)**Goal**: Manage strategic projects effectively### User Stories:1. As a Project Manager, I want to create a WBS for projects so that I can break down work into manageable tasks.2. As a Project Manager, I want to see a Gantt chart with the critical path so that I can focus on high-risk activities.3. As a Project Manager, I want to update project progress so that stakeholders can track status in real-time.4. As a Project Manager, I want to allocate costs using ABC method so that I can accurately track project expenses.## Team Lead Persona**Name**: Khun Preecha (Emergency Services Team Lead)**Goal**: Track team performance and update KPIs### User Stories:1. As a Team Lead, I want to update KPI actuals so that performance is accurately reflected.2. As a Team Lead, I want to see traffic light indicators for KPIs so that I can quickly identify issues.3. As a Team Lead, I want to check in on team OKRs weekly so that we stay on track.4. As a Team Lead, I want to see what changed in our KPI targets so that I understand the rationale.## Viewer/Stakeholder Persona**Name**: Dr. Prasert (Board Member)**Goal**: Monitor strategic progress### User Stories:1. As a Stakeholder, I want to view the BSC dashboard so that I can see overall organizational performance.2. As a Stakeholder, I want to export reports to PDF so that I can share them in meetings.3. As a Stakeholder, I want to see the audit trail for key decisions so that I can understand the decision-making process.```---ğŸ¯ How to Use This PromptStep 1: Prepare FilesOpen Google AI Studio (aistudio.google.com)Click "Create new prompt"Upload files:âœ… SMART4CUSM6831_original.xlsxâœ… 01CUSM6741.pdf (if you have it)âœ… requirements.md (create from above)âœ… user-stories.md (create from above)Step 2: Paste Main PromptCopy the entire main prompt abovePaste into Google AI StudioSelect model: Gemini 1.5 Pro (best for complex tasks)Step 3: Configure Settings```Temperature: 0.4 (more focused)Top-K: 40Top-P: 0.95Max output tokens: 8192 (maximum)```Step 4: Iterative RefinementAfter first response, ask follow-up questions like:```markdown## Follow-up Prompt 1: Prisma Schema RefinementReview the Prisma schema you generated and:1. Add missing indexes for performance2. Ensure all relations have proper cascade rules3. Add validation constraints4. Generate migration file names5. Suggest partitioning strategy for audit logs## Follow-up Prompt 2: RBAC Deep DiveFor the permission system you designed:1. Generate complete middleware code for all protected routes2. Create helper functions for permission checks3. Provide examples of permission testing4. Show how to handle permission errors gracefully5. Generate UI components for role management## Follow-up Prompt 3: Audit Trail ImplementationFor the audit trail system:1. Show complete Prisma middleware implementation2. Generate React components for audit log viewer3. Create diff algorithm for change detection4. Implement filtering and search functionality5. Add export to Excel feature## Follow-up Prompt 4: Complete Feature ImplementationGenerate complete code for [specific feature]:1. tRPC router with all procedures2. React page component3. Form components with validation4. API integration hooks5. Unit tests6. E2E test scenarios```---ğŸ”„ Alternative: Claude or GPT-4 PromptIf using Claude (Anthropic) or GPT-4, modify the prompt slightly:```markdown[Same main prompt as above, but add at the beginning:]## Model-Specific Instructions (for Claude/GPT-4)You have access to:- Web search (use when you need latest documentation)- Code execution (use for testing calculations)- Multiple responses (provide 2-3 architecture options)Please structure your response with clear sections and use:- Mermaid diagrams for architecture- TypeScript code blocks- Prisma schema blocks- React TSX blocksIf a section exceeds token limits, provide a summary and offer to continue in next message.```---ğŸ’¡ Pro Tips for Best Results1. Be Specific About Priorities```markdown## Priority Features (Must Have - Week 1-4)1. User authentication & RBAC2. Organization profile3. SWOT analysis with Delphi4. Audit trail for SWOT## Secondary Features (Should Have - Week 5-8)1. BSC with KPIs2. Strategy map3. Basic reporting## Future Features (Nice to Have - Week 9-12)1. OKR cascading2. Project management3. Advanced visualizations```2. Request Specific Output Formats```markdownFor each feature, provide:1. âœ… Prisma schema changes (if any)2. âœ… tRPC router code (complete file)3. âœ… React page component (complete file)4. âœ… Zod validation schemas5. âœ… Unit test examples6. âœ… Usage documentationFormat:```// File: packages/api/src/routers/swot.router.ts// Purpose: SWOT analysis CRUD and Delphi rounds// Dependencies: @trpc/server, zod, @prisma/client[complete code]``````3. Ask for Explanations```markdownFor complex implementations, please explain:- Why you chose this approach- Alternative approaches considered- Performance implications- Security considerations- Scalability concerns```4. Request Validation```markdownAfter generating the schema, please:1. Validate all relations are bidirectional2. Check for missing indexes on foreign keys3. Verify enum values match business logic4. Confirm soft delete is implemented where needed5. Check that audit trail captures all entities```---ğŸ“Š Expected Output StructureGoogle AI Studio should provide:Part 1: Analysis (First Response)```1. Executive Summary (500 words)2. System Architecture Diagram (Mermaid)3. Tech Stack Justification (1000 words)4. Feature Breakdown (Table format)5. Database ER Diagram (Mermaid)6. User Flow Diagrams (Mermaid)```Part 2: Implementation (Follow-up Prompts)```1. Complete Prisma Schema (2000+ lines)2. Seed Script (500+ lines)3. All tRPC Routers (3000+ lines)4. RBAC Middleware (500+ lines)5. Audit Trail System (1000+ lines)6. React Components (5000+ lines)7. Test Suites (1000+ lines)```Part 3: Deployment (Final Prompt)```1. Vercel Configuration2. Database Migration Guide3. Environment Variables4. CI/CD Pipeline (GitHub Actions)5. Monitoring Setup6. Troubleshooting Guide```---âœ… Validation ChecklistBefore deploying, verify AI-generated code has:Backend:â˜ All tRPC procedures have proper error handlingâ˜ All mutations check permissionsâ˜ All writes create audit logsâ˜ All queries include proper relationsâ˜ All inputs validated with ZodFrontend:â˜ All forms have client-side validationâ˜ All mutations have loading statesâ˜ All errors display user-friendly messagesâ˜ All tables have paginationâ˜ All charts have error boundariesDatabase:â˜ All foreign keys have indexesâ˜ All enum values are correctâ˜ All required fields are non-nullableâ˜ All timestamps are presentâ˜ All relations have cascade rulesSecurity:â˜ All routes are protectedâ˜ All inputs are sanitizedâ˜ All passwords are hashedâ˜ All tokens are validatedâ˜ All API calls use HTTPS---à¸à¸£à¹‰à¸­à¸¡à¹„à¸›à¸•à¹ˆà¸­à¹à¸¥à¹‰à¸§à¸„à¸£à¸±à¸š! à¸„à¸¸à¸“à¸•à¹‰à¸­à¸‡à¸à¸²à¸£:à¹ƒà¸Šà¹‰ prompt à¸™à¸µà¹‰à¹€à¸¥à¸¢ â†’ Copy-paste à¹„à¸› Google AI Studioà¸›à¸£à¸±à¸šà¹à¸•à¹ˆà¸‡à¹€à¸à¸´à¹ˆà¸¡à¹€à¸•à¸´à¸¡ â†’ à¸šà¸­à¸à¸ªà¹ˆà¸§à¸™à¹„à¸«à¸™à¸—à¸µà¹ˆà¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¹€à¸™à¹‰à¸™à¹€à¸£à¸´à¹ˆà¸¡à¸—à¸µà¸¥à¸°à¸ªà¹ˆà¸§à¸™ â†’ à¹€à¸£à¸´à¹ˆà¸¡à¸ˆà¸²à¸ Database Schema à¸à¹ˆà¸­à¸™à¸”à¸¹à¸•à¸±à¸§à¸­à¸¢à¹ˆà¸²à¸‡ output â†’ à¹ƒà¸«à¹‰à¸œà¸¡à¸ˆà¸³à¸¥à¸­à¸‡ response à¸ˆà¸²à¸ AIà¸šà¸­à¸à¸¡à¸²à¹„à¸”à¹‰à¹€à¸¥à¸¢à¸„à¸£à¸±à¸š! ğŸš€---ğŸ—„ï¸ Database Schema - Part 1: Foundationà¸œà¸¡à¸ˆà¸°à¹€à¸£à¸´à¹ˆà¸¡à¸ªà¸£à¹‰à¸²à¸‡ Database Schema à¹à¸šà¸šà¸—à¸µà¸¥à¸°à¸ªà¹ˆà¸§à¸™ à¹€à¸à¸·à¹ˆà¸­à¹ƒà¸«à¹‰à¹€à¸‚à¹‰à¸²à¹ƒà¸ˆà¸‡à¹ˆà¸²à¸¢à¹à¸¥à¸°à¸ªà¸²à¸¡à¸²à¸£à¸–à¸—à¸”à¸ªà¸­à¸šà¹„à¸”à¹‰à¸—à¸±à¸™à¸—à¸µ---ğŸ“ Project Structure Setup```bash# à¸ªà¸£à¹‰à¸²à¸‡à¹‚à¸„à¸£à¸‡à¸ªà¸£à¹‰à¸²à¸‡à¹‚à¸›à¸£à¹€à¸ˆà¸„smart-niems/â”œâ”€â”€ prisma/â”‚   â”œâ”€â”€ schema.prisma          # Main schemaâ”‚   â”œâ”€â”€ seed.ts                # Seed dataâ”‚   â””â”€â”€ migrations/            # Auto-generatedâ”œâ”€â”€ .env                       # Database connectionâ””â”€â”€ package.json```---ğŸ”§ Step 1: Initial Setup1.1 Install Dependencies```json// package.json{  "name": "smart-niems",  "version": "1.0.0",  "scripts": {    "db:generate": "prisma generate",    "db:push": "prisma db push",    "db:migrate": "prisma migrate dev",    "db:seed": "tsx prisma/seed.ts",    "db:studio": "prisma studio",    "db:reset": "prisma migrate reset --force"  },  "dependencies": {    "@prisma/client": "^5.22.0"  },  "devDependencies": {    "prisma": "^5.22.0",    "tsx": "^4.7.0",    "typescript": "^5.3.3",    "@types/node": "^20.10.0"  }}```1.2 Environment Variables```bash# .envDATABASE_URL="postgresql://user:password@localhost:5432/smart_niems?schema=public"# For production (example)# DATABASE_URL="postgresql://user:password@aws-postgres.com:5432/smart_niems_prod"```---ğŸ“Š Step 2: Core Database Schema (Phase 1)2.1 Foundation Models```prisma// prisma/schema.prismagenerator client {  provider        = "prisma-client-js"  previewFeatures = ["fullTextSearch", "views"]}datasource db {  provider = "postgresql"  url      = env("DATABASE_URL")}// ============================================================================// SECTION 1: USER MANAGEMENT & AUTHENTICATION// ============================================================================enum UserRole {  SUPER_ADMIN           // Full system access  ORG_ADMIN            // Organization management  STRATEGIC_PLANNER    // Strategy & planning  PROJECT_MANAGER      // Project management  TEAM_LEAD            // Team & KPI management  TEAM_MEMBER          // Individual contributor  VIEWER               // Read-only access}enum UserStatus {  ACTIVE  INACTIVE  SUSPENDED  PENDING_ACTIVATION}model User {  id                String      @id @default(cuid())  email             String      @unique  emailVerified     DateTime?  username          String?     @unique  passwordHash      String?     // nullable for OAuth users    // Profile  fullName          String  displayName       String?  positionTitle     String?  phoneNumber       String?  avatar            String?     // URL to avatar image    // Role & Status  role              UserRole    @default(TEAM_MEMBER)  status            UserStatus  @default(PENDING_ACTIVATION)    // Organization relationship  organizationId    String?  organization      Organization? @relation(fields: [organizationId], references: [id], onDelete: SetNull)    // Department/Team  departmentId      String?  department        Department? @relation(fields: [departmentId], references: [id], onDelete: SetNull)    // Settings  locale            String      @default("th") // "th" or "en"  timezone          String      @default("Asia/Bangkok")  preferences       Json?       // User preferences as JSON    // Security  lastLoginAt       DateTime?  lastLoginIp       String?  failedLoginAttempts Int       @default(0)  lockedUntil       DateTime?    // Timestamps  createdAt         DateTime    @default(now())  updatedAt         DateTime    @updatedAt  deletedAt         DateTime?   // Soft delete    // Relations  teamMemberships   TeamMembership[]  permissions       Permission[]  auditLogs         AuditLog[]  changeHistories   ChangeHistory[]  createdOrgs       Organization[] @relation("OrgCreator")  notifications     Notification[]  sessions          Session[]    @@index([email])  @@index([organizationId])  @@index([role])  @@index([status])  @@index([deletedAt])  @@map("users")}model Session {  id           String   @id @default(cuid())  userId       String  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)  token        String   @unique  expiresAt    DateTime  ipAddress    String?  userAgent    String?  createdAt    DateTime @default(now())    @@index([userId])  @@index([token])  @@index([expiresAt])  @@map("sessions")}// ============================================================================// SECTION 2: ORGANIZATION & STRUCTURE// ============================================================================enum OrganizationType {  GOVERNMENT          // à¸«à¸™à¹ˆà¸§à¸¢à¸‡à¸²à¸™à¸£à¸²à¸Šà¸à¸²à¸£  STATE_ENTERPRISE    // à¸£à¸±à¸à¸§à¸´à¸ªà¸²à¸«à¸à¸´à¸ˆ  PRIVATE             // à¹€à¸­à¸à¸Šà¸™  NGO                 // à¸­à¸‡à¸„à¹Œà¸à¸£à¸à¸±à¸’à¸™à¸²à¹€à¸­à¸à¸Šà¸™  INTERNATIONAL       // à¸­à¸‡à¸„à¹Œà¸à¸£à¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡à¸›à¸£à¸°à¹€à¸—à¸¨}enum IndustryLifecycle {  EMBRYONIC           // à¹€à¸à¸´à¹ˆà¸‡à¹€à¸à¸´à¸”à¹ƒà¸«à¸¡à¹ˆ  GROWTH              // à¸à¸³à¸¥à¸±à¸‡à¹€à¸•à¸´à¸šà¹‚à¸•  SHAKEOUT            // à¹€à¸£à¸´à¹ˆà¸¡à¸¡à¸µà¸à¸²à¸£à¹à¸‚à¹ˆà¸‡à¸‚à¸±à¸™  MATURE              // à¹€à¸•à¸´à¸šà¹‚à¸•à¹€à¸•à¹‡à¸¡à¸—à¸µà¹ˆ  DECLINE             // à¹€à¸£à¸´à¹ˆà¸¡à¹€à¸ªà¸·à¹ˆà¸­à¸¡à¸–à¸­à¸¢}model Organization {  id                String              @id @default(cuid())    // Basic Info  code              String              @unique // e.g., "NIEMS", "MOH"  nameTh            String              // à¸Šà¸·à¹ˆà¸­à¸ à¸²à¸©à¸²à¹„à¸—à¸¢  nameEn            String?             // à¸Šà¸·à¹ˆà¸­à¸ à¸²à¸©à¸²à¸­à¸±à¸‡à¸à¸¤à¸©  shortName         String?             // à¸Šà¸·à¹ˆà¸­à¸¢à¹ˆà¸­  acronym           String?             // à¸­à¸±à¸à¸©à¸£à¸¢à¹ˆà¸­ (e.g., "à¸ªà¸à¸‰")    // Classification  organizationType  OrganizationType  industrySector    String?             // à¸ à¸²à¸„à¸­à¸¸à¸•à¸ªà¸²à¸«à¸à¸£à¸£à¸¡  industryLifecycle IndustryLifecycle?    // Contact Info  address           String?  province          String?  postalCode        String?  phoneNumber       String?  email             String?  website           String?    // Planning Period  currentPlanStart  DateTime?  currentPlanEnd    DateTime?  planDuration      Int?                // à¸£à¸°à¸¢à¸°à¹€à¸§à¸¥à¸²à¹à¸œà¸™ (à¸›à¸µ)    // Logo & Branding  logo              String?             // URL to logo  primaryColor      String?             // HEX color code    // Settings  fiscalYearStart   Int                 @default(10) // à¹€à¸”à¸·à¸­à¸™à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸›à¸µà¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“ (10 = à¸•à¸¸à¸¥à¸²à¸„à¸¡)  currency          String              @default("THB")  settings          Json?               // Additional settings    // Status  isActive          Boolean             @default(true)    // Timestamps  createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt  deletedAt         DateTime?  createdById       String?  createdBy         User?               @relation("OrgCreator", fields: [createdById], references: [id], onDelete: SetNull)    // Relations  users             User[]  departments       Department[]  teams             Team[]  vision            Vision?  mission           Mission?  coreValues        CoreValue[]  swotFactors       SWOTFactor[]  strategicObjectives StrategicObjective[]  projects          Project[]  okrCycles         OKRCycle[]    @@index([code])  @@index([organizationType])  @@index([isActive])  @@index([deletedAt])  @@map("organizations")}model Department {  id                String      @id @default(cuid())  organizationId    String  organization      Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)    parentDepartmentId String?  parentDepartment  Department? @relation("DepartmentHierarchy", fields: [parentDepartmentId], references: [id], onDelete: SetNull)  childDepartments  Department[] @relation("DepartmentHierarchy")    code              String      // e.g., "HR", "IT", "OPS"  nameTh            String  nameEn            String?    headUserId        String?     // à¸«à¸±à¸§à¸«à¸™à¹‰à¸²à¸«à¸™à¹ˆà¸§à¸¢à¸‡à¸²à¸™    level             Int         @default(1) // à¸£à¸°à¸”à¸±à¸šà¹ƒà¸™à¸¥à¸³à¸”à¸±à¸šà¸Šà¸±à¹‰à¸™  displayOrder      Int         @default(0)    isActive          Boolean     @default(true)  createdAt         DateTime    @default(now())  updatedAt         DateTime    @updatedAt  deletedAt         DateTime?    users             User[]  teams             Team[]    @@unique([organizationId, code])  @@index([organizationId])  @@index([parentDepartmentId])  @@map("departments")}model Team {  id                String      @id @default(cuid())  organizationId    String  organization      Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)    departmentId      String?  department        Department? @relation(fields: [departmentId], references: [id], onDelete: SetNull)    parentTeamId      String?  parentTeam        Team?       @relation("TeamHierarchy", fields: [parentTeamId], references: [id], onDelete: SetNull)  childTeams        Team[]      @relation("TeamHierarchy")    code              String  name              String  description       String?    teamLeadId        String?     // Team leader user ID    teamType          TeamType    @default(FUNCTIONAL)    isActive          Boolean     @default(true)  createdAt         DateTime    @default(now())  updatedAt         DateTime    @updatedAt  deletedAt         DateTime?    members           TeamMembership[]  okrs              OKR[]    @@unique([organizationId, code])  @@index([organizationId])  @@index([departmentId])  @@index([parentTeamId])  @@map("teams")}enum TeamType {  FUNCTIONAL          // à¸—à¸µà¸¡à¸›à¸£à¸°à¸ˆà¸³  CROSS_FUNCTIONAL    // à¸—à¸µà¸¡à¸‚à¹‰à¸²à¸¡à¸ªà¸²à¸¢à¸‡à¸²à¸™  PROJECT             // à¸—à¸µà¸¡à¹‚à¸„à¸£à¸‡à¸à¸²à¸£  TEMPORARY           // à¸—à¸µà¸¡à¸Šà¸±à¹ˆà¸§à¸„à¸£à¸²à¸§}model TeamMembership {  id          String    @id @default(cuid())  teamId      String  team        Team      @relation(fields: [teamId], references: [id], onDelete: Cascade)    userId      String  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)    role        String?   // e.g., "Member", "Lead", "Scrum Master"    isActive    Boolean   @default(true)  joinDate    DateTime  @default(now())  leaveDate   DateTime?    createdAt   DateTime  @default(now())  updatedAt   DateTime  @updatedAt    @@unique([teamId, userId])  @@index([teamId])  @@index([userId])  @@map("team_memberships")}// ============================================================================// SECTION 3: STRATEGIC CONTEXT (Vision, Mission, Values)// ============================================================================model Vision {  id                String        @id @default(cuid())  organizationId    String        @unique  organization      Organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade)    visionStatementTh String        @db.Text  visionStatementEn String?       @db.Text    targetYear        Int?          // à¸›à¸µà¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢ (e.g., 2580)    keyAspiration     String?       @db.Text // à¹à¸£à¸‡à¸šà¸±à¸™à¸”à¸²à¸¥à¹ƒà¸ˆà¸«à¸¥à¸±à¸    version           Int           @default(1)  status            VisionStatus  @default(DRAFT)    approvedAt        DateTime?  approvedById      String?    createdAt         DateTime      @default(now())  updatedAt         DateTime      @updatedAt    @@index([organizationId])  @@map("visions")}enum VisionStatus {  DRAFT  PENDING_APPROVAL  APPROVED  ARCHIVED}model Mission {  id                String        @id @default(cuid())  organizationId    String        @unique  organization      Organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade)    missionStatementTh String       @db.Text  missionStatementEn String?      @db.Text    keyPurpose        String?       @db.Text // à¸§à¸±à¸•à¸–à¸¸à¸›à¸£à¸°à¸ªà¸‡à¸„à¹Œà¸«à¸¥à¸±à¸    version           Int           @default(1)  status            VisionStatus  @default(DRAFT)    approvedAt        DateTime?  approvedById      String?    createdAt         DateTime      @default(now())  updatedAt         DateTime      @updatedAt    @@index([organizationId])  @@map("missions")}model CoreValue {  id                String        @id @default(cuid())  organizationId    String  organization      Organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade)    code              String        // e.g., "H", "E", "A", "L", "T", "H", "Y" for HEALTHY  valueName         String        // e.g., "Holistic"  valueDescription  String        @db.Text    displayOrder      Int           @default(0)    isActive          Boolean       @default(true)  createdAt         DateTime      @default(now())  updatedAt         DateTime      @updatedAt    @@unique([organizationId, code])  @@index([organizationId])  @@map("core_values")}// ============================================================================// SECTION 4: SWOT ANALYSIS & DELPHI METHOD// ============================================================================enum SWOTCategory {  STRENGTH      // à¸ˆà¸¸à¸”à¹à¸‚à¹‡à¸‡  WEAKNESS      // à¸ˆà¸¸à¸”à¸­à¹ˆà¸­à¸™  OPPORTUNITY   // à¹‚à¸­à¸à¸²à¸ª  THREAT        // à¸­à¸¸à¸›à¸ªà¸£à¸£à¸„}model SWOTFactor {  id                String        @id @default(cuid())  organizationId    String  organization      Organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade)    factorCode        String        // "S01", "W03", "O05", "T02"  category          SWOTCategory    descriptionTh     String        @db.Text  descriptionEn     String?       @db.Text    // Metadata  source            String?       // à¹à¸«à¸¥à¹ˆà¸‡à¸—à¸µà¹ˆà¸¡à¸² (e.g., "Workshop", "Survey", "Expert Interview")  evidenceLinks     String?       @db.Text // à¸¥à¸´à¸‡à¸à¹Œà¹„à¸›à¸¢à¸±à¸‡à¸«à¸¥à¸±à¸à¸à¸²à¸™    // Scoring (calculated from Delphi rounds)  averageScore      Float?        @default(0)  weightNormalized  Float?        @default(0) // à¸™à¹‰à¸³à¸«à¸™à¸±à¸à¸—à¸µà¹ˆ normalize à¹à¸¥à¹‰à¸§  weightedScore     Float?        @default(0) // à¸„à¸°à¹à¸™à¸™à¸–à¹ˆà¸§à¸‡à¸™à¹‰à¸³à¸«à¸™à¸±à¸  rankInCategory    Int?          // à¸­à¸±à¸™à¸”à¸±à¸šà¹ƒà¸™à¸«à¸¡à¸§à¸”    // Consensus level from Delphi  consensusLevel    Float?        // 0-1 (1 = consensus à¸ªà¸¹à¸‡)  standardDeviation Float?        // à¸„à¹ˆà¸²à¹€à¸šà¸µà¹ˆà¸¢à¸‡à¹€à¸šà¸™à¸¡à¸²à¸•à¸£à¸à¸²à¸™    isActive          Boolean       @default(true)  createdAt         DateTime      @default(now())  updatedAt         DateTime      @updatedAt  deletedAt         DateTime?  createdById       String?    delphiScores      DelphiScore[]    @@unique([organizationId, factorCode])  @@index([organizationId, category])  @@index([category])  @@map("swot_factors")}enum DelphiRoundStatus {  DRAFT             // à¸à¸³à¸¥à¸±à¸‡à¹€à¸•à¸£à¸µà¸¢à¸¡  ACTIVE            // à¹€à¸›à¸´à¸”à¹ƒà¸«à¹‰à¸—à¸³  CLOSED            // à¸›à¸´à¸”à¹à¸¥à¹‰à¸§  ANALYSING         // à¸à¸³à¸¥à¸±à¸‡à¸§à¸´à¹€à¸„à¸£à¸²à¸°à¸«à¹Œ  COMPLETED         // à¹€à¸ªà¸£à¹‡à¸ˆà¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œ}model DelphiRound {  id                String              @id @default(cuid())  organizationId    String    roundNumber       Int                 // 1, 2, 3, 4, 5  roundName         String?             // e.g., "Round 1: Initial Assessment"    status            DelphiRoundStatus   @default(DRAFT)    instructions      String?             @db.Text // à¸„à¸³à¹à¸™à¸°à¸™à¸³à¸ªà¸³à¸«à¸£à¸±à¸šà¸œà¸¹à¹‰à¹€à¸Šà¸µà¹ˆà¸¢à¸§à¸Šà¸²à¸    startDate         DateTime?  endDate           DateTime?  actualEndDate     DateTime?    targetExpertCount Int?                // à¸ˆà¸³à¸™à¸§à¸™à¸œà¸¹à¹‰à¹€à¸Šà¸µà¹ˆà¸¢à¸§à¸Šà¸²à¸à¸—à¸µà¹ˆà¸•à¹‰à¸­à¸‡à¸à¸²à¸£  actualExpertCount Int                 @default(0) // à¸ˆà¸³à¸™à¸§à¸™à¸—à¸µà¹ˆà¸•à¸­à¸šà¸ˆà¸£à¸´à¸‡    // Consensus threshold  consensusThreshold Float              @default(0.7) // à¸–à¹‰à¸² consensus >= 0.7 à¸–à¸·à¸­à¸§à¹ˆà¸²à¸•à¸à¸¥à¸‡à¸à¸±à¸™    createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt    scores            DelphiScore[]    @@unique([organizationId, roundNumber])  @@index([organizationId])  @@index([status])  @@map("delphi_rounds")}model DelphiScore {  id                String        @id @default(cuid())    factorId          String  factor            SWOTFactor    @relation(fields: [factorId], references: [id], onDelete: Cascade)    roundId           String  round             DelphiRound   @relation(fields: [roundId], references: [id], onDelete: Cascade)    expertId          String  expertName        String?       // à¸Šà¸·à¹ˆà¸­à¸œà¸¹à¹‰à¹€à¸Šà¸µà¹ˆà¸¢à¸§à¸Šà¸²à¸ (optional for anonymity)  expertRole        String?       // à¸šà¸—à¸šà¸²à¸—à¸‚à¸­à¸‡à¸œà¸¹à¹‰à¹€à¸Šà¸µà¹ˆà¸¢à¸§à¸Šà¸²à¸    // Multiple scoring dimensions  importanceScore   Float         // à¸„à¸§à¸²à¸¡à¸ªà¸³à¸„à¸±à¸ (0-5)  feasibilityScore  Float?        // à¸„à¸§à¸²à¸¡à¹€à¸›à¹‡à¸™à¹„à¸›à¹„à¸”à¹‰ (0-5)  urgencyScore      Float?        // à¸„à¸§à¸²à¸¡à¹€à¸£à¹ˆà¸‡à¸”à¹ˆà¸§à¸™ (0-5)  impactScore       Float?        // à¸œà¸¥à¸à¸£à¸°à¸—à¸š (0-5)    // Overall score (can be average or weighted)  overallScore      Float         // à¸„à¸°à¹à¸™à¸™à¸£à¸§à¸¡ (0-5)    // Qualitative feedback  comment           String?       @db.Text  rationale         String?       @db.Text // à¹€à¸«à¸•à¸¸à¸œà¸¥à¹ƒà¸™à¸à¸²à¸£à¹ƒà¸«à¹‰à¸„à¸°à¹à¸™à¸™    // Confidence level  confidenceLevel   Float?        // 0-5 (à¸„à¸§à¸²à¸¡à¸¡à¸±à¹ˆà¸™à¹ƒà¸ˆà¹ƒà¸™à¸„à¸°à¹à¸™à¸™à¸—à¸µà¹ˆà¹ƒà¸«à¹‰)    scoredAt          DateTime      @default(now())  updatedAt         DateTime      @updatedAt    @@unique([factorId, roundId, expertId])  @@index([factorId])  @@index([roundId])  @@index([expertId])  @@map("delphi_scores")}```---ğŸ“ Step 3: Create Seed Data```typescript// prisma/seed.tsimport { PrismaClient, UserRole, OrganizationType, SWOTCategory } from '@prisma/client'const prisma = new PrismaClient()async function main() {  console.log('ğŸŒ± Starting seed...')  // 1. Create Super Admin User  const adminUser = await prisma.user.upsert({    where: { email: 'admin@niems.go.th' },    update: {},    create: {      email: 'admin@niems.go.th',      username: 'admin',      passwordHash: '$2a$10$example...', // bcrypt hash of "password123"      fullName: 'System Administrator',      displayName: 'Admin',      role: UserRole.SUPER_ADMIN,      status: 'ACTIVE',      locale: 'th',    },  })  console.log('âœ… Created admin user:', adminUser.email)  // 2. Create NIEMS Organization  const niems = await prisma.organization.upsert({    where: { code: 'NIEMS' },    update: {},    create: {      code: 'NIEMS',      nameTh: 'à¸ªà¸–à¸²à¸šà¸±à¸™à¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œà¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¹à¸«à¹ˆà¸‡à¸Šà¸²à¸•à¸´',      nameEn: 'National Institute for Emergency Medicine',      shortName: 'à¸ªà¸à¸‰',      acronym: 'NIEMS',      organizationType: OrganizationType.GOVERNMENT,      industrySector: 'Healthcare / Emergency Medical Services',      industryLifecycle: 'GROWTH',      currentPlanStart: new Date('2023-10-01'),      currentPlanEnd: new Date('2027-09-30'),      planDuration: 4,      website: 'https://www.niems.go.th',      fiscalYearStart: 10, // à¸•à¸¸à¸¥à¸²à¸„à¸¡      createdById: adminUser.id,    },  })  console.log('âœ… Created organization:', niems.nameTh)  // 3. Create Vision  const vision = await prisma.vision.upsert({    where: { organizationId: niems.id },    update: {},    create: {      organizationId: niems.id,      visionStatementTh: 'à¹€à¸›à¹‡à¸™à¸­à¸‡à¸„à¹Œà¸à¸£à¸Šà¸±à¹‰à¸™à¸™à¸³à¸”à¹‰à¸²à¸™à¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œà¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸—à¸µà¹ˆà¹„à¸”à¹‰à¸¡à¸²à¸•à¸£à¸à¸²à¸™à¸ªà¸²à¸à¸¥ à¸ªà¸²à¸¡à¸²à¸£à¸–à¸”à¸¹à¹à¸¥à¸œà¸¹à¹‰à¸›à¹ˆà¸§à¸¢à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¹„à¸”à¹‰à¸­à¸¢à¹ˆà¸²à¸‡à¸¡à¸µà¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸ à¸²à¸ à¸¥à¸”à¸­à¸±à¸•à¸£à¸²à¸à¸²à¸£à¹€à¸ªà¸µà¸¢à¸Šà¸µà¸§à¸´à¸•à¹à¸¥à¸°à¸„à¸§à¸²à¸¡à¸à¸´à¸à¸²à¸£',      visionStatementEn: 'To be a leading organization in emergency medical services with international standards, capable of efficient emergency care, reducing mortality and disability rates',      targetYear: 2027,      version: 1,      status: 'APPROVED',      approvedAt: new Date(),    },  })  console.log('âœ… Created vision')  // 4. Create Mission  const mission = await prisma.mission.upsert({    where: { organizationId: niems.id },    update: {},    create: {      organizationId: niems.id,      missionStatementTh: 'à¸à¸±à¸’à¸™à¸²à¸£à¸°à¸šà¸šà¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œà¸‰à¸¸à¸à¹€à¸‰à¸´à¸™ à¸¢à¸à¸£à¸°à¸”à¸±à¸šà¸¡à¸²à¸•à¸£à¸à¸²à¸™à¸šà¸¸à¸„à¸¥à¸²à¸à¸£ à¸ªà¸£à¹‰à¸²à¸‡à¸™à¸§à¸±à¸•à¸à¸£à¸£à¸¡à¸à¸²à¸£à¸”à¸¹à¹à¸¥à¸œà¸¹à¹‰à¸›à¹ˆà¸§à¸¢ à¹à¸¥à¸°à¸ªà¸£à¹‰à¸²à¸‡à¹€à¸„à¸£à¸·à¸­à¸‚à¹ˆà¸²à¸¢à¸„à¸§à¸²à¸¡à¸£à¹ˆà¸§à¸¡à¸¡à¸·à¸­à¸—à¸µà¹ˆà¹€à¸‚à¹‰à¸¡à¹à¸‚à¹‡à¸‡',      missionStatementEn: 'Develop emergency medical systems, elevate personnel standards, create patient care innovations, and build strong collaborative networks',      version: 1,      status: 'APPROVED',      approvedAt: new Date(),    },  })  console.log('âœ… Created mission')  // 5. Create Core Values (HEALTHY framework)  const coreValues = [    { code: 'H', name: 'Holistic', desc: 'à¸¡à¸¸à¸¡à¸¡à¸­à¸‡à¹à¸šà¸šà¸­à¸‡à¸„à¹Œà¸£à¸§à¸¡ à¸„à¸³à¸™à¸¶à¸‡à¸–à¸¶à¸‡à¸—à¸¸à¸à¸¡à¸´à¸•à¸´à¸‚à¸­à¸‡à¸à¸²à¸£à¸”à¸¹à¹à¸¥à¸œà¸¹à¹‰à¸›à¹ˆà¸§à¸¢' },    { code: 'E', name: 'Equity', desc: 'à¸„à¸§à¸²à¸¡à¹€à¸ªà¸¡à¸­à¸ à¸²à¸„ à¹ƒà¸«à¹‰à¸šà¸£à¸´à¸à¸²à¸£à¸­à¸¢à¹ˆà¸²à¸‡à¹€à¸—à¹ˆà¸²à¹€à¸—à¸µà¸¢à¸¡à¸—à¸¸à¸à¸à¸·à¹‰à¸™à¸—à¸µà¹ˆ' },    { code: 'A', name: 'Advancement', desc: 'à¸à¹‰à¸²à¸§à¸«à¸™à¹‰à¸² à¸à¸±à¸’à¸™à¸²à¸­à¸¢à¹ˆà¸²à¸‡à¸•à¹ˆà¸­à¹€à¸™à¸·à¹ˆà¸­à¸‡' },    { code: 'L', name: 'Learning', desc: 'à¸à¸²à¸£à¹€à¸£à¸µà¸¢à¸™à¸£à¸¹à¹‰ à¹à¸¥à¸à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸„à¸§à¸²à¸¡à¸£à¸¹à¹‰à¹à¸¥à¸°à¸›à¸£à¸°à¸ªà¸šà¸à¸²à¸£à¸“à¹Œ' },    { code: 'T', name: 'Teamwork', desc: 'à¸—à¸³à¸‡à¸²à¸™à¹€à¸›à¹‡à¸™à¸—à¸µà¸¡ à¸›à¸£à¸°à¸ªà¸²à¸™à¸‡à¸²à¸™à¸­à¸¢à¹ˆà¸²à¸‡à¸¡à¸µà¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸ à¸²à¸' },    { code: 'H2', name: 'Healthy', desc: 'à¸ªà¸¸à¸‚à¸ à¸²à¸§à¸°à¸—à¸µà¹ˆà¸”à¸µ à¸—à¸±à¹‰à¸‡à¸œà¸¹à¹‰à¸›à¹ˆà¸§à¸¢à¹à¸¥à¸°à¸šà¸¸à¸„à¸¥à¸²à¸à¸£' },    { code: 'Y', name: 'Yield', desc: 'à¸œà¸¥à¸¥à¸±à¸à¸˜à¹Œà¸—à¸µà¹ˆà¹€à¸›à¹‡à¸™à¸£à¸¹à¸›à¸˜à¸£à¸£à¸¡ à¸§à¸±à¸”à¸œà¸¥à¹„à¸”à¹‰' },  ]  for (const [index, value] of coreValues.entries()) {    await prisma.coreValue.upsert({      where: {        organizationId_code: {          organizationId: niems.id,          code: value.code,        },      },      update: {},      create: {        organizationId: niems.id,        code: value.code,        valueName: value.name,        valueDescription: value.desc,        displayOrder: index + 1,      },    })  }  console.log('âœ… Created 7 core values')  // 6. Create Strategic Planner User  const planner = await prisma.user.upsert({    where: { email: 'planner@niems.go.th' },    update: {},    create: {      email: 'planner@niems.go.th',      username: 'planner',      passwordHash: '$2a$10$example...', // bcrypt hash      fullName: 'à¸™à¸²à¸¢à¸ªà¸¡à¸Šà¸²à¸¢ à¹ƒà¸ˆà¸”à¸µ',      displayName: 'à¸„à¸¸à¸“à¸ªà¸¡à¸Šà¸²à¸¢',      positionTitle: 'à¸™à¸±à¸à¸§à¸²à¸‡à¹à¸œà¸™à¸¢à¸¸à¸—à¸˜à¸¨à¸²à¸ªà¸•à¸£à¹Œ',      role: UserRole.STRATEGIC_PLANNER,      status: 'ACTIVE',      organizationId: niems.id,      locale: 'th',    },  })  console.log('âœ… Created planner user:', planner.email)  // 7. Create SWOT Factors  const swotFactors = [    // Strengths    {      code: 'S01',      category: SWOTCategory.STRENGTH,      desc: 'à¸¡à¸µà¹€à¸„à¸£à¸·à¸­à¸‚à¹ˆà¸²à¸¢à¹à¸¥à¸°à¸£à¸°à¸šà¸šà¸à¸²à¸£à¸ªà¹ˆà¸‡à¸•à¹ˆà¸­à¸œà¸¹à¹‰à¸›à¹ˆà¸§à¸¢à¸—à¸µà¹ˆà¸„à¸£à¸­à¸šà¸„à¸¥à¸¸à¸¡à¸—à¸±à¹ˆà¸§à¸›à¸£à¸°à¹€à¸—à¸¨',      source: 'Workshop 2023',    },    {      code: 'S02',      category: SWOTCategory.STRENGTH,      desc: 'à¸¡à¸µà¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¸—à¸µà¹ˆà¸¡à¸µà¸„à¸§à¸²à¸¡à¹€à¸Šà¸µà¹ˆà¸¢à¸§à¸Šà¸²à¸à¸”à¹‰à¸²à¸™à¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œà¸‰à¸¸à¸à¹€à¸‰à¸´à¸™',      source: 'Expert Interview',    },    {      code: 'S03',      category: SWOTCategory.STRENGTH,      desc: 'à¸¡à¸µà¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹à¸¥à¸°à¸£à¸°à¸šà¸šà¸ªà¸²à¸£à¸ªà¸™à¹€à¸—à¸¨à¸—à¸µà¹ˆà¸—à¸±à¸™à¸ªà¸¡à¸±à¸¢',      source: 'Internal Assessment',    },    // Weaknesses    {      code: 'W01',      category: SWOTCategory.WEAKNESS,      desc: 'à¸à¸²à¸£à¸à¸£à¸°à¸ˆà¸²à¸¢à¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¹„à¸¡à¹ˆà¹€à¸—à¹ˆà¸²à¹€à¸—à¸µà¸¢à¸¡à¸à¸±à¸™ à¹€à¸™à¹‰à¸™à¹ƒà¸™à¹€à¸¡à¸·à¸­à¸‡à¹ƒà¸«à¸à¹ˆ',      source: 'Survey 2023',    },    {      code: 'W02',      category: SWOTCategory.WEAKNESS,      desc: 'à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“à¸ˆà¸³à¸à¸±à¸” à¹„à¸¡à¹ˆà¹€à¸à¸µà¸¢à¸‡à¸à¸­à¸•à¹ˆà¸­à¸à¸²à¸£à¸à¸±à¸’à¸™à¸²à¸£à¸°à¸šà¸š',      source: 'Financial Report',    },    {      code: 'W03',      category: SWOTCategory.WEAKNESS,      desc: 'à¸‚à¸²à¸”à¸à¸²à¸£à¸šà¸¹à¸£à¸“à¸²à¸à¸²à¸£à¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡à¸«à¸™à¹ˆà¸§à¸¢à¸‡à¸²à¸™à¸—à¸µà¹ˆà¹€à¸à¸µà¹ˆà¸¢à¸§à¸‚à¹‰à¸­à¸‡',      source: 'Workshop 2023',    },    // Opportunities    {      code: 'O01',      category: SWOTCategory.OPPORTUNITY,      desc: 'à¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µ AI à¹à¸¥à¸° IoT à¸ªà¸²à¸¡à¸²à¸£à¸–à¸™à¸³à¸¡à¸²à¸à¸±à¸’à¸™à¸²à¸£à¸°à¸šà¸šà¸‰à¸¸à¸à¹€à¸‰à¸´à¸™',      source: 'Technology Trend Analysis',    },    {      code: 'O02',      category: SWOTCategory.OPPORTUNITY,      desc: 'à¸™à¹‚à¸¢à¸šà¸²à¸¢à¸£à¸±à¸à¸šà¸²à¸¥à¸ªà¸™à¸±à¸šà¸ªà¸™à¸¸à¸™à¸à¸²à¸£à¸à¸±à¸’à¸™à¸²à¸£à¸°à¸šà¸šà¸ªà¸¸à¸‚à¸ à¸²à¸',      source: 'Policy Review',    },    // Threats    {      code: 'T01',      category: SWOTCategory.THREAT,      desc: 'à¸ à¸±à¸¢à¸à¸´à¸šà¸±à¸•à¸´à¸˜à¸£à¸£à¸¡à¸Šà¸²à¸•à¸´à¸—à¸µà¹ˆà¹€à¸à¸´à¹ˆà¸¡à¸‚à¸¶à¹‰à¸™ à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸£à¸°à¸šà¸šà¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸—à¸µà¹ˆà¹à¸‚à¹‡à¸‡à¹à¸à¸£à¹ˆà¸‡',      source: 'Risk Assessment',    },    {      code: 'T02',      category: SWOTCategory.THREAT,      desc: 'à¸à¸²à¸£à¹à¸‚à¹ˆà¸‡à¸‚à¸±à¸™à¸”à¹‰à¸²à¸™à¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¸à¸±à¸šà¸ à¸²à¸„à¹€à¸­à¸à¸Šà¸™',      source: 'HR Analysis',    },  ]  for (const factor of swotFactors) {    await prisma.sWOTFactor.upsert({      where: {        organizationId_factorCode: {          organizationId: niems.id,          factorCode: factor.code,        },      },      update: {},      create: {        organizationId: niems.id,        factorCode: factor.code,        category: factor.category,        descriptionTh: factor.desc,        source: factor.source,        createdById: planner.id,      },    })  }  console.log('âœ… Created 10 SWOT factors')  // 8. Create Delphi Round 1  const delphiRound1 = await prisma.delphiRound.create({    data: {      organizationId: niems.id,      roundNumber: 1,      roundName: 'à¸£à¸­à¸šà¸—à¸µà¹ˆ 1: à¸à¸²à¸£à¸›à¸£à¸°à¹€à¸¡à¸´à¸™à¹€à¸šà¸·à¹‰à¸­à¸‡à¸•à¹‰à¸™',      status: 'COMPLETED',      instructions: 'à¸à¸£à¸¸à¸“à¸²à¹ƒà¸«à¹‰à¸„à¸°à¹à¸™à¸™à¸„à¸§à¸²à¸¡à¸ªà¸³à¸„à¸±à¸à¸‚à¸­à¸‡à¹à¸•à¹ˆà¸¥à¸°à¸›à¸±à¸ˆà¸ˆà¸±à¸¢ SWOT à¹ƒà¸™à¸£à¸°à¸”à¸±à¸š 0-5',      startDate: new Date('2023-11-01'),      endDate: new Date('2023-11-15'),      actualEndDate: new Date('2023-11-14'),      targetExpertCount: 5,      actualExpertCount: 5,    },  })  console.log('âœ… Created Delphi Round 1')  // 9. Create Delphi Scores (5 experts Ã— 10 factors = 50 scores)  const experts = [    { id: 'expert1', name: 'à¸œà¸¨.à¸™à¸.à¸ªà¸¡à¸Šà¸²à¸¢ à¸§à¸‡à¸¨à¹Œà¹ƒà¸«à¸à¹ˆ', role: 'Emergency Medicine Specialist' },    { id: 'expert2', name: 'à¸”à¸£.à¸ªà¸¸à¸ à¸²à¸à¸£ à¹ƒà¸ˆà¸”à¸µ', role: 'Public Health Expert' },    { id: 'expert3', name: 'à¸œà¸­.à¸§à¸´à¸Šà¸±à¸¢ à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡', role: 'EMS Director' },    { id: 'expert4', name: 'à¸£à¸¨.à¸™à¸.à¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¹Œ à¸¡à¸±à¹ˆà¸™à¸„à¸‡', role: 'Healthcare Policy Analyst' },    { id: 'expert5', name: 'à¸™à¸²à¸‡à¸ªà¸²à¸§à¸¡à¸²à¸¥à¸µ à¸ªà¸§à¹ˆà¸²à¸‡à¹„à¸ªà¸§', role: 'Healthcare Administrator' },  ]  const allFactors = await prisma.sWOTFactor.findMany({    where: { organizationId: niems.id },  })  for (const factor of allFactors) {    for (const expert of experts) {      // Random scores for demo (à¹ƒà¸™à¸£à¸°à¸šà¸šà¸ˆà¸£à¸´à¸‡à¸ˆà¸°à¹€à¸›à¹‡à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸ˆà¸²à¸à¸œà¸¹à¹‰à¹€à¸Šà¸µà¹ˆà¸¢à¸§à¸Šà¸²à¸)      const importance = Math.random() * 2 + 3 // 3.0-5.0      const feasibility = Math.random() * 2 + 3      const urgency = Math.random() * 2 + 2.5      const impact = Math.random() * 2 + 3      await prisma.delphiScore.create({        data: {          factorId: factor.id,          roundId: delphiRound1.id,          expertId: expert.id,          expertName: expert.name,          expertRole: expert.role,          importanceScore: importance,          feasibilityScore: feasibility,          urgencyScore: urgency,          impactScore: impact,          overallScore: (importance + feasibility + urgency + impact) / 4,          confidenceLevel: Math.random() * 1 + 4, // 4.0-5.0          comment: `à¸„à¸°à¹à¸™à¸™à¸ˆà¸²à¸à¸à¸²à¸£à¸›à¸£à¸°à¹€à¸¡à¸´à¸™à¹ƒà¸™à¸£à¸­à¸šà¸—à¸µà¹ˆ 1`,        },      })    }  }  console.log('âœ… Created 50 Delphi scores (5 experts Ã— 10 factors)')  // 10. Update SWOT factors with calculated scores  for (const factor of allFactors) {    const scores = await prisma.delphiScore.findMany({      where: {        factorId: factor.id,        roundId: delphiRound1.id,      },    })    const avgScore = scores.reduce((sum, s) => sum + s.overallScore, 0) / scores.length    const stdDev = Math.sqrt(      scores.reduce((sum, s) => sum + Math.pow(s.overallScore - avgScore, 2), 0) / scores.length    )    const consensus = 1 - stdDev / 5 // à¸¢à¸´à¹ˆà¸‡ stdDev à¸•à¹ˆà¸³ = consensus à¸ªà¸¹à¸‡    await prisma.sWOTFactor.update({      where: { id: factor.id },      data: {        averageScore: avgScore,        consensusLevel: consensus,        standardDeviation: stdDev,      },    })  }  console.log('âœ… Updated SWOT factors with calculated scores')  console.log('\nğŸ‰ Seed completed successfully!')}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error('âŒ Seed failed:', e)    await prisma.$disconnect()    process.exit(1)  })```---ğŸš€ Step 4: Commands to Run```bash# 1. Install dependenciespnpm install# 2. Generate Prisma Clientpnpm db:generate# 3. Push schema to database (for development)pnpm db:push# OR create migration (for production)pnpm db:migrate# 4. Run seedpnpm db:seed# 5. Open Prisma Studio to view datapnpm db:studio```---âœ… Verification Checklistà¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸à¸£à¸±à¸™ seed à¹à¸¥à¹‰à¸§ à¹ƒà¸«à¹‰à¹€à¸Šà¹‡à¸„à¸§à¹ˆà¸²à¸¡à¸µà¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸„à¸£à¸šà¸”à¸±à¸‡à¸™à¸µà¹‰:```âœ… 1 Super Admin user (admin@niems.go.th)âœ… 1 Strategic Planner user (planner@niems.go.th)âœ… 1 Organization (NIEMS)âœ… 1 Visionâœ… 1 Missionâœ… 7 Core Values (HEALTHY)âœ… 10 SWOT Factors (3S, 3W, 2O, 2T)âœ… 1 Delphi Round (completed)âœ… 50 Delphi Scores (5 experts Ã— 10 factors)```---ğŸ“Š Query Examples```typescript// lib/prisma.tsimport { PrismaClient } from '@prisma/client'const globalForPrisma = global as unknown as { prisma: PrismaClient }export const prisma = globalForPrisma.prisma || new PrismaClient()if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma// Example queries:// 1. Get organization with all SWOT factorsconst orgWithSWOT = await prisma.organization.findUnique({  where: { code: 'NIEMS' },  include: {    swotFactors: {      where: { isActive: true },      orderBy: [{ category: 'asc' }, { averageScore: 'desc' }],    },    vision: true,    mission: true,    coreValues: {      orderBy: { displayOrder: 'asc' },    },  },})// 2. Get Strengths with top scoresconst topStrengths = await prisma.sWOTFactor.findMany({  where: {    organizationId: 'xxx',    category: 'STRENGTH',    isActive: true,  },  orderBy: { averageScore: 'desc' },  take: 5,  include: {    delphiScores: {      include: {        round: true,      },    },  },})// 3. Get Delphi round with scores and consensusconst delphiData = await prisma.delphiRound.findUnique({  where: { id: 'xxx' },  include: {    scores: {      include: {        factor: true,      },      orderBy: { overallScore: 'desc' },    },  },})// 4. Calculate SFAS (Strategic Factor Analysis Summary)const swotSummary = await prisma.sWOTFactor.groupBy({  by: ['category'],  where: {    organizationId: 'xxx',    isActive: true,  },  _sum: {    weightedScore: true,  },  _count: true,})// Result: { S: 10.5, W: -8.2, O: 9.8, T: -7.5 }// Position: S+O > W+T = Aggressive (SO) Strategy```---ğŸ¯ Next Stepsà¹€à¸£à¸²à¹„à¸”à¹‰à¸ªà¸£à¹‰à¸²à¸‡ Database Schema à¸ªà¹ˆà¸§à¸™ Foundation à¹€à¸ªà¸£à¹‡à¸ˆà¹à¸¥à¹‰à¸§ à¸›à¸£à¸°à¸à¸­à¸šà¸”à¹‰à¸§à¸¢:âœ… User Management & Authenticationâœ… Organization Structureâœ… Vision, Mission, Valuesâœ… SWOT Analysis with Delphi Methodà¸•à¹ˆà¸­à¹„à¸›à¸ˆà¸°à¸—à¸³à¸­à¸°à¹„à¸£à¸”à¸µ?à¸•à¹ˆà¸­ Schema Phase 2 â†’ RBAC & Audit Trail (à¸ªà¸³à¸„à¸±à¸à¸¡à¸²à¸!)à¸—à¸”à¸ªà¸­à¸š Schema à¸™à¸µà¹‰à¸à¹ˆà¸­à¸™ â†’ à¸£à¸±à¸™ seed à¹à¸¥à¸°à¹€à¸¥à¹ˆà¸™à¹ƒà¸™ Prisma Studioà¸ªà¸£à¹‰à¸²à¸‡ tRPC API â†’ à¸ªà¸£à¹‰à¸²à¸‡ router à¸ªà¸³à¸«à¸£à¸±à¸š SWOT Analysisà¸ªà¸£à¹‰à¸²à¸‡ UI Component â†’ à¸«à¸™à¹‰à¸² SWOT Analysisà¸„à¸¸à¸“à¸­à¸¢à¸²à¸à¸—à¸³à¸­à¸±à¸™à¹„à¸«à¸™à¸•à¹ˆà¸­à¸„à¸£à¸±à¸š? ğŸš€---ğŸ” Database Schema - Part 2: RBAC & Audit Trailà¸•à¹ˆà¸­à¸ˆà¸²à¸ Phase 1 à¹€à¸£à¸²à¸ˆà¸°à¹€à¸à¸´à¹ˆà¸¡ Permission System à¹à¸¥à¸° Audit Trail à¸—à¸µà¹ˆà¸„à¸£à¸­à¸šà¸„à¸¥à¸¸à¸¡à¸—à¸¸à¸ action---ğŸ“Š Step 1: Extended Schema (Add to existing schema.prisma)```prisma// prisma/schema.prisma (continued from Part 1)// ============================================================================// SECTION 5: ROLE-BASED ACCESS CONTROL (RBAC)// ============================================================================enum ResourceType {  // Strategic Planning  ORGANIZATION  VISION  MISSION  CORE_VALUE  SWOT_FACTOR  DELPHI_ROUND  TOWS_STRATEGY    // Performance Management  BSC_PERSPECTIVE  STRATEGIC_OBJECTIVE  KPI  KPI_TARGET  KPI_ACTUAL    // Project Management  PROJECT  WBS_ELEMENT  MILESTONE  PROJECT_RISK    // OKR System  OKR_CYCLE  OKR  KEY_RESULT    // Other  TEAM  DEPARTMENT  REPORT  DASHBOARD  DOCUMENT}enum PermissionAction {  CREATE              // à¸ªà¸£à¹‰à¸²à¸‡à¹ƒà¸«à¸¡à¹ˆ  READ                // à¸­à¹ˆà¸²à¸™/à¸”à¸¹  UPDATE              // à¹à¸à¹‰à¹„à¸‚  DELETE              // à¸¥à¸š  APPROVE             // à¸­à¸™à¸¸à¸¡à¸±à¸•à¸´  REJECT              // à¸›à¸à¸´à¹€à¸ªà¸˜  EXPORT              // à¸ªà¹ˆà¸‡à¸­à¸­à¸à¸‚à¹‰à¸­à¸¡à¸¹à¸¥  IMPORT              // à¸™à¸³à¹€à¸‚à¹‰à¸²à¸‚à¹‰à¸­à¸¡à¸¹à¸¥  SHARE               // à¹à¸Šà¸£à¹Œà¹ƒà¸«à¹‰à¸œà¸¹à¹‰à¸­à¸·à¹ˆà¸™  COMMENT             // à¹à¸ªà¸”à¸‡à¸„à¸§à¸²à¸¡à¸„à¸´à¸”à¹€à¸«à¹‡à¸™  ARCHIVE             // à¹€à¸à¹‡à¸šà¸–à¸²à¸§à¸£  RESTORE             // à¸à¸¹à¹‰à¸„à¸·à¸™  ASSIGN              // à¸¡à¸­à¸šà¸«à¸¡à¸²à¸¢  SUBMIT              // à¸ªà¹ˆà¸‡/à¸¢à¸·à¹ˆà¸™  REVIEW              // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š}enum PermissionScope {  GLOBAL              // à¸—à¸±à¹‰à¸‡à¸£à¸°à¸šà¸š  ORGANIZATION        // à¹€à¸‰à¸à¸²à¸°à¸­à¸‡à¸„à¹Œà¸à¸£à¸‚à¸­à¸‡à¸•à¸±à¸§à¹€à¸­à¸‡  DEPARTMENT          // à¹€à¸‰à¸à¸²à¸°à¹à¸œà¸™à¸à¸‚à¸­à¸‡à¸•à¸±à¸§à¹€à¸­à¸‡  TEAM                // à¹€à¸‰à¸à¸²à¸°à¸—à¸µà¸¡à¸‚à¸­à¸‡à¸•à¸±à¸§à¹€à¸­à¸‡  OWN                 // à¹€à¸‰à¸à¸²à¸°à¸‚à¸­à¸‡à¸•à¸±à¸§à¹€à¸­à¸‡à¸—à¸µà¹ˆà¸ªà¸£à¹‰à¸²à¸‡}// Permission Matrix: à¸à¸³à¸«à¸™à¸” permission à¸•à¸²à¸¡ rolemodel RolePermission {  id              String            @id @default(cuid())    role            UserRole  resourceType    ResourceType  action          PermissionAction  scope           PermissionScope   @default(ORGANIZATION)    // Conditions (JSON)  conditions      Json?             // à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¹€à¸à¸´à¹ˆà¸¡à¹€à¸•à¸´à¸¡ à¹€à¸Šà¹ˆà¸™ "only if status = DRAFT"    isActive        Boolean           @default(true)    createdAt       DateTime          @default(now())  updatedAt       DateTime          @updatedAt    @@unique([role, resourceType, action, scope])  @@index([role])  @@index([resourceType])  @@map("role_permissions")}// User-specific permissions (override role permissions)model Permission {  id              String            @id @default(cuid())    userId          String  user            User              @relation(fields: [userId], references: [id], onDelete: Cascade)    resourceType    ResourceType  resourceId      String?           // null = all resources of this type    actions         PermissionAction[] // Array of allowed actions  scope           PermissionScope   @default(ORGANIZATION)    // Grant metadata  grantedBy       String?           // Who granted this permission  grantedAt       DateTime          @default(now())  expiresAt       DateTime?         // Permission expiration    reason          String?           @db.Text // à¹€à¸«à¸•à¸¸à¸œà¸¥à¹ƒà¸™à¸à¸²à¸£à¹ƒà¸«à¹‰ permission    isActive        Boolean           @default(true)    createdAt       DateTime          @default(now())  updatedAt       DateTime          @updatedAt    @@index([userId])  @@index([resourceType, resourceId])  @@index([userId, resourceType])  @@map("permissions")}// Permission Request: à¸‚à¸­ permission à¸à¸´à¹€à¸¨à¸©model PermissionRequest {  id              String            @id @default(cuid())    requesterId     String  requester       User              @relation("PermissionRequester", fields: [requesterId], references: [id], onDelete: Cascade)    resourceType    ResourceType  resourceId      String?  actions         PermissionAction[]    justification   String            @db.Text // à¹€à¸«à¸•à¸¸à¸œà¸¥à¹ƒà¸™à¸à¸²à¸£à¸‚à¸­    status          RequestStatus     @default(PENDING)    reviewerId      String?  reviewer        User?             @relation("PermissionReviewer", fields: [reviewerId], references: [id], onDelete: SetNull)    reviewedAt      DateTime?  reviewNotes     String?           @db.Text    createdAt       DateTime          @default(now())  updatedAt       DateTime          @updatedAt    @@index([requesterId])  @@index([status])  @@map("permission_requests")}enum RequestStatus {  PENDING  APPROVED  REJECTED  EXPIRED  CANCELLED}// Add to User model (append these relations):// permissionRequests PermissionRequest[] @relation("PermissionRequester")// reviewedRequests   PermissionRequest[] @relation("PermissionReviewer")// ============================================================================// SECTION 6: COMPREHENSIVE AUDIT TRAIL// ============================================================================enum AuditAction {  // Basic CRUD  CREATE  READ  UPDATE  DELETE    // State changes  APPROVE  REJECT  SUBMIT  PUBLISH  ARCHIVE  RESTORE    // Data operations  IMPORT  EXPORT  BULK_UPDATE  BULK_DELETE    // Access  LOGIN  LOGOUT  LOGIN_FAILED  PASSWORD_CHANGE  PASSWORD_RESET    // Permissions  PERMISSION_GRANTED  PERMISSION_REVOKED    // Sensitive operations  VIEW_SENSITIVE  DOWNLOAD_SENSITIVE  SHARE}enum AuditSeverity {  LOW               // à¸›à¸à¸•à¸´ à¹€à¸Šà¹ˆà¸™ READ  MEDIUM            // UPDATE à¸—à¸±à¹ˆà¸§à¹„à¸›  HIGH              // DELETE, APPROVE  CRITICAL          // Permission changes, Bulk operations}model AuditLog {  id              String          @id @default(cuid())    // Who  userId          String?         // null for system actions  user            User?           @relation(fields: [userId], references: [id], onDelete: SetNull)  userName        String?         // Cached for performance  userRole        UserRole?    // What  action          AuditAction  severity        AuditSeverity   @default(MEDIUM)    // Where (Resource)  entityType      String          // "SWOTFactor", "KPI", "Project"  entityId        String  entityName      String?         // For display (e.g., factor code, KPI name)    // Changes (JSON structure)  oldValue        Json?           // Complete old object  newValue        Json?           // Complete new object  changes         Json?           // Diff array: [{field, oldVal, newVal}]    // Context  reason          String?         @db.Text // Optional reason/comment  ipAddress       String?  userAgent       String?  sessionId       String?  requestId       String?         // For tracing across microservices    // Additional metadata  metadata        Json?           // Extra context    // Timestamp  createdAt       DateTime        @default(now())    @@index([userId, createdAt])  @@index([entityType, entityId])  @@index([action, createdAt])  @@index([severity, createdAt])  @@index([sessionId])  @@map("audit_logs")}// Detailed change tracking for specific fieldsmodel ChangeHistory {  id              String          @id @default(cuid())    // What changed  entityType      String  entityId        String  fieldName       String    // Values  oldValue        String?         @db.Text  newValue        String?         @db.Text    // Data type for proper display  dataType        String?         // "string", "number", "date", "json"    // Who changed  changedBy       String  changedByUser   User            @relation(fields: [changedBy], references: [id], onDelete: Cascade)  changedByName   String?         // Cached    // Why  changeReason    String?         @db.Text    // Version control  version         Int             @default(1)    // Related audit log  auditLogId      String?    // Timestamp  changedAt       DateTime        @default(now())    @@index([entityType, entityId, changedAt])  @@index([changedBy, changedAt])  @@index([fieldName])  @@index([auditLogId])  @@map("change_histories")}// Entity snapshots for point-in-time recoverymodel EntitySnapshot {  id              String          @id @default(cuid())    entityType      String  entityId        String    snapshotData    Json            // Complete entity state    version         Int    createdBy       String?  createdAt       DateTime        @default(now())    // Snapshot triggers  triggerType     SnapshotTrigger  auditLogId      String?         // Related audit log    @@index([entityType, entityId, version])  @@index([createdAt])  @@map("entity_snapshots")}enum SnapshotTrigger {  MANUAL              // Manual backup  AUTO_DAILY          // Automated daily backup  BEFORE_DELETE       // Before deletion  BEFORE_MAJOR_UPDATE // Before significant changes  APPROVAL            // After approval  VERSION_INCREMENT   // Version milestone}// Activity Feed: User-friendly activity streammodel ActivityFeed {  id              String          @id @default(cuid())    // Who  actorId         String?  actor           User?           @relation(fields: [actorId], references: [id], onDelete: SetNull)  actorName       String?  actorRole       UserRole?    // What (user-friendly)  activityType    ActivityType  actionVerb      String          // "created", "updated", "approved", "deleted"    // Target  targetType      String          // "SWOT Factor", "KPI", "Project"  targetId        String  targetName      String          // Display name    // Description  description     String          @db.Text // "created SWOT Factor S01: Network Coverage"    // Related entities  relatedEntities Json?           // [{type, id, name}]    // Visibility  isPublic        Boolean         @default(true)  visibleTo       String[]        // Array of user IDs (if not public)    // Metadata  metadata        Json?    createdAt       DateTime        @default(now())    @@index([actorId, createdAt])  @@index([targetType, targetId])  @@index([activityType, createdAt])  @@index([isPublic, createdAt])  @@map("activity_feeds")}enum ActivityType {  // Strategic Planning  SWOT_CREATED  SWOT_UPDATED  SWOT_DELETED  DELPHI_STARTED  DELPHI_COMPLETED  STRATEGY_CREATED  STRATEGY_APPROVED    // Performance Management  KPI_CREATED  KPI_TARGET_SET  KPI_ACTUAL_UPDATED  KPI_ACHIEVED  KPI_AT_RISK    // Project Management  PROJECT_CREATED  PROJECT_UPDATED  MILESTONE_ACHIEVED  PROJECT_COMPLETED  PROJECT_DELAYED    // OKR  OKR_CREATED  OKR_UPDATED  KEY_RESULT_PROGRESS  OKR_ACHIEVED    // Collaboration  COMMENT_ADDED  DOCUMENT_UPLOADED  USER_MENTIONED    // System  USER_JOINED  TEAM_CREATED  PERMISSION_CHANGED}// Add to User model:// activityFeeds ActivityFeed[]// ============================================================================// SECTION 7: DATA RETENTION & COMPLIANCE// ============================================================================model DataRetentionPolicy {  id              String          @id @default(cuid())    entityType      String          @unique    // Retention rules  retentionDays   Int             // Keep for N days  archiveAfterDays Int?           // Move to archive after N days    // Deletion rules  softDelete      Boolean         @default(true) // Use deletedAt instead of hard delete  hardDeleteAfterDays Int?        // Permanently delete after N days    // Audit trail retention  keepAuditLogs   Boolean         @default(true)  auditRetentionDays Int?    // Compliance  complianceNotes String?         @db.Text    isActive        Boolean         @default(true)    createdAt       DateTime        @default(now())  updatedAt       DateTime        @updatedAt    @@map("data_retention_policies")}model ComplianceLog {  id              String          @id @default(cuid())    complianceType  ComplianceType    // What was checked  entityType      String?  entityId        String?    // Result  status          ComplianceStatus  findings        Json?           // Detailed findings    // Actions taken  actionsTaken    String?         @db.Text    // Who checked  checkedBy       String?  checkedAt       DateTime        @default(now())    @@index([complianceType, checkedAt])  @@index([status])  @@map("compliance_logs")}enum ComplianceType {  DATA_RETENTION        // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸à¸²à¸£à¹€à¸à¹‡à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥  ACCESS_REVIEW         // à¸—à¸šà¸—à¸§à¸™ access permissions  AUDIT_TRAIL_INTEGRITY // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸„à¸§à¸²à¸¡à¸–à¸¹à¸à¸•à¹‰à¸­à¸‡à¸‚à¸­à¸‡ audit logs  GDPR_COMPLIANCE       // GDPR (if applicable)  SECURITY_SCAN         // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸„à¸§à¸²à¸¡à¸›à¸¥à¸­à¸”à¸ à¸±à¸¢}enum ComplianceStatus {  COMPLIANT  NON_COMPLIANT  NEEDS_REVIEW  REMEDIATED}// ============================================================================// SECTION 8: NOTIFICATION SYSTEM (for Audit & Activity)// ============================================================================enum NotificationChannel {  IN_APP  EMAIL  SMS  LINE  PUSH}enum NotificationPriority {  LOW  MEDIUM  HIGH  URGENT}model NotificationTemplate {  id              String          @id @default(cuid())    templateCode    String          @unique // "KPI_AT_RISK", "OKR_DUE", "APPROVAL_NEEDED"    eventType       ActivityType    // Trigger event    // Content (supports variables)  titleTemplate   String          // "{{userName}} updated {{entityName}}"  bodyTemplate    String          @db.Text    // Channels  channels        NotificationChannel[]    // Who should receive  recipientRoles  UserRole[]      // Send to these roles  recipientRule   String?         @db.Text // e.g., "creator", "assignee", "team_lead"    // Settings  isActive        Boolean         @default(true)  priority        NotificationPriority @default(MEDIUM)    // Throttling  throttleMinutes Int?            // Don't send more than once per N minutes    createdAt       DateTime        @default(now())  updatedAt       DateTime        @updatedAt    @@index([eventType])  @@map("notification_templates")}model Notification {  id              String          @id @default(cuid())    userId          String  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)    templateId      String?    // Content  title           String  body            String          @db.Text    // Type & Priority  notificationType ActivityType?  priority        NotificationPriority @default(MEDIUM)    // Link  linkUrl         String?  linkText        String?    // Related entities  entityType      String?  entityId        String?    // Delivery  channels        NotificationChannel[]    // Status  status          NotificationStatus @default(UNREAD)  readAt          DateTime?  dismissedAt     DateTime?    // Metadata  metadata        Json?    // Timestamps  sentAt          DateTime        @default(now())  expiresAt       DateTime?    @@index([userId, status])  @@index([userId, sentAt])  @@index([notificationType])  @@map("notifications")}enum NotificationStatus {  UNREAD  READ  DISMISSED  EXPIRED}// ============================================================================// SECTION 9: SECURITY & MONITORING// ============================================================================model SecurityEvent {  id              String          @id @default(cuid())    eventType       SecurityEventType  severity        SecuritySeverity    // Who  userId          String?  username        String?  ipAddress       String    // What  description     String          @db.Text    // Context  userAgent       String?  requestUrl      String?  requestMethod   String?  requestBody     Json?    // Result  blocked         Boolean         @default(false)    // Response  responseStatus  Int?  responseTime    Int?            // milliseconds    // Detection  detectionRule   String?         // Which rule triggered    createdAt       DateTime        @default(now())    @@index([eventType, createdAt])  @@index([severity, createdAt])  @@index([userId])  @@index([ipAddress])  @@map("security_events")}enum SecurityEventType {  FAILED_LOGIN  MULTIPLE_FAILED_LOGINS  SUSPICIOUS_ACCESS  UNAUTHORIZED_ACCESS  PRIVILEGE_ESCALATION  DATA_EXFILTRATION  SQL_INJECTION_ATTEMPT  XSS_ATTEMPT  CSRF_ATTEMPT  BRUTE_FORCE  RATE_LIMIT_EXCEEDED  INVALID_TOKEN  EXPIRED_TOKEN}enum SecuritySeverity {  INFO  LOW  MEDIUM  HIGH  CRITICAL}model RateLimitLog {  id              String          @id @default(cuid())    // Identifier (IP or User)  identifier      String          // IP address or user ID  identifierType  String          // "ip" or "user"    // Endpoint  endpoint        String  method          String          // GET, POST, PUT, DELETE    // Rate limiting  requestCount    Int             @default(1)  windowStart     DateTime  windowEnd       DateTime    // Status  blocked         Boolean         @default(false)    createdAt       DateTime        @default(now())  updatedAt       DateTime        @updatedAt    @@index([identifier, endpoint, windowStart])  @@index([blocked, createdAt])  @@map("rate_limit_logs")}// ============================================================================// SECTION 10: PERFORMANCE MONITORING// ============================================================================model PerformanceMetric {  id              String          @id @default(cuid())    // Endpoint  endpoint        String  method          String    // Performance  responseTime    Int             // milliseconds  cpuUsage        Float?          // percentage  memoryUsage     Float?          // MB    // Database  queryCount      Int?  queryTime       Int?            // milliseconds    // Result  statusCode      Int  errorOccurred   Boolean         @default(false)  errorMessage    String?         @db.Text    // Context  userId          String?  userAgent       String?    createdAt       DateTime        @default(now())    @@index([endpoint, createdAt])  @@index([responseTime])  @@index([errorOccurred, createdAt])  @@map("performance_metrics")}```---ğŸ”§ Step 2: Seed Data for RBAC```typescript// prisma/seed-rbac.tsimport { PrismaClient, UserRole, ResourceType, PermissionAction, PermissionScope } from '@prisma/client'const prisma = new PrismaClient()async function seedRBAC() {  console.log('ğŸ” Seeding RBAC...')  // Define role permissions matrix  const rolePermissions = [    // =========================================================================    // SUPER_ADMIN - Full access to everything    // =========================================================================    {      role: UserRole.SUPER_ADMIN,      resourceType: ResourceType.ORGANIZATION,      actions: [        PermissionAction.CREATE,        PermissionAction.READ,        PermissionAction.UPDATE,        PermissionAction.DELETE,        PermissionAction.EXPORT,      ],      scope: PermissionScope.GLOBAL,    },    // ... repeat for all resource types    // =========================================================================    // ORG_ADMIN - Organization-level admin    // =========================================================================    {      role: UserRole.ORG_ADMIN,      resourceType: ResourceType.ORGANIZATION,      actions: [PermissionAction.READ, PermissionAction.UPDATE],      scope: PermissionScope.ORGANIZATION,    },    {      role: UserRole.ORG_ADMIN,      resourceType: ResourceType.SWOT_FACTOR,      actions: [        PermissionAction.CREATE,        PermissionAction.READ,        PermissionAction.UPDATE,        PermissionAction.DELETE,        PermissionAction.APPROVE,      ],      scope: PermissionScope.ORGANIZATION,    },    {      role: UserRole.ORG_ADMIN,      resourceType: ResourceType.DELPHI_ROUND,      actions: [        PermissionAction.CREATE,        PermissionAction.READ,        PermissionAction.UPDATE,        PermissionAction.DELETE,      ],      scope: PermissionScope.ORGANIZATION,    },    // =========================================================================    // STRATEGIC_PLANNER - Can manage strategies but not approve    // =========================================================================    {      role: UserRole.STRATEGIC_PLANNER,      resourceType: ResourceType.SWOT_FACTOR,      actions: [PermissionAction.CREATE, PermissionAction.READ, PermissionAction.UPDATE, PermissionAction.SUBMIT],      scope: PermissionScope.ORGANIZATION,    },    {      role: UserRole.STRATEGIC_PLANNER,      resourceType: ResourceType.TOWS_STRATEGY,      actions: [        PermissionAction.CREATE,        PermissionAction.READ,        PermissionAction.UPDATE,        PermissionAction.DELETE,        PermissionAction.SUBMIT,      ],      scope: PermissionScope.ORGANIZATION,    },    {      role: UserRole.STRATEGIC_PLANNER,      resourceType: ResourceType.STRATEGIC_OBJECTIVE,      actions: [PermissionAction.CREATE, PermissionAction.READ, PermissionAction.UPDATE, PermissionAction.SUBMIT],      scope: PermissionScope.ORGANIZATION,    },    {      role: UserRole.STRATEGIC_PLANNER,      resourceType: ResourceType.KPI,      actions: [PermissionAction.CREATE, PermissionAction.READ, PermissionAction.UPDATE],      scope: PermissionScope.ORGANIZATION,    },    // =========================================================================    // PROJECT_MANAGER - Project management focus    // =========================================================================    {      role: UserRole.PROJECT_MANAGER,      resourceType: ResourceType.PROJECT,      actions: [        PermissionAction.CREATE,        PermissionAction.READ,        PermissionAction.UPDATE,        PermissionAction.DELETE,        PermissionAction.ASSIGN,      ],      scope: PermissionScope.ORGANIZATION,    },    {      role: UserRole.PROJECT_MANAGER,      resourceType: ResourceType.WBS_ELEMENT,      actions: [        PermissionAction.CREATE,        PermissionAction.READ,        PermissionAction.UPDATE,        PermissionAction.DELETE,        PermissionAction.ASSIGN,      ],      scope: PermissionScope.ORGANIZATION,    },    {      role: UserRole.PROJECT_MANAGER,      resourceType: ResourceType.MILESTONE,      actions: [PermissionAction.CREATE, PermissionAction.READ, PermissionAction.UPDATE, PermissionAction.DELETE],      scope: PermissionScope.ORGANIZATION,    },    {      role: UserRole.PROJECT_MANAGER,      resourceType: ResourceType.KPI_ACTUAL,      actions: [PermissionAction.READ, PermissionAction.UPDATE],      scope: PermissionScope.ORGANIZATION,    },    // =========================================================================    // TEAM_LEAD - Can manage team KPIs and OKRs    // =========================================================================    {      role: UserRole.TEAM_LEAD,      resourceType: ResourceType.KPI_ACTUAL,      actions: [PermissionAction.READ, PermissionAction.UPDATE],      scope: PermissionScope.TEAM,    },    {      role: UserRole.TEAM_LEAD,      resourceType: ResourceType.OKR,      actions: [PermissionAction.CREATE, PermissionAction.READ, PermissionAction.UPDATE, PermissionAction.APPROVE],      scope: PermissionScope.TEAM,    },    {      role: UserRole.TEAM_LEAD,      resourceType: ResourceType.KEY_RESULT,      actions: [PermissionAction.CREATE, PermissionAction.READ, PermissionAction.UPDATE, PermissionAction.REVIEW],      scope: PermissionScope.TEAM,    },    {      role: UserRole.TEAM_LEAD,      resourceType: ResourceType.PROJECT,      actions: [PermissionAction.READ, PermissionAction.COMMENT],      scope: PermissionScope.TEAM,    },    // =========================================================================    // TEAM_MEMBER - Individual contributor    // =========================================================================    {      role: UserRole.TEAM_MEMBER,      resourceType: ResourceType.OKR,      actions: [PermissionAction.READ, PermissionAction.UPDATE],      scope: PermissionScope.OWN,    },    {      role: UserRole.TEAM_MEMBER,      resourceType: ResourceType.KEY_RESULT,      actions: [PermissionAction.READ, PermissionAction.UPDATE],      scope: PermissionScope.OWN,    },    {      role: UserRole.TEAM_MEMBER,      resourceType: ResourceType.KPI_ACTUAL,      actions: [PermissionAction.READ],      scope: PermissionScope.TEAM,    },    {      role: UserRole.TEAM_MEMBER,      resourceType: ResourceType.PROJECT,      actions: [PermissionAction.READ, PermissionAction.COMMENT],      scope: PermissionScope.TEAM,    },    // =========================================================================    // VIEWER - Read-only access    // =========================================================================    {      role: UserRole.VIEWER,      resourceType: ResourceType.SWOT_FACTOR,      actions: [PermissionAction.READ],      scope: PermissionScope.ORGANIZATION,    },    {      role: UserRole.VIEWER,      resourceType: ResourceType.STRATEGIC_OBJECTIVE,      actions: [PermissionAction.READ],      scope: PermissionScope.ORGANIZATION,    },    {      role: UserRole.VIEWER,      resourceType: ResourceType.KPI,      actions: [PermissionAction.READ],      scope: PermissionScope.ORGANIZATION,    },    {      role: UserRole.VIEWER,      resourceType: ResourceType.PROJECT,      actions: [PermissionAction.READ],      scope: PermissionScope.ORGANIZATION,    },    {      role: UserRole.VIEWER,      resourceType: ResourceType.REPORT,      actions: [PermissionAction.READ, PermissionAction.EXPORT],      scope: PermissionScope.ORGANIZATION,    },  ]  // Insert role permissions  for (const perm of rolePermissions) {    for (const action of perm.actions) {      await prisma.rolePermission.upsert({        where: {          role_resourceType_action_scope: {            role: perm.role,            resourceType: perm.resourceType,            action: action,            scope: perm.scope,          },        },        update: {},        create: {          role: perm.role,          resourceType: perm.resourceType,          action: action,          scope: perm.scope,        },      })    }  }  console.log(`âœ… Created ${rolePermissions.length} role permission rules`)  // Create data retention policies  const retentionPolicies = [    {      entityType: 'AuditLog',      retentionDays: 2555, // ~7 years      keepAuditLogs: true,    },    {      entityType: 'SWOTFactor',      retentionDays: 1825, // ~5 years      softDelete: true,      keepAuditLogs: true,      auditRetentionDays: 1825,    },    {      entityType: 'KPI',      retentionDays: 1825, // ~5 years      softDelete: true,      keepAuditLogs: true,      auditRetentionDays: 1825,    },    {      entityType: 'Project',      retentionDays: 1095, // ~3 years      archiveAfterDays: 365,      softDelete: true,      keepAuditLogs: true,    },    {      entityType: 'OKR',      retentionDays: 730, // ~2 years      archiveAfterDays: 180,      softDelete: true,      keepAuditLogs: true,    },  ]  for (const policy of retentionPolicies) {    await prisma.dataRetentionPolicy.upsert({      where: { entityType: policy.entityType },      update: {},      create: policy,    })  }  console.log(`âœ… Created ${retentionPolicies.length} data retention policies`)  console.log('ğŸ‰ RBAC seed completed!')}seedRBAC()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })```---ğŸ›¡ï¸ Step 3: Permission Helper Functions```typescript// lib/permissions.tsimport { prisma } from './prisma'import { UserRole, ResourceType, PermissionAction, PermissionScope } from '@prisma/client'export interface PermissionContext {  userId: string  userRole: UserRole  organizationId?: string  departmentId?: string  teamId?: string}export async function checkPermission(  ctx: PermissionContext,  resourceType: ResourceType,  action: PermissionAction,  resourceId?: string): Promise<boolean> {  // 1. Check role-based permission  const rolePermission = await prisma.rolePermission.findFirst({    where: {      role: ctx.userRole,      resourceType,      action,      isActive: true,    },  })  if (!rolePermission) {    return false // Role doesn't have this permission  }  // 2. Check scope  const scopeCheck = await checkScope(ctx, rolePermission.scope, resourceId, resourceType)  if (!scopeCheck) {    return false  }  // 3. Check user-specific permissions (overrides)  const userPermission = await prisma.permission.findFirst({    where: {      userId: ctx.userId,      resourceType,      resourceId: resourceId || null,      isActive: true,      OR: [{ expiresAt: null }, { expiresAt: { gte: new Date() } }],    },  })  if (userPermission) {    // User-specific permission exists    return userPermission.actions.includes(action)  }  // 4. All checks passed  return true}async function checkScope(  ctx: PermissionContext,  scope: PermissionScope,  resourceId: string | undefined,  resourceType: ResourceType): Promise<boolean> {  switch (scope) {    case PermissionScope.GLOBAL:      return true    case PermissionScope.ORGANIZATION:      // Check if resource belongs to user's organization      if (!ctx.organizationId || !resourceId) return true      return await checkOrganizationScope(ctx.organizationId, resourceId, resourceType)    case PermissionScope.DEPARTMENT:      // Check if resource belongs to user's department      if (!ctx.departmentId || !resourceId) return false      return await checkDepartmentScope(ctx.departmentId, resourceId, resourceType)    case PermissionScope.TEAM:      // Check if resource belongs to user's team      if (!ctx.teamId || !resourceId) return false      return await checkTeamScope(ctx.teamId, resourceId, resourceType)    case PermissionScope.OWN:      // Check if user owns this resource      if (!resourceId) return false      return await checkOwnership(ctx.userId, resourceId, resourceType)    default:      return false  }}async function checkOrganizationScope(  organizationId: string,  resourceId: string,  resourceType: ResourceType): Promise<boolean> {  switch (resourceType) {    case ResourceType.SWOT_FACTOR:      const swot = await prisma.sWOTFactor.findUnique({        where: { id: resourceId },        select: { organizationId: true },      })      return swot?.organizationId === organizationId    case ResourceType.PROJECT:      const project = await prisma.project.findUnique({        where: { id: resourceId },        select: { organizationId: true },      })      return project?.organizationId === organizationId    // Add more cases as needed    default:      return true  }}async function checkDepartmentScope(  departmentId: string,  resourceId: string,  resourceType: ResourceType): Promise<boolean> {  // Similar implementation  return true // TODO: Implement}async function checkTeamScope(  teamId: string,  resourceId: string,  resourceType: ResourceType): Promise<boolean> {  // Similar implementation  return true // TODO: Implement}async function checkOwnership(  userId: string,  resourceId: string,  resourceType: ResourceType): Promise<boolean> {  switch (resourceType) {    case ResourceType.OKR:      const okr = await prisma.oKR.findUnique({        where: { id: resourceId },        select: { ownerId: true },      })      return okr?.ownerId === userId    // Add more cases    default:      return false  }}// Middleware for tRPC/Next.jsexport function requirePermission(resourceType: ResourceType, action: PermissionAction) {  return async (ctx: PermissionContext, resourceId?: string) => {    const hasPermission = await checkPermission(ctx, resourceType, action, resourceId)    if (!hasPermission) {      throw new Error(`Permission denied: ${action} on ${resourceType}`)    }    return true  }}// Batch permission checkexport async function checkPermissions(  ctx: PermissionContext,  checks: Array<{ resourceType: ResourceType; action: PermissionAction; resourceId?: string }>): Promise<Record<string, boolean>> {  const results: Record<string, boolean> = {}  for (const check of checks) {    const key = `${check.resourceType}:${check.action}:${check.resourceId || 'all'}`    results[key] = await checkPermission(ctx, check.resourceType, check.action, check.resourceId)  }  return results}```---ğŸ“ Step 4: Audit Trail Middleware```typescript// lib/audit-middleware.tsimport { prisma } from './prisma'import { Prisma, AuditAction, AuditSeverity } from '@prisma/client'interface AuditContext {  userId?: string  userRole?: string  ipAddress?: string  userAgent?: string  sessionId?: string}export async function createAuditMiddleware() {  return prisma.$use(async (params, next) => {    const result = await next(params)    // Only audit write operations    if (['create', 'update', 'delete', 'upsert', 'createMany', 'updateMany', 'deleteMany'].includes(params.action)) {      // Get context from async local storage or similar      const ctx = getAuditContext() // TODO: Implement context storage      await captureAuditLog({        action: mapPrismaActionToAudit(params.action),        model: params.model!,        args: params.args,        result,        context: ctx,      })    }    return result  })}function mapPrismaActionToAudit(action: string): AuditAction {  switch (action) {    case 'create':    case 'createMany':      return AuditAction.CREATE    case 'update':    case 'updateMany':    case 'upsert':      return AuditAction.UPDATE    case 'delete':    case 'deleteMany':      return AuditAction.DELETE    default:      return AuditAction.UPDATE  }}interface CaptureAuditLogParams {  action: AuditAction  model: string  args: any  result: any  context: AuditContext}async function captureAuditLog({ action, model, args, result, context }: CaptureAuditLogParams) {  try {    // Get old value for UPDATE/DELETE    let oldValue = null    if (action === AuditAction.UPDATE || action === AuditAction.DELETE) {      if (args.where?.id) {        oldValue = await prisma[model.toLowerCase()].findUnique({          where: { id: args.where.id },        })      }    }    // Calculate diff    const changes = action === AuditAction.UPDATE ? calculateDiff(oldValue, result) : null    // Determine severity    const severity = determineSeverity(action, model)    // Create audit log    await prisma.auditLog.create({      data: {        userId: context.userId,        action,        severity,        entityType: model,        entityId: result?.id || args.where?.id,        entityName: getEntityName(result),        oldValue: oldValue ? (oldValue as any) : Prisma.JsonNull,        newValue: result ? (result as any) : Prisma.JsonNull,        changes: changes ? (changes as any) : Prisma.JsonNull,        ipAddress: context.ipAddress,        userAgent: context.userAgent,        sessionId: context.sessionId,      },    })    // Create change history for each field    if (changes && changes.length > 0) {      for (const change of changes) {        await prisma.changeHistory.create({          data: {            entityType: model,            entityId: result.id,            fieldName: change.field,            oldValue: String(change.oldValue),            newValue: String(change.newValue),            changedBy: context.userId!,            dataType: typeof change.newValue,          },        })      }    }    // Create activity feed    await createActivityFeed({      action,      model,      result,      context,    })  } catch (error) {    console.error('Failed to create audit log:', error)    // Don't throw - audit failure shouldn't break the operation  }}function calculateDiff(oldValue: any, newValue: any): Array<{ field: string; oldValue: any; newValue: any }> {  if (!oldValue || !newValue) return []  const changes: Array<{ field: string; oldValue: any; newValue: any }> = []  for (const key of Object.keys(newValue)) {    if (key === 'updatedAt' || key === 'createdAt') continue // Skip timestamps    if (oldValue[key] !== newValue[key]) {      changes.push({        field: key,        oldValue: oldValue[key],        newValue: newValue[key],      })    }  }  return changes}function determineSeverity(action: AuditAction, model: string): AuditSeverity {  if (action === AuditAction.DELETE) return AuditSeverity.HIGH  // Sensitive models  const sensitiveModels = ['User', 'Permission', 'RolePermission']  if (sensitiveModels.includes(model)) return AuditSeverity.HIGH  if (action === AuditAction.CREATE) return AuditSeverity.MEDIUM  if (action === AuditAction.UPDATE) return AuditSeverity.MEDIUM  return AuditSeverity.LOW}function getEntityName(entity: any): string {  if (!entity) return 'Unknown'  return entity.name || entity.title || entity.code || entity.id || 'Unknown'}async function createActivityFeed(params: any) {  // TODO: Implement activity feed creation}function getAuditContext(): AuditContext {  // TODO: Implement async local storage to get context  return {    userId: undefined,    ipAddress: undefined,    userAgent: undefined,    sessionId: undefined,  }}```---ğŸ“¦ Step 5: Update package.json Scripts```json{  "scripts": {    "db:generate": "prisma generate",    "db:push": "prisma db push",    "db:migrate": "prisma migrate dev",    "db:seed": "tsx prisma/seed.ts",    "db:seed-rbac": "tsx prisma/seed-rbac.ts",    "db:seed-all": "pnpm db:seed && pnpm db:seed-rbac",    "db:studio": "prisma studio",    "db:reset": "prisma migrate reset --force && pnpm db:seed-all"  }}```---âœ… Verification Queries```typescript// Test permission checkingimport { checkPermission } from './lib/permissions'// Example 1: Can Strategic Planner create SWOT factors?const canCreate = await checkPermission(  {    userId: 'planner-user-id',    userRole: UserRole.STRATEGIC_PLANNER,    organizationId: 'niems-org-id',  },  ResourceType.SWOT_FACTOR,  PermissionAction.CREATE)console.log('Can create SWOT:', canCreate) // true// Example 2: Can Viewer delete projects?const canDelete = await checkPermission(  {    userId: 'viewer-user-id',    userRole: UserRole.VIEWER,    organizationId: 'niems-org-id',  },  ResourceType.PROJECT,  PermissionAction.DELETE)console.log('Can delete project:', canDelete) // false// Example 3: View audit logs for a SWOT factorconst auditLogs = await prisma.auditLog.findMany({  where: {    entityType: 'SWOTFactor',    entityId: 'swot-factor-id',  },  include: {    user: {      select: {        fullName: true,        email: true,      },    },  },  orderBy: { createdAt: 'desc' },})// Example 4: Get change history with timelineconst changeHistory = await prisma.changeHistory.findMany({  where: {    entityType: 'KPI',    entityId: 'kpi-id',  },  include: {    changedByUser: {      select: {        fullName: true,      },    },  },  orderBy: { changedAt: 'desc' },})```---ğŸ¯ Summary - What We Have Nowâœ… RBAC System7 predefined roles with granular permissions5 permission scopes (Global â†’ Own)Resource-level and action-level controlUser-specific permission overridesPermission request workflowâœ… Audit TrailComprehensive logging of all CRUD operationsField-level change trackingOld vs. new value comparisonIP address and session trackingPoint-in-time snapshotsâœ… Activity FeedUser-friendly activity stream@mentions and notificationsPublic/private visibilityRich metadata supportâœ… ComplianceData retention policiesCompliance loggingSecurity event trackingRate limiting logsPerformance monitoring---ğŸš€ Next Stepsà¸à¸£à¹‰à¸­à¸¡à¹„à¸›à¸•à¹ˆà¸­à¹à¸¥à¹‰à¸§à¸„à¸£à¸±à¸š! à¹€à¸¥à¸·à¸­à¸à¹„à¸”à¹‰à¹€à¸¥à¸¢:Phase 3: TOWS & BSC Schema â†’ à¸•à¹ˆà¸­à¸—à¸³ strategic executionTest RBAC System â†’ à¹€à¸‚à¸µà¸¢à¸™ test cases à¸ªà¸³à¸«à¸£à¸±à¸š permission checkingCreate tRPC Router â†’ à¸ªà¸£à¹‰à¸²à¸‡ API endpoint à¸—à¸µà¹ˆà¹ƒà¸Šà¹‰ permission systemBuild Audit UI â†’ à¸ªà¸£à¹‰à¸²à¸‡ component à¹à¸ªà¸”à¸‡ audit trailà¸„à¸¸à¸“à¸­à¸¢à¸²à¸à¸—à¸³à¸­à¸±à¸™à¹„à¸«à¸™à¸•à¹ˆà¸­à¸„à¸£à¸±à¸š? ğŸ¯---ğŸ“Š Database Schema - Part 3: TOWS & BSC (Strategic Execution)à¸•à¹ˆà¸­à¸ˆà¸²à¸ Phase 2 à¹€à¸£à¸²à¸ˆà¸°à¹€à¸à¸´à¹ˆà¸¡ TOWS Strategy, Balanced Scorecard, Strategy Map, à¹à¸¥à¸° Hoshin Kanri (X-Matrix)---ğŸ“‹ Step 1: Strategic Execution Schema```prisma// prisma/schema.prisma (continued from Part 2)// ============================================================================// SECTION 11: TOWS STRATEGY MATRIX// ============================================================================enum TOWSStrategyType {  SO    // Strengths-Opportunities (Aggressive/Growth)  ST    // Strengths-Threats (Diversification)  WO    // Weaknesses-Opportunities (Turnaround)  WT    // Weaknesses-Threats (Defensive/Retrenchment)}enum StrategyStatus {  DRAFT  PENDING_REVIEW  UNDER_REVIEW  APPROVED  IN_PROGRESS  ON_HOLD  COMPLETED  CANCELLED  ARCHIVED}model TOWSStrategy {  id                String            @id @default(cuid())  organizationId    String  organization      Organization      @relation(fields: [organizationId], references: [id], onDelete: Cascade)    // Strategy identification  strategyCode      String            // "SO1", "WO2", "ST3", "WT1"  strategyType      TOWSStrategyType    // Content  strategyName      String  strategyDescription String          @db.Text    // Linked SWOT factors  linkedStrengths   String[]          // Array of SWOT factor IDs  linkedWeaknesses  String[]  linkedOpportunities String[]  linkedThreats     String[]    // Priority & Feasibility  priorityScore     Float?            @default(0) // Calculated from SWOT weights  feasibilityScore  Float?            // 0-5 scale  impactScore       Float?            // 0-5 scale  urgencyScore      Float?            // 0-5 scale    // Overall ranking  overallRank       Int?              // 1, 2, 3, ... based on priorityScore    // Resource requirements  estimatedBudget   Float?  estimatedDuration Int?              // in months  requiredResources Json?             // {human: 10, budget: 1000000, technology: [...]}    // Status & Approval  status            StrategyStatus    @default(DRAFT)    submittedAt       DateTime?  submittedBy       String?    reviewedAt        DateTime?  reviewedBy        String?  reviewNotes       String?           @db.Text    approvedAt        DateTime?  approvedBy        String?    // Implementation  startDate         DateTime?  endDate           DateTime?  actualStartDate   DateTime?  actualEndDate     DateTime?    completionPercentage Float?         @default(0)    // Responsible parties  ownerUserId       String?  ownerTeamId       String?    // Metrics & KPIs  successCriteria   String?           @db.Text    // Metadata  tags              String[]          // For categorization  metadata          Json?    // Timestamps  createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt  deletedAt         DateTime?  createdById       String?    // Relations  rationale         StrategyRationale?  objectives        StrategicObjective[]  projects          Project[]  okrs              OKR[]    @@unique([organizationId, strategyCode])  @@index([organizationId])  @@index([strategyType])  @@index([status])  @@index([overallRank])  @@map("tows_strategies")}// Add to Organization model:// towsStrategies TOWSStrategy[]model StrategyRationale {  id                String        @id @default(cuid())  strategyId        String        @unique  strategy          TOWSStrategy  @relation(fields: [strategyId], references: [id], onDelete: Cascade)    // Why this strategy?  rationaleText     String        @db.Text    // Supporting evidence  marketAnalysis    String?       @db.Text  competitorAnalysis String?      @db.Text  resourceAnalysis  String?       @db.Text  riskAnalysis      String?       @db.Text    // Expected outcomes  expectedOutcomes  Json?         // Array of expected outcomes    // Supporting documents  supportingDocs    String[]      // Array of document IDs or URLs    // Stakeholder alignment  stakeholderBuyIn  Json?         // {stakeholder: "name", support: "high/medium/low"}    createdAt         DateTime      @default(now())  updatedAt         DateTime      @updatedAt    @@map("strategy_rationales")}// ============================================================================// SECTION 12: BALANCED SCORECARD (BSC)// ============================================================================enum BSCPerspectiveType {  FINANCIAL         // à¸à¸²à¸£à¹€à¸‡à¸´à¸™  CUSTOMER          // à¸¥à¸¹à¸à¸„à¹‰à¸²  INTERNAL_PROCESS  // à¸à¸£à¸°à¸šà¸§à¸™à¸à¸²à¸£à¸ à¸²à¸¢à¹ƒà¸™  LEARNING_GROWTH   // à¸à¸²à¸£à¹€à¸£à¸µà¸¢à¸™à¸£à¸¹à¹‰à¹à¸¥à¸°à¹€à¸•à¸´à¸šà¹‚à¸•}model BSCPerspective {  id                String              @id @default(cuid())    perspectiveType   BSCPerspectiveType  @unique    nameTh            String  nameEn            String    description       String?             @db.Text    displayOrder      Int                 // 1 (Financial) â†’ 4 (Learning)  color             String?             // HEX color for visualization  icon              String?             // Icon name    isActive          Boolean             @default(true)    objectives        StrategicObjective[]    @@map("bsc_perspectives")}model StrategicObjective {  id                String            @id @default(cuid())  organizationId    String  organization      Organization      @relation(fields: [organizationId], references: [id], onDelete: Cascade)    perspectiveId     String  perspective       BSCPerspective    @relation(fields: [perspectiveId], references: [id])    // Identification  objectiveCode     String            // "F1", "C2", "I3", "L1"  objectiveName     String  objectiveDescription String?        @db.Text    // Strategic alignment  linkedStrategyIds String[]          // Array of TOWS strategy IDs    // Parent-child hierarchy (for cascading)  parentObjectiveId String?  parentObjective   StrategicObjective? @relation("ObjectiveHierarchy", fields: [parentObjectiveId], references: [id], onDelete: SetNull)  childObjectives   StrategicObjective[] @relation("ObjectiveHierarchy")    // Target & Timeline  targetYear        Int?  targetQuarter     Int?              // 1-4    // Weighting  weightPercentage  Float?            // % importance within perspective    // Status  status            StrategyStatus    @default(DRAFT)    // Owner  ownerUserId       String?  ownerTeamId       String?    // Performance (calculated from KPIs)  currentScore      Float?            @default(0) // 0-100  targetScore       Float?            @default(100)  achievementRate   Float?            @default(0) // currentScore / targetScore    // Traffic light status  trafficLight      TrafficLightStatus?    // Metadata  displayOrder      Int               @default(0)  tags              String[]    // Timestamps  createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt  deletedAt         DateTime?    // Relations  kpis              KPI[]  strategyMapNodes  StrategyMapNode[]  causalSourceLinks CausalRelationship[] @relation("SourceObjective")  causalTargetLinks CausalRelationship[] @relation("TargetObjective")  annualObjectives  AnnualObjective[]    @@unique([organizationId, objectiveCode])  @@index([organizationId, perspectiveId])  @@index([status])  @@index([parentObjectiveId])  @@map("strategic_objectives")}enum TrafficLightStatus {  GREEN       // On track (>= 80%)  YELLOW      // At risk (60-79%)  RED         // Off track (< 60%)  GREY        // No data}model KPI {  id                String            @id @default(cuid())  objectiveId       String  objective         StrategicObjective @relation(fields: [objectiveId], references: [id], onDelete: Cascade)    // Identification  kpiCode           String            // "F1.1", "C2.3"  kpiName           String  kpiDescription    String?           @db.Text    // Measurement  measurementUnit   String            // "%", "à¸šà¸²à¸—", "à¸„à¸™", "à¸§à¸±à¸™"  measurementFormula String?          @db.Text // Formula for calculation  dataSource        String?           // Where to get the data    // Type  kpiType           KPIType           @default(LAGGING)  polarity          KPIPolarity       @default(HIGHER_BETTER)    // Baseline  baselineValue     Float?  baselineYear      Int?  baselineQuarter   Int?    // Target (final goal)  targetValue       Float  targetYear        Int  targetQuarter     Int?    // Current status  currentValue      Float?            @default(0)  lastUpdated       DateTime?    // Achievement calculation  achievementRate   Float?            @default(0) // (current - baseline) / (target - baseline) Ã— 100  trafficLight      TrafficLightStatus?    // Threshold values  greenThreshold    Float?            // >= this value = green  yellowThreshold   Float?            // >= this value = yellow (< green)    // Weighting within objective  weightPercentage  Float?            @default(0)    // Reporting frequency  reportingFrequency ReportingFrequency @default(MONTHLY)    // Owner & Responsible  ownerUserId       String?  responsibleTeamId String?    // Data validation  dataQualityScore  Float?            @default(5) // 1-5 scale    // Status  isActive          Boolean           @default(true)    // Metadata  tags              String[]  metadata          Json?    // Timestamps  createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt  deletedAt         DateTime?    // Relations  targets           KPITarget[]  actuals           KPIActual[]    @@unique([objectiveId, kpiCode])  @@index([objectiveId])  @@index([kpiType])  @@index([isActive])  @@map("kpis")}enum KPIType {  LEADING       // à¸•à¸±à¸§à¸Šà¸µà¹‰à¸§à¸±à¸”à¸™à¸³ (predictive)  LAGGING       // à¸•à¸±à¸§à¸Šà¸µà¹‰à¸§à¸±à¸”à¸•à¸²à¸¡ (outcome)  DIAGNOSTIC    // à¸•à¸±à¸§à¸Šà¸µà¹‰à¸§à¸±à¸”à¸§à¸´à¸™à¸´à¸ˆà¸‰à¸±à¸¢}enum KPIPolarity {  HIGHER_BETTER     // à¸¢à¸´à¹ˆà¸‡à¸¡à¸²à¸à¸¢à¸´à¹ˆà¸‡à¸”à¸µ (e.g., revenue, satisfaction)  LOWER_BETTER      // à¸¢à¸´à¹ˆà¸‡à¸™à¹‰à¸­à¸¢à¸¢à¸´à¹ˆà¸‡à¸”à¸µ (e.g., cost, defects)  TARGET_BETTER     // à¹ƒà¸à¸¥à¹‰à¹€à¸›à¹‰à¸²à¸¢à¸´à¹ˆà¸‡à¸”à¸µ (e.g., optimal inventory)}enum ReportingFrequency {  DAILY  WEEKLY  BIWEEKLY  MONTHLY  QUARTERLY  SEMI_ANNUAL  ANNUAL}model KPITarget {  id                String      @id @default(cuid())  kpiId             String  kpi               KPI         @relation(fields: [kpiId], references: [id], onDelete: Cascade)    // Time period  year              Int  quarter           Int?        // 1-4 (null for annual)  month             Int?        // 1-12 (null for quarterly/annual)    // Target values  targetValue       Float  stretchTarget     Float?      // Ambitious target  minimumAcceptable Float?      // Threshold target    // Context  notes             String?     @db.Text  assumptions       String?     @db.Text    // Status  isActive          Boolean     @default(true)    createdAt         DateTime    @default(now())  updatedAt         DateTime    @updatedAt    @@unique([kpiId, year, quarter, month])  @@index([kpiId, year])  @@map("kpi_targets")}model KPIActual {  id                String      @id @default(cuid())  kpiId             String  kpi               KPI         @relation(fields: [kpiId], references: [id], onDelete: Cascade)    // Time period  measurementDate   DateTime  year              Int  quarter           Int?  month             Int?  week              Int?    // Actual value  actualValue       Float    // Data quality  dataQualityScore  Int         @default(5) // 1-5  dataSource        String?    // Variance analysis  variance          Float?      // actual - target  variancePercent   Float?      // (actual - target) / target Ã— 100    // Comments & Analysis  notes             String?     @db.Text  analysisComments  String?     @db.Text  actionRequired    String?     @db.Text    // Verification  verifiedBy        String?  verifiedAt        DateTime?  isVerified        Boolean     @default(false)    // Status  status            DataStatus  @default(DRAFT)    // Metadata  metadata          Json?    createdAt         DateTime    @default(now())  updatedAt         DateTime    @updatedAt  createdById       String?    @@unique([kpiId, measurementDate])  @@index([kpiId, year, quarter])  @@index([measurementDate])  @@map("kpi_actuals")}enum DataStatus {  DRAFT  SUBMITTED  VERIFIED  APPROVED  REJECTED}// Performance View (Materialized view or calculated)// This would typically be a database view, but we define it for reference// CREATE MATERIALIZED VIEW bsc_performance AS ...// ============================================================================// SECTION 13: STRATEGY MAP// ============================================================================model StrategyMapNode {  id                String              @id @default(cuid())  objectiveId       String              @unique  objective         StrategicObjective  @relation(fields: [objectiveId], references: [id], onDelete: Cascade)    // Visual positioning (for D3.js visualization)  positionX         Int?                // X coordinate  positionY         Int?                // Y coordinate    // Styling  nodeColor         String?             // HEX color (default to perspective color)  nodeShape         String?             // "circle", "rect", "hexagon"  nodeSize          Int?                @default(60) // Radius or dimension    // Display  displayLabel      String?             // Custom label (defaults to objective name)  showIcon          Boolean             @default(true)  iconName          String?    // Metadata  metadata          Json?    createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt    @@index([objectiveId])  @@map("strategy_map_nodes")}model CausalRelationship {  id                String              @id @default(cuid())    sourceObjectiveId String  sourceObjective   StrategicObjective  @relation("SourceObjective", fields: [sourceObjectiveId], references: [id], onDelete: Cascade)    targetObjectiveId String  targetObjective   StrategicObjective  @relation("TargetObjective", fields: [targetObjectiveId], references: [id], onDelete: Cascade)    // Relationship type  relationshipType  RelationshipType    @default(ENABLES)    // Strength of relationship  strength          Float?              @default(0.5) // 0-1 scale  confidence        Float?              @default(0.5) // How confident are we? 0-1    // Supporting evidence  evidence          String?             @db.Text  dataSupport       Json?               // Statistical correlation, case studies    // Time lag  lagMonths         Int?                // How long before effect is seen?    // Validation  validated         Boolean             @default(false)  validatedBy       String?  validatedAt       DateTime?  validationNotes   String?             @db.Text    // Metadata  metadata          Json?    createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt    @@unique([sourceObjectiveId, targetObjectiveId])  @@index([sourceObjectiveId])  @@index([targetObjectiveId])  @@map("causal_relationships")}enum RelationshipType {  ENABLES           // A enables B  INFLUENCES        // A influences B  SUPPORTS          // A supports B  DEPENDS_ON        // A depends on B  CONTRIBUTES_TO    // A contributes to B}// Impact Analysis (calculated data)// Useful for understanding which objectives are most criticalmodel ImpactAnalysis {  id                String              @id @default(cuid())  objectiveId       String              @unique    // Dependencies  directDependenciesCount    Int      @default(0) // Objectives this one enables  indirectDependenciesCount  Int      @default(0) // Transitive dependencies    // Influence score (how many objectives depend on this one)  influenceScore    Float               @default(0) // Calculated from causal links    // Critical path indicator  isOnCriticalPath  Boolean             @default(false)  criticalityScore  Float?              // 0-1 scale    // Risk impact  failureImpact     String?             // "HIGH", "MEDIUM", "LOW"    // Last calculation  calculatedAt      DateTime            @default(now())    @@index([objectiveId])  @@map("impact_analyses")}// ============================================================================// SECTION 14: HOSHIN KANRI (X-MATRIX)// ============================================================================enum XMatrixStatus {  DRAFT  UNDER_REVIEW  APPROVED  IN_PROGRESS  COMPLETED  ARCHIVED}model LongTermGoal {  id                String            @id @default(cuid())  organizationId    String    goalCode          String            // "LTG1", "LTG2"  goalName          String  goalDescription   String            @db.Text    // Timeline (3-5 year goals)  targetYear        Int    // Link to vision  linkedVisionId    String?    // Priority  priorityRank      Int               @default(0)  weightPercentage  Float?    // Metrics  successMetrics    Json?             // Array of metrics to measure success    // Status  status            XMatrixStatus     @default(DRAFT)    // Owner  ownerUserId       String?    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt    annualObjectives  AnnualObjective[]  correlations      XMatrixCorrelation[]    @@unique([organizationId, goalCode])  @@index([organizationId])  @@map("long_term_goals")}model AnnualObjective {  id                String            @id @default(cuid())  organizationId    String    longTermGoalId    String  longTermGoal      LongTermGoal      @relation(fields: [longTermGoalId], references: [id], onDelete: Cascade)    // Link to BSC objective  bscObjectiveId    String?  bscObjective      StrategicObjective? @relation(fields: [bscObjectiveId], references: [id], onDelete: SetNull)    objectiveCode     String            // "AO1", "AO2"  objectiveName     String  objectiveDescription String?        @db.Text    // Fiscal year  fiscalYear        Int    // Target  targetValue       Float?  targetUnit        String?    // Progress  currentValue      Float?            @default(0)  completionPercent Float?            @default(0)    // Status  status            XMatrixStatus     @default(DRAFT)    // Owner  ownerUserId       String?  ownerTeamId       String?    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt    priorities        ImprovementPriority[]  correlations      XMatrixCorrelation[]  responsibleTeams  ResponsibleTeam[]    @@unique([organizationId, objectiveCode])  @@index([organizationId, fiscalYear])  @@index([longTermGoalId])  @@map("annual_objectives")}model ImprovementPriority {  id                String            @id @default(cuid())  organizationId    String    annualObjectiveId String  annualObjective   AnnualObjective   @relation(fields: [annualObjectiveId], references: [id], onDelete: Cascade)    priorityCode      String            // "IP1", "IP2"  priorityName      String  priorityDescription String?         @db.Text    // Focus area  focusArea         String?           // "Process Improvement", "Technology", "People"    // Resource allocation  budgetAllocated   Float?  budgetPercentage  Float?            // % of total budget  headcountAllocated Int?    // Priority level  priorityLevel     Int               @default(1) // 1 = highest    // Status  status            XMatrixStatus     @default(DRAFT)    // Progress  completionPercent Float?            @default(0)    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt    correlations      XMatrixCorrelation[]    @@unique([organizationId, priorityCode])  @@index([organizationId])  @@index([annualObjectiveId])  @@map("improvement_priorities")}model XMatrixCorrelation {  id                String              @id @default(cuid())    // What is correlated with what  longTermGoalId    String?  longTermGoal      LongTermGoal?       @relation(fields: [longTermGoalId], references: [id], onDelete: Cascade)    annualObjectiveId String?  annualObjective   AnnualObjective?    @relation(fields: [annualObjectiveId], references: [id], onDelete: Cascade)    priorityId        String?  priority          ImprovementPriority? @relation(fields: [priorityId], references: [id], onDelete: Cascade)    // Correlation strength  correlationStrength CorrelationStrength @default(NONE)    // Justification  justification     String?             @db.Text    // Metadata  metadata          Json?    createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt    @@index([longTermGoalId])  @@index([annualObjectiveId])  @@index([priorityId])  @@map("x_matrix_correlations")}enum CorrelationStrength {  NONE              // No correlation (0)  WEAK              // Weak (1)  MODERATE          // Moderate (3)  STRONG            // Strong (9)}model ResponsibleTeam {  id                String            @id @default(cuid())    annualObjectiveId String  annualObjective   AnnualObjective   @relation(fields: [annualObjectiveId], references: [id], onDelete: Cascade)    teamId            String  team              Team              @relation(fields: [teamId], references: [id], onDelete: Cascade)    // Role in achieving objective  role              TeamRole          @default(CONTRIBUTOR)    // Accountability level (1-5)  accountabilityLevel Int             @default(3)    // Contribution percentage  contributionPercent Float?    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt    @@unique([annualObjectiveId, teamId])  @@index([annualObjectiveId])  @@index([teamId])  @@map("responsible_teams")}enum TeamRole {  OWNER             // à¸«à¸¥à¸±à¸à¸œà¸¹à¹‰à¸£à¸±à¸šà¸œà¸´à¸”à¸Šà¸­à¸š  CO_OWNER          // à¸£à¹ˆà¸§à¸¡à¸£à¸±à¸šà¸œà¸´à¸”à¸Šà¸­à¸š  CONTRIBUTOR       // à¸ªà¸™à¸±à¸šà¸ªà¸™à¸¸à¸™  CONSULTED         // à¹ƒà¸«à¹‰à¸„à¸³à¸›à¸£à¸¶à¸à¸©à¸²  INFORMED          // à¸£à¸±à¸šà¸—à¸£à¸²à¸š}// Add to Team model:// annualObjectives ResponsibleTeam[]```---ğŸŒ± Step 2: Seed Data for TOWS & BSC```typescript// prisma/seed-tows-bsc.tsimport { PrismaClient, TOWSStrategyType, BSCPerspectiveType, KPIType, KPIPolarity } from '@prisma/client'const prisma = new PrismaClient()async function seedTOWSandBSC() {  console.log('ğŸ“Š Seeding TOWS & BSC...')  // Get NIEMS organization  const niems = await prisma.organization.findUnique({    where: { code: 'NIEMS' },  })  if (!niems) {    throw new Error('NIEMS organization not found. Run seed.ts first!')  }  // =========================================================================  // 1. Create TOWS Strategies  // =========================================================================  const towsStrategies = [    // SO Strategies (Strengths + Opportunities)    {      code: 'SO1',      type: TOWSStrategyType.SO,      name: 'à¸à¸±à¸’à¸™à¸²à¸£à¸°à¸šà¸š EMS à¸”à¹‰à¸§à¸¢ AI à¹à¸¥à¸° IoT',      desc: 'à¹ƒà¸Šà¹‰à¸„à¸§à¸²à¸¡à¹€à¸Šà¸µà¹ˆà¸¢à¸§à¸Šà¸²à¸à¸‚à¸­à¸‡à¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¹à¸¥à¸°à¹€à¸„à¸£à¸·à¸­à¸‚à¹ˆà¸²à¸¢à¸—à¸µà¹ˆà¸¡à¸µ à¸£à¹ˆà¸§à¸¡à¸à¸±à¸šà¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µ AI/IoT à¹€à¸à¸·à¹ˆà¸­à¸¢à¸à¸£à¸°à¸”à¸±à¸šà¸£à¸°à¸šà¸šà¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œà¸‰à¸¸à¸à¹€à¸‰à¸´à¸™',      strengths: ['S02', 'S03'], // à¸šà¸¸à¸„à¸¥à¸²à¸à¸£, à¸£à¸°à¸šà¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥      opportunities: ['O01'], // AI & IoT      priority: 9.5,      budget: 50000000,    },    {      code: 'SO2',      type: TOWSStrategyType.SO,      name: 'à¸‚à¸¢à¸²à¸¢à¹€à¸„à¸£à¸·à¸­à¸‚à¹ˆà¸²à¸¢à¸ªà¸¹à¹ˆà¸à¸·à¹‰à¸™à¸—à¸µà¹ˆà¸«à¹ˆà¸²à¸‡à¹„à¸à¸¥',      desc: 'à¹ƒà¸Šà¹‰à¹€à¸„à¸£à¸·à¸­à¸‚à¹ˆà¸²à¸¢à¸—à¸µà¹ˆà¸¡à¸µà¸­à¸¢à¸¹à¹ˆà¹à¸¥à¸°à¸™à¹‚à¸¢à¸šà¸²à¸¢à¸£à¸±à¸à¸šà¸²à¸¥à¸—à¸µà¹ˆà¸ªà¸™à¸±à¸šà¸ªà¸™à¸¸à¸™ à¹€à¸à¸·à¹ˆà¸­à¸‚à¸¢à¸²à¸¢à¸šà¸£à¸´à¸à¸²à¸£à¹„à¸›à¸¢à¸±à¸‡à¸à¸·à¹‰à¸™à¸—à¸µà¹ˆà¸«à¹ˆà¸²à¸‡à¹„à¸à¸¥',      strengths: ['S01'], // à¹€à¸„à¸£à¸·à¸­à¸‚à¹ˆà¸²à¸¢      opportunities: ['O02'], // à¸™à¹‚à¸¢à¸šà¸²à¸¢à¸£à¸±à¸à¸šà¸²à¸¥      priority: 8.7,      budget: 30000000,    },    // WO Strategies (Weaknesses + Opportunities)    {      code: 'WO1',      type: TOWSStrategyType.WO,      name: 'à¸à¸±à¸’à¸™à¸²à¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¸”à¹‰à¸§à¸¢à¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µ',      desc: 'à¹ƒà¸Šà¹‰à¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µ AI à¹€à¸à¸·à¹ˆà¸­à¸à¸±à¸’à¸™à¸²à¸—à¸±à¸à¸©à¸°à¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¹à¸¥à¸°à¸¥à¸”à¸›à¸±à¸à¸«à¸²à¸à¸²à¸£à¸à¸£à¸°à¸ˆà¸²à¸¢à¸•à¸±à¸§à¹„à¸¡à¹ˆà¹€à¸—à¹ˆà¸²à¹€à¸—à¸µà¸¢à¸¡',      weaknesses: ['W01'], // à¸à¸²à¸£à¸à¸£à¸°à¸ˆà¸²à¸¢à¸šà¸¸à¸„à¸¥à¸²à¸à¸£      opportunities: ['O01'], // AI & IoT      priority: 7.8,      budget: 20000000,    },    {      code: 'WO2',      type: TOWSStrategyType.WO,      name: 'à¸ªà¸£à¹‰à¸²à¸‡à¸„à¸§à¸²à¸¡à¸£à¹ˆà¸§à¸¡à¸¡à¸·à¸­à¸šà¸¹à¸£à¸“à¸²à¸à¸²à¸£',      desc: 'à¹ƒà¸Šà¹‰à¸™à¹‚à¸¢à¸šà¸²à¸¢à¸£à¸±à¸à¸šà¸²à¸¥à¹€à¸›à¹‡à¸™à¸•à¸±à¸§à¸‚à¸±à¸šà¹€à¸„à¸¥à¸·à¹ˆà¸­à¸™à¸à¸²à¸£à¸šà¸¹à¸£à¸“à¸²à¸à¸²à¸£à¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡à¸«à¸™à¹ˆà¸§à¸¢à¸‡à¸²à¸™',      weaknesses: ['W03'], // à¸‚à¸²à¸”à¸šà¸¹à¸£à¸“à¸²à¸à¸²à¸£      opportunities: ['O02'], // à¸™à¹‚à¸¢à¸šà¸²à¸¢à¸£à¸±à¸à¸šà¸²à¸¥      priority: 7.2,      budget: 15000000,    },    // ST Strategies (Strengths + Threats)    {      code: 'ST1',      type: TOWSStrategyType.ST,      name: 'à¹€à¸ªà¸£à¸´à¸¡à¸ªà¸£à¹‰à¸²à¸‡à¸„à¸§à¸²à¸¡à¸à¸£à¹‰à¸­à¸¡à¸£à¸±à¸šà¸¡à¸·à¸­à¸ à¸±à¸¢à¸à¸´à¸šà¸±à¸•à¸´',      desc: 'à¹ƒà¸Šà¹‰à¹€à¸„à¸£à¸·à¸­à¸‚à¹ˆà¸²à¸¢à¹à¸¥à¸°à¸„à¸§à¸²à¸¡à¹€à¸Šà¸µà¹ˆà¸¢à¸§à¸Šà¸²à¸à¸‚à¸­à¸‡à¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¹€à¸à¸·à¹ˆà¸­à¸£à¸±à¸šà¸¡à¸·à¸­à¸à¸±à¸šà¸ à¸±à¸¢à¸à¸´à¸šà¸±à¸•à¸´à¸—à¸µà¹ˆà¹€à¸à¸´à¹ˆà¸¡à¸‚à¸¶à¹‰à¸™',      strengths: ['S01', 'S02'], // à¹€à¸„à¸£à¸·à¸­à¸‚à¹ˆà¸²à¸¢, à¸šà¸¸à¸„à¸¥à¸²à¸à¸£      threats: ['T01'], // à¸ à¸±à¸¢à¸à¸´à¸šà¸±à¸•à¸´      priority: 8.5,      budget: 40000000,    },    // WT Strategies (Weaknesses + Threats)    {      code: 'WT1',      type: TOWSStrategyType.WT,      name: 'à¸›à¸£à¸±à¸šà¹‚à¸„à¸£à¸‡à¸ªà¸£à¹‰à¸²à¸‡à¸„à¹ˆà¸²à¸•à¸­à¸šà¹à¸—à¸™à¹à¸¥à¸°à¸ªà¸§à¸±à¸ªà¸”à¸´à¸à¸²à¸£',      desc: 'à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡à¸„à¹ˆà¸²à¸•à¸­à¸šà¹à¸—à¸™à¹à¸¥à¸°à¸ªà¸§à¸±à¸ªà¸”à¸´à¸à¸²à¸£à¹€à¸à¸·à¹ˆà¸­à¸¥à¸”à¸›à¸±à¸à¸«à¸²à¸à¸²à¸£à¹à¸‚à¹ˆà¸‡à¸‚à¸±à¸™à¸”à¹‰à¸²à¸™à¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¸à¸±à¸šà¹€à¸­à¸à¸Šà¸™',      weaknesses: ['W02'], // à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“à¸ˆà¸³à¸à¸±à¸”      threats: ['T02'], // à¹à¸‚à¹ˆà¸‡à¸‚à¸±à¸™à¸šà¸¸à¸„à¸¥à¸²à¸à¸£      priority: 6.5,      budget: 25000000,    },  ]  const createdStrategies: any[] = []  for (const strategy of towsStrategies) {    const created = await prisma.tOWSStrategy.create({      data: {        organizationId: niems.id,        strategyCode: strategy.code,        strategyType: strategy.type,        strategyName: strategy.name,        strategyDescription: strategy.desc,        linkedStrengths: strategy.strengths,        linkedWeaknesses: strategy.weaknesses || [],        linkedOpportunities: strategy.opportunities || [],        linkedThreaths: strategy.threats || [],        priorityScore: strategy.priority,        estimatedBudget: strategy.budget,        status: 'APPROVED',        approvedAt: new Date(),      },    })    createdStrategies.push(created)    console.log(`  âœ… Created strategy: ${strategy.code}`)  }  // Create rationale for SO1  await prisma.strategyRationale.create({    data: {      strategyId: createdStrategies[0].id,      rationaleText: `à¸à¸²à¸£à¸à¸±à¸’à¸™à¸²à¸£à¸°à¸šà¸š EMS à¸”à¹‰à¸§à¸¢ AI à¹à¸¥à¸° IoT à¹€à¸›à¹‡à¸™à¸à¸¥à¸¢à¸¸à¸—à¸˜à¹Œà¸—à¸µà¹ˆà¸ªà¸­à¸”à¸„à¸¥à¹‰à¸­à¸‡à¸à¸±à¸šà¸—à¸´à¸¨à¸—à¸²à¸‡à¸à¸²à¸£à¸à¸±à¸’à¸™à¸²à¸›à¸£à¸°à¹€à¸—à¸¨ à¹‚à¸”à¸¢à¸¡à¸µà¹€à¸«à¸•à¸¸à¸œà¸¥à¸”à¸±à¸‡à¸™à¸µà¹‰:1. **Market Analysis**: à¸•à¸¥à¸²à¸”à¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µà¸”à¹‰à¸²à¸™à¸ªà¸¸à¸‚à¸ à¸²à¸à¸à¸³à¸¥à¸±à¸‡à¹€à¸•à¸´à¸šà¹‚à¸•à¸­à¸¢à¹ˆà¸²à¸‡à¸£à¸§à¸”à¹€à¸£à¹‡à¸§ à¸„à¸²à¸”à¸§à¹ˆà¸²à¸ˆà¸°à¸¡à¸µà¸¡à¸¹à¸¥à¸„à¹ˆà¸² 500,000 à¸¥à¹‰à¸²à¸™à¸šà¸²à¸—à¹ƒà¸™à¸›à¸µ 25702. **Technology Readiness**: à¸¡à¸µà¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µ AI à¸ªà¸³à¹€à¸£à¹‡à¸ˆà¸£à¸¹à¸›à¸—à¸µà¹ˆà¸à¸£à¹‰à¸­à¸¡à¹ƒà¸Šà¹‰à¸‡à¸²à¸™ à¹€à¸Šà¹ˆà¸™:   - Predictive analytics à¸ªà¸³à¸«à¸£à¸±à¸šà¸à¸¢à¸²à¸à¸£à¸“à¹Œà¸„à¸§à¸²à¸¡à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸šà¸£à¸´à¸à¸²à¸£   - IoT sensors à¸ªà¸³à¸«à¸£à¸±à¸šà¸•à¸´à¸”à¸•à¸²à¸¡à¸ªà¸±à¸à¸à¸²à¸“à¸Šà¸µà¸ real-time   - Computer vision à¸ªà¸³à¸«à¸£à¸±à¸š triage à¸œà¸¹à¹‰à¸›à¹ˆà¸§à¸¢3. **Resource Analysis**:    - à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“: 50 à¸¥à¹‰à¸²à¸™à¸šà¸²à¸—   - à¸£à¸°à¸¢à¸°à¹€à¸§à¸¥à¸²: 18 à¹€à¸”à¸·à¸­à¸™   - à¸šà¸¸à¸„à¸¥à¸²à¸à¸£: 15 à¸„à¸™ (Data Scientists, Engineers, Domain Experts)4. **Risk Analysis**:   - à¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¹ˆà¸¢à¸‡à¸”à¹‰à¸²à¸™à¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µ: à¸•à¹ˆà¸³ (à¸¡à¸µà¸•à¸±à¸§à¸­à¸¢à¹ˆà¸²à¸‡à¸ªà¸³à¹€à¸£à¹‡à¸ˆà¸«à¸¥à¸²à¸¢à¸›à¸£à¸°à¹€à¸—à¸¨)   - à¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¹ˆà¸¢à¸‡à¸”à¹‰à¸²à¸™à¸à¸²à¸£à¸¢à¸­à¸¡à¸£à¸±à¸š: à¸›à¸²à¸™à¸à¸¥à¸²à¸‡ (à¸•à¹‰à¸­à¸‡à¸—à¸³ Change Management)   - à¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¹ˆà¸¢à¸‡à¸”à¹‰à¸²à¸™à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“: à¸•à¹ˆà¸³ (à¸¡à¸µà¹à¸«à¸¥à¹ˆà¸‡à¸—à¸¸à¸™à¸ªà¸™à¸±à¸šà¸ªà¸™à¸¸à¸™)      `,      expectedOutcomes: {        outcomes: [          'à¸¥à¸”à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸¥à¸‡ 20%',          'à¹€à¸à¸´à¹ˆà¸¡à¸„à¸§à¸²à¸¡à¹à¸¡à¹ˆà¸™à¸¢à¸³à¹ƒà¸™à¸à¸²à¸£ triage à¸œà¸¹à¹‰à¸›à¹ˆà¸§à¸¢à¹€à¸›à¹‡à¸™ 95%',          'à¸¥à¸”à¸­à¸±à¸•à¸£à¸²à¸à¸²à¸£à¹€à¸ªà¸µà¸¢à¸Šà¸µà¸§à¸´à¸•à¸ˆà¸²à¸à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸¥à¸‡ 15%',        ],      },    },  })  console.log('âœ… Created TOWS strategies')  // =========================================================================  // 2. Create BSC Perspectives  // =========================================================================  const perspectives = [    {      type: BSCPerspectiveType.FINANCIAL,      nameTh: 'à¸à¸²à¸£à¹€à¸‡à¸´à¸™',      nameEn: 'Financial',      order: 1,      color: '#10B981', // Green      icon: 'currency-dollar',    },    {      type: BSCPerspectiveType.CUSTOMER,      nameTh: 'à¸œà¸¹à¹‰à¸£à¸±à¸šà¸šà¸£à¸´à¸à¸²à¸£',      nameEn: 'Customer',      order: 2,      color: '#3B82F6', // Blue      icon: 'users',    },    {      type: BSCPerspectiveType.INTERNAL_PROCESS,      nameTh: 'à¸à¸£à¸°à¸šà¸§à¸™à¸à¸²à¸£à¸ à¸²à¸¢à¹ƒà¸™',      nameEn: 'Internal Process',      order: 3,      color: '#F59E0B', // Orange      icon: 'cog',    },    {      type: BSCPerspectiveType.LEARNING_GROWTH,      nameTh: 'à¸à¸²à¸£à¹€à¸£à¸µà¸¢à¸™à¸£à¸¹à¹‰à¹à¸¥à¸°à¹€à¸•à¸´à¸šà¹‚à¸•',      nameEn: 'Learning & Growth',      order: 4,      color: '#8B5CF6', // Purple      icon: 'academic-cap',    },  ]  for (const p of perspectives) {    await prisma.bSCPerspective.upsert({      where: { perspectiveType: p.type },      update: {},      create: {        perspectiveType: p.type,        nameTh: p.nameTh,        nameEn: p.nameEn,        displayOrder: p.order,        color: p.color,        icon: p.icon,      },    })  }  console.log('âœ… Created BSC perspectives')  // =========================================================================  // 3. Create Strategic Objectives  // =========================================================================  const financialPerspective = await prisma.bSCPerspective.findUnique({    where: { perspectiveType: BSCPerspectiveType.FINANCIAL },  })  const customerPerspective = await prisma.bSCPerspective.findUnique({    where: { perspectiveType: BSCPerspectiveType.CUSTOMER },  })  const processPerspective = await prisma.bSCPerspective.findUnique({    where: { perspectiveType: BSCPerspectiveType.INTERNAL_PROCESS },  })  const learningPerspective = await prisma.bSCPerspective.findUnique({    where: { perspectiveType: BSCPerspectiveType.LEARNING_GROWTH },  })  const objectives = [    // Financial Objectives    {      code: 'F1',      name: 'à¹€à¸à¸´à¹ˆà¸¡à¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸ à¸²à¸à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“',      desc: 'à¹ƒà¸Šà¹‰à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“à¸­à¸¢à¹ˆà¸²à¸‡à¸„à¸¸à¹‰à¸¡à¸„à¹ˆà¸² à¸¥à¸”à¸„à¹ˆà¸²à¹ƒà¸Šà¹‰à¸ˆà¹ˆà¸²à¸¢à¸—à¸µà¹ˆà¹„à¸¡à¹ˆà¸ˆà¸³à¹€à¸›à¹‡à¸™',      perspectiveId: financialPerspective!.id,      linkedStrategies: [createdStrategies[0].id, createdStrategies[1].id],      targetYear: 2027,      weight: 40,    },    {      code: 'F2',      name: 'à¹€à¸à¸´à¹ˆà¸¡à¸à¸²à¸£à¸ˆà¸±à¸”à¸ªà¸£à¸£à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“à¸•à¸²à¸¡à¸„à¸§à¸²à¸¡à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸ˆà¸£à¸´à¸‡',      desc: 'à¹ƒà¸Šà¹‰à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹ƒà¸™à¸à¸²à¸£à¸§à¸²à¸‡à¹à¸œà¸™à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“',      perspectiveId: financialPerspective!.id,      linkedStrategies: [createdStrategies[0].id],      targetYear: 2027,      weight: 30,    },    // Customer Objectives    {      code: 'C1',      name: 'à¸¥à¸”à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™',      desc: 'à¸¥à¸”à¹€à¸§à¸¥à¸²à¸•à¸±à¹‰à¸‡à¹à¸•à¹ˆà¸£à¸±à¸šà¹à¸ˆà¹‰à¸‡à¸ˆà¸™à¸–à¸¶à¸‡à¸›à¸à¸¡à¸à¸¢à¸²à¸šà¸²à¸¥',      perspectiveId: customerPerspective!.id,      linkedStrategies: [createdStrategies[0].id, createdStrategies[4].id],      targetYear: 2027,      weight: 50,    },    {      code: 'C2',      name: 'à¹€à¸à¸´à¹ˆà¸¡à¸„à¸§à¸²à¸¡à¸à¸¶à¸‡à¸à¸­à¹ƒà¸ˆà¸‚à¸­à¸‡à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸šà¸£à¸´à¸à¸²à¸£',      desc: 'à¸¢à¸à¸£à¸°à¸”à¸±à¸šà¸„à¸¸à¸“à¸ à¸²à¸à¸à¸²à¸£à¹ƒà¸«à¹‰à¸šà¸£à¸´à¸à¸²à¸£',      perspectiveId: customerPerspective!.id,      linkedStrategies: [createdStrategies[1].id],      targetYear: 2027,      weight: 30,    },    // Internal Process Objectives    {      code: 'I1',      name: 'à¸à¸±à¸’à¸™à¸²à¸£à¸°à¸šà¸š EMS à¸”à¹‰à¸§à¸¢à¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µ',      desc: 'à¸™à¸³à¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µà¸¡à¸²à¹ƒà¸Šà¹‰à¹ƒà¸™à¸à¸²à¸£à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡à¸à¸£à¸°à¸šà¸§à¸™à¸à¸²à¸£',      perspectiveId: processPerspective!.id,      linkedStrategies: [createdStrategies[0].id],      targetYear: 2027,      weight: 40,    },    {      code: 'I2',      name: 'à¸ªà¸£à¹‰à¸²à¸‡à¹€à¸„à¸£à¸·à¸­à¸‚à¹ˆà¸²à¸¢à¸„à¸§à¸²à¸¡à¸£à¹ˆà¸§à¸¡à¸¡à¸·à¸­',      desc: 'à¸šà¸¹à¸£à¸“à¸²à¸à¸²à¸£à¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡à¸«à¸™à¹ˆà¸§à¸¢à¸‡à¸²à¸™',      perspectiveId: processPerspective!.id,      linkedStrategies: [createdStrategies[3].id],      targetYear: 2027,      weight: 35,    },    // Learning & Growth Objectives    {      code: 'L1',      name: 'à¸à¸±à¸’à¸™à¸²à¸ªà¸¡à¸£à¸£à¸–à¸™à¸°à¸šà¸¸à¸„à¸¥à¸²à¸à¸£',      desc: 'à¸¢à¸à¸£à¸°à¸”à¸±à¸šà¸—à¸±à¸à¸©à¸°à¹à¸¥à¸°à¸„à¸§à¸²à¸¡à¸£à¸¹à¹‰à¸‚à¸­à¸‡à¸šà¸¸à¸„à¸¥à¸²à¸à¸£',      perspectiveId: learningPerspective!.id,      linkedStrategies: [createdStrategies[2].id],      targetYear: 2027,      weight: 45,    },    {      code: 'L2',      name: 'à¸ªà¸£à¹‰à¸²à¸‡à¸§à¸±à¸’à¸™à¸˜à¸£à¸£à¸¡à¸™à¸§à¸±à¸•à¸à¸£à¸£à¸¡',      desc: 'à¸ªà¹ˆà¸‡à¹€à¸ªà¸£à¸´à¸¡à¸à¸²à¸£à¹€à¸£à¸µà¸¢à¸™à¸£à¸¹à¹‰à¹à¸¥à¸°à¸™à¸§à¸±à¸•à¸à¸£à¸£à¸¡',      perspectiveId: learningPerspective!.id,      linkedStrategies: [createdStrategies[0].id],      targetYear: 2027,      weight: 30,    },  ]  const createdObjectives: any[] = []  for (const obj of objectives) {    const created = await prisma.strategicObjective.create({      data: {        organizationId: niems.id,        perspectiveId: obj.perspectiveId,        objectiveCode: obj.code,        objectiveName: obj.name,        objectiveDescription: obj.desc,        linkedStrategyIds: obj.linkedStrategies,        targetYear: obj.targetYear,        weightPercentage: obj.weight,        status: 'APPROVED',        currentScore: 0,        targetScore: 100,      },    })    createdObjectives.push(created)    console.log(`  âœ… Created objective: ${obj.code}`)  }  console.log('âœ… Created strategic objectives')  // =========================================================================  // 4. Create KPIs  // =========================================================================  const kpis = [    // F1: à¹€à¸à¸´à¹ˆà¸¡à¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸ à¸²à¸à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“    {      objectiveId: createdObjectives[0].id, // F1      code: 'F1.1',      name: 'à¸£à¹‰à¸­à¸¢à¸¥à¸°à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸ˆà¹ˆà¸²à¸¢à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“à¸•à¸²à¸¡à¹à¸œà¸™',      desc: 'à¸§à¸±à¸”à¸„à¸§à¸²à¸¡à¸ªà¸²à¸¡à¸²à¸£à¸–à¹ƒà¸™à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“à¸•à¸²à¸¡à¸—à¸µà¹ˆà¸§à¸²à¸‡à¹à¸œà¸™à¹„à¸§à¹‰',      unit: '%',      type: KPIType.LAGGING,      polarity: KPIPolarity.HIGHER_BETTER,      baseline: 85,      baselineYear: 2023,      target: 95,      targetYear: 2027,      current: 87,      frequency: 'QUARTERLY',      weight: 60,    },    {      objectiveId: createdObjectives[0].id, // F1      code: 'F1.2',      name: 'à¸­à¸±à¸•à¸£à¸²à¸à¸²à¸£à¸›à¸£à¸°à¸«à¸¢à¸±à¸”à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“',      desc: 'à¸£à¹‰à¸­à¸¢à¸¥à¸°à¸‚à¸­à¸‡à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“à¸—à¸µà¹ˆà¸›à¸£à¸°à¸«à¸¢à¸±à¸”à¹„à¸”à¹‰',      unit: '%',      type: KPIType.LAGGING,      polarity: KPIPolarity.HIGHER_BETTER,      baseline: 5,      baselineYear: 2023,      target: 10,      targetYear: 2027,      current: 6.5,      frequency: 'ANNUAL',      weight: 40,    },    // C1: à¸¥à¸”à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™    {      objectiveId: createdObjectives[2].id, // C1      code: 'C1.1',      name: 'à¹€à¸§à¸¥à¸²à¹€à¸‰à¸¥à¸µà¹ˆà¸¢à¹ƒà¸™à¸à¸²à¸£à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™',      desc: 'à¹€à¸§à¸¥à¸²à¹€à¸‰à¸¥à¸µà¹ˆà¸¢à¸•à¸±à¹‰à¸‡à¹à¸•à¹ˆà¸£à¸±à¸šà¹à¸ˆà¹‰à¸‡à¸ˆà¸™à¸–à¸¶à¸‡à¸›à¸à¸¡à¸à¸¢à¸²à¸šà¸²à¸¥',      unit: 'à¸™à¸²à¸—à¸µ',      type: KPIType.LAGGING,      polarity: KPIPolarity.LOWER_BETTER,      baseline: 15,      baselineYear: 2023,      target: 12,      targetYear: 2027,      current: 14,      frequency: 'MONTHLY',      weight: 70,    },    {      objectiveId: createdObjectives[2].id, // C1      code: 'C1.2',      name: 'à¸£à¹‰à¸­à¸¢à¸¥à¸°à¸‚à¸­à¸‡à¸à¸£à¸“à¸µà¸—à¸µà¹ˆà¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸ à¸²à¸¢à¹ƒà¸™ 10 à¸™à¸²à¸—à¸µ',      desc: 'à¸§à¸±à¸”à¸„à¸§à¸²à¸¡à¸£à¸§à¸”à¹€à¸£à¹‡à¸§à¹ƒà¸™à¸à¸²à¸£à¹ƒà¸«à¹‰à¸šà¸£à¸´à¸à¸²à¸£',      unit: '%',      type: KPIType.LAGGING,      polarity: KPIPolarity.HIGHER_BETTER,      baseline: 60,      baselineYear: 2023,      target: 80,      targetYear: 2027,      current: 65,      frequency: 'MONTHLY',      weight: 30,    },    // C2: à¹€à¸à¸´à¹ˆà¸¡à¸„à¸§à¸²à¸¡à¸à¸¶à¸‡à¸à¸­à¹ƒà¸ˆ    {      objectiveId: createdObjectives[3].id, // C2      code: 'C2.1',      name: 'à¸„à¸°à¹à¸™à¸™à¸„à¸§à¸²à¸¡à¸à¸¶à¸‡à¸à¸­à¹ƒà¸ˆà¸‚à¸­à¸‡à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸šà¸£à¸´à¸à¸²à¸£',      desc: 'à¸„à¸°à¹à¸™à¸™à¹€à¸‰à¸¥à¸µà¹ˆà¸¢à¸ˆà¸²à¸à¹à¸šà¸šà¸ªà¸­à¸šà¸–à¸²à¸¡',      unit: 'à¸„à¸°à¹à¸™à¸™',      type: KPIType.LAGGING,      polarity: KPIPolarity.HIGHER_BETTER,      baseline: 4.2,      baselineYear: 2023,      target: 4.5,      targetYear: 2027,      current: 4.3,      frequency: 'QUARTERLY',      weight: 100,    },    // I1: à¸à¸±à¸’à¸™à¸²à¸£à¸°à¸šà¸š EMS    {      objectiveId: createdObjectives[4].id, // I1      code: 'I1.1',      name: 'à¸£à¹‰à¸­à¸¢à¸¥à¸°à¸‚à¸­à¸‡à¸«à¸™à¹ˆà¸§à¸¢à¸šà¸£à¸´à¸à¸²à¸£à¸—à¸µà¹ˆà¹ƒà¸Šà¹‰à¸£à¸°à¸šà¸š EMS à¸”à¸´à¸ˆà¸´à¸—à¸±à¸¥',      desc: 'à¸§à¸±à¸”à¸à¸²à¸£à¸™à¸³à¸£à¸°à¸šà¸šà¸”à¸´à¸ˆà¸´à¸—à¸±à¸¥à¸¡à¸²à¹ƒà¸Šà¹‰',      unit: '%',      type: KPIType.LEADING,      polarity: KPIPolarity.HIGHER_BETTER,      baseline: 40,      baselineYear: 2023,      target: 90,      targetYear: 2027,      current: 55,      frequency: 'QUARTERLY',      weight: 60,    },    // L1: à¸à¸±à¸’à¸™à¸²à¸ªà¸¡à¸£à¸£à¸–à¸™à¸°à¸šà¸¸à¸„à¸¥à¸²à¸à¸£    {      objectiveId: createdObjectives[6].id, // L1      code: 'L1.1',      name: 'à¸ˆà¸³à¸™à¸§à¸™à¸Šà¸±à¹ˆà¸§à¹‚à¸¡à¸‡à¸à¸²à¸£à¸à¸¶à¸à¸­à¸šà¸£à¸¡à¹€à¸‰à¸¥à¸µà¹ˆà¸¢à¸•à¹ˆà¸­à¸„à¸™à¸•à¹ˆà¸­à¸›à¸µ',      desc: 'à¸§à¸±à¸”à¸à¸²à¸£à¸¥à¸‡à¸—à¸¸à¸™à¹ƒà¸™à¸à¸²à¸£à¸à¸±à¸’à¸™à¸²à¸šà¸¸à¸„à¸¥à¸²à¸à¸£',      unit: 'à¸Šà¸±à¹ˆà¸§à¹‚à¸¡à¸‡',      type: KPIType.LEADING,      polarity: KPIPolarity.HIGHER_BETTER,      baseline: 40,      baselineYear: 2023,      target: 60,      targetYear: 2027,      current: 45,      frequency: 'ANNUAL',      weight: 50,    },    {      objectiveId: createdObjectives[6].id, // L1      code: 'L1.2',      name: 'à¸£à¹‰à¸­à¸¢à¸¥à¸°à¸‚à¸­à¸‡à¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¸—à¸µà¹ˆà¸œà¹ˆà¸²à¸™à¸à¸²à¸£à¸£à¸±à¸šà¸£à¸­à¸‡',      desc: 'à¸§à¸±à¸”à¸„à¸¸à¸“à¸ à¸²à¸à¸šà¸¸à¸„à¸¥à¸²à¸à¸£',      unit: '%',      type: KPIType.LAGGING,      polarity: KPIPolarity.HIGHER_BETTER,      baseline: 75,      baselineYear: 2023,      target: 90,      targetYear: 2027,      current: 80,      frequency: 'ANNUAL',      weight: 50,    },  ]  for (const kpi of kpis) {    const created = await prisma.kPI.create({      data: {        objectiveId: kpi.objectiveId,        kpiCode: kpi.code,        kpiName: kpi.name,        kpiDescription: kpi.desc,        measurementUnit: kpi.unit,        kpiType: kpi.type,        polarity: kpi.polarity,        baselineValue: kpi.baseline,        baselineYear: kpi.baselineYear,        targetValue: kpi.target,        targetYear: kpi.targetYear,        currentValue: kpi.current,        reportingFrequency: kpi.frequency as any,        weightPercentage: kpi.weight,        lastUpdated: new Date(),      },    })    // Calculate achievement rate    const achievement = ((kpi.current - kpi.baseline) / (kpi.target - kpi.baseline)) * 100    const trafficLight =      achievement >= 80 ? 'GREEN' : achievement >= 60 ? 'YELLOW' : 'RED'    await prisma.kPI.update({      where: { id: created.id },      data: {        achievementRate: achievement,        trafficLight: trafficLight as any,      },    })    console.log(`  âœ… Created KPI: ${kpi.code}`)  }  console.log('âœ… Created KPIs')  // =========================================================================  // 5. Create Strategy Map (Causal Relationships)  // =========================================================================  // Create nodes first  for (const obj of createdObjectives) {    await prisma.strategyMapNode.create({      data: {        objectiveId: obj.id,        displayLabel: obj.objectiveName.substring(0, 50),      },    })  }  // Create causal links (bottom-up: L&G â†’ Process â†’ Customer â†’ Financial)  const causalLinks = [    // L1 â†’ I1 (Learning enables Process improvement)    {      source: createdObjectives[6].id, // L1      target: createdObjectives[4].id, // I1      type: 'ENABLES',      strength: 0.8,      evidence: 'à¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¸—à¸µà¹ˆà¸¡à¸µà¸—à¸±à¸à¸©à¸°à¸ªà¸¹à¸‡à¸ªà¸²à¸¡à¸²à¸£à¸–à¸™à¸³à¸£à¸°à¸šà¸šà¸”à¸´à¸ˆà¸´à¸—à¸±à¸¥à¸¡à¸²à¹ƒà¸Šà¹‰à¹„à¸”à¹‰à¸”à¸µà¸‚à¸¶à¹‰à¸™',    },    // L2 â†’ I1    {      source: createdObjectives[7].id, // L2      target: createdObjectives[4].id, // I1      type: 'SUPPORTS',      strength: 0.6,      evidence: 'à¸§à¸±à¸’à¸™à¸˜à¸£à¸£à¸¡à¸™à¸§à¸±à¸•à¸à¸£à¸£à¸¡à¸ªà¹ˆà¸‡à¹€à¸ªà¸£à¸´à¸¡à¸à¸²à¸£à¸™à¸³à¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µà¸¡à¸²à¹ƒà¸Šà¹‰',    },    // I1 â†’ C1 (Process improvement enables Customer satisfaction)    {      source: createdObjectives[4].id, // I1      target: createdObjectives[2].id, // C1      type: 'ENABLES',      strength: 0.9,      evidence: 'à¸£à¸°à¸šà¸šà¸”à¸´à¸ˆà¸´à¸—à¸±à¸¥à¸Šà¹ˆà¸§à¸¢à¸¥à¸”à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡',    },    // I2 â†’ C1    {      source: createdObjectives[5].id, // I2      target: createdObjectives[2].id, // C1      type: 'SUPPORTS',      strength: 0.7,      evidence: 'à¹€à¸„à¸£à¸·à¸­à¸‚à¹ˆà¸²à¸¢à¸—à¸µà¹ˆà¹€à¸‚à¹‰à¸¡à¹à¸‚à¹‡à¸‡à¸Šà¹ˆà¸§à¸¢à¹€à¸à¸´à¹ˆà¸¡à¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸ à¸²à¸à¸à¸²à¸£à¹ƒà¸«à¹‰à¸šà¸£à¸´à¸à¸²à¸£',    },    // C1 â†’ C2    {      source: createdObjectives[2].id, // C1      target: createdObjectives[3].id, // C2      type: 'CONTRIBUTES_TO',      strength: 0.85,      evidence: 'à¸à¸²à¸£à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸—à¸µà¹ˆà¸£à¸§à¸”à¹€à¸£à¹‡à¸§à¹€à¸à¸´à¹ˆà¸¡à¸„à¸§à¸²à¸¡à¸à¸¶à¸‡à¸à¸­à¹ƒà¸ˆ',    },    // C1 â†’ F1 (Customer outcomes lead to Financial outcomes)    {      source: createdObjectives[2].id, // C1      target: createdObjectives[0].id, // F1      type: 'CONTRIBUTES_TO',      strength: 0.6,      evidence: 'à¸šà¸£à¸´à¸à¸²à¸£à¸—à¸µà¹ˆà¸¡à¸µà¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸ à¸²à¸à¸Šà¹ˆà¸§à¸¢à¸›à¸£à¸°à¸«à¸¢à¸±à¸”à¸„à¹ˆà¸²à¹ƒà¸Šà¹‰à¸ˆà¹ˆà¸²à¸¢',    },    // I1 â†’ F1    {      source: createdObjectives[4].id, // I1      target: createdObjectives[0].id, // F1      type: 'CONTRIBUTES_TO',      strength: 0.7,      evidence: 'à¸£à¸°à¸šà¸šà¸”à¸´à¸ˆà¸´à¸—à¸±à¸¥à¸¥à¸”à¸•à¹‰à¸™à¸—à¸¸à¸™à¸à¸²à¸£à¸”à¸³à¹€à¸™à¸´à¸™à¸‡à¸²à¸™',    },  ]  for (const link of causalLinks) {    await prisma.causalRelationship.create({      data: {        sourceObjectiveId: link.source,        targetObjectiveId: link.target,        relationshipType: link.type as any,        strength: link.strength,        evidence: link.evidence,        validated: true,        validatedAt: new Date(),      },    })  }  console.log('âœ… Created strategy map relationships')  console.log('\nğŸ‰ TOWS & BSC seed completed successfully!')}seedTOWSandBSC()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error('âŒ Seed failed:', e)    await prisma.$disconnect()    process.exit(1)  })```---ğŸ“¦ Step 3: Update package.json```json{  "scripts": {    "db:seed-tows-bsc": "tsx prisma/seed-tows-bsc.ts",    "db:seed-all": "pnpm db:seed && pnpm db:seed-rbac && pnpm db:seed-tows-bsc"  }}```---ğŸ” Step 4: Query Examples```typescript// lib/queries/bsc-queries.ts// 1. Get complete BSC dashboard for an organizationexport async function getBSCDashboard(organizationId: string) {  const perspectives = await prisma.bSCPerspective.findMany({    where: { isActive: true },    include: {      objectives: {        where: {          organizationId,          status: 'APPROVED',          deletedAt: null,        },        include: {          kpis: {            where: { isActive: true },            include: {              actuals: {                orderBy: { measurementDate: 'desc' },                take: 1, // Latest actual              },            },          },        },        orderBy: { displayOrder: 'asc' },      },    },    orderBy: { displayOrder: 'asc' },  })  // Calculate perspective scores  const dashboardData = perspectives.map((perspective) => {    const objectives = perspective.objectives.map((obj) => {      const kpiScores = obj.kpis.map((kpi) => kpi.achievementRate || 0)      const objectiveScore =        kpiScores.length > 0          ? kpiScores.reduce((sum, score) => sum + score, 0) / kpiScores.length          : 0      return {        ...obj,        calculatedScore: objectiveScore,      }    })    const perspectiveScore =      objectives.length > 0        ? objectives.reduce((sum, obj) => sum + obj.calculatedScore, 0) /          objectives.length        : 0    return {      ...perspective,      objectives,      perspectiveScore,      trafficLight:        perspectiveScore >= 80          ? 'GREEN'          : perspectiveScore >= 60          ? 'YELLOW'          : 'RED',    }  })  return dashboardData}// 2. Get strategy map dataexport async function getStrategyMap(organizationId: string) {  const objectives = await prisma.strategicObjective.findMany({    where: {      organizationId,      status: 'APPROVED',      deletedAt: null,    },    include: {      perspective: true,      strategyMapNodes: true,      causalSourceLinks: {        include: {          targetObjective: true,        },      },      kpis: {        where: { isActive: true },        select: {          id: true,          kpiCode: true,          currentValue: true,          targetValue: true,          achievementRate: true,          trafficLight: true,        },      },    },  })  // Format for D3.js visualization  const nodes = objectives.map((obj) => ({    id: obj.id,    code: obj.objectiveCode,    name: obj.objectiveName,    perspective: obj.perspective.perspectiveType,    perspectiveColor: obj.perspective.color,    score: obj.currentScore,    trafficLight: obj.trafficLight,    x: obj.strategyMapNodes[0]?.positionX,    y: obj.strategyMapNodes[0]?.positionY,  }))  const links = objectives.flatMap((obj) =>    obj.causalSourceLinks.map((link) => ({      source: obj.id,      target: link.targetObjectiveId,      type: link.relationshipType,      strength: link.strength,      validated: link.validated,    }))  )  return { nodes, links }}// 3. Get TOWS strategies with performanceexport async function getTOWSStrategiesWithPerformance(organizationId: string) {  const strategies = await prisma.tOWSStrategy.findMany({    where: {      organizationId,      deletedAt: null,    },    include: {      objectives: {        include: {          kpis: {            select: {              achievementRate: true,              trafficLight: true,            },          },        },      },      projects: {        select: {          status: true,          completionPercentage: true,        },      },    },    orderBy: { overallRank: 'asc' },  })  return strategies.map((strategy) => {    // Calculate strategy performance from linked objectives    const objectiveScores = strategy.objectives.map((obj) => {      const kpiScores = obj.kpis.map((kpi) => kpi.achievementRate || 0)      return kpiScores.length > 0        ? kpiScores.reduce((sum, score) => sum + score, 0) / kpiScores.length        : 0    })    const strategyScore =      objectiveScores.length > 0        ? objectiveScores.reduce((sum, score) => sum + score, 0) /          objectiveScores.length        : 0    // Calculate project progress    const projectProgress =      strategy.projects.length > 0        ? strategy.projects.reduce(            (sum, p) => sum + (p.completionPercentage || 0),            0          ) / strategy.projects.length        : 0    return {      ...strategy,      performanceScore: strategyScore,      projectProgress,      trafficLight:        strategyScore >= 80 ? 'GREEN' : strategyScore >= 60 ? 'YELLOW' : 'RED',    }  })}// 4. Update KPI actual valueexport async function updateKPIActual(  kpiId: string,  actualValue: number,  measurementDate: Date,  userId: string) {  const kpi = await prisma.kPI.findUnique({    where: { id: kpiId },    include: {      targets: {        where: {          year: measurementDate.getFullYear(),          quarter: Math.ceil((measurementDate.getMonth() + 1) / 3),        },        take: 1,      },    },  })  if (!kpi) throw new Error('KPI not found')  const target = kpi.targets[0]?.targetValue || kpi.targetValue  // Calculate variance  const variance = actualValue - target  const variancePercent = (variance / target) * 100  // Calculate achievement rate  let achievementRate = 0  if (kpi.polarity === KPIPolarity.HIGHER_BETTER) {    achievementRate = (actualValue / target) * 100  } else if (kpi.polarity === KPIPolarity.LOWER_BETTER) {    achievementRate = (target / actualValue) * 100  }  // Determine traffic light  const trafficLight: TrafficLightStatus =    achievementRate >= (kpi.greenThreshold || 80)      ? TrafficLightStatus.GREEN      : achievementRate >= (kpi.yellowThreshold || 60)      ? TrafficLightStatus.YELLOW      : TrafficLightStatus.RED  // Create actual record  const actual = await prisma.kPIActual.create({    data: {      kpiId,      measurementDate,      year: measurementDate.getFullYear(),      quarter: Math.ceil((measurementDate.getMonth() + 1) / 3),      month: measurementDate.getMonth() + 1,      actualValue,      variance,      variancePercent,      status: DataStatus.SUBMITTED,      createdById: userId,    },  })  // Update KPI current value  await prisma.kPI.update({    where: { id: kpiId },    data: {      currentValue: actualValue,      achievementRate,      trafficLight,      lastUpdated: new Date(),    },  })  return actual}```---âœ… Verification Checklistà¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸à¸£à¸±à¸™ seed à¹ƒà¸«à¹‰à¹€à¸Šà¹‡à¸„à¸§à¹ˆà¸²à¸¡à¸µà¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸„à¸£à¸š:```âœ… 6 TOWS Strategies (SO, WO, ST, WT)âœ… 1 Strategy Rationale (for SO1)âœ… 4 BSC Perspectivesâœ… 8 Strategic Objectives (2 per perspective)âœ… 8 KPIs across objectivesâœ… 8 Strategy Map Nodesâœ… 7 Causal Relationships```---ğŸš€ Next: Run Complete Seed```bash# Run all seeds in sequencepnpm db:seed-all# Or individuallypnpm db:seed              # Organizations, SWOT, Delphipnpm db:seed-rbac         # Roles, Permissions, Auditpnpm db:seed-tows-bsc     # TOWS, BSC, Strategy Map# Open Prisma Studio to view datapnpm db:studio```---ğŸ¯ Summary - What We Have NowPhase 1 âœ…User ManagementOrganizationsSWOT + DelphiPhase 2 âœ…RBAC (7 roles)Audit TrailPermissionsPhase 3 âœ…TOWS Strategies (6 strategies)BSC (4 perspectives, 8 objectives, 8 KPIs)Strategy Map (causal relationships)Hoshin Kanri (X-Matrix structure)---ğŸ“Š Next Steps OptionsPhase 4: Projects & Gantt â†’ Project management schemaPhase 5: OKR Cascading â†’ OKR system schemaPhase 6: Logframe â†’ Logical Framework AnalysisCreate tRPC API â†’ Build API endpointsBuild React UI â†’ Start building componentsà¸„à¸¸à¸“à¸à¸£à¹‰à¸­à¸¡à¸ˆà¸°à¸—à¸³à¸­à¸±à¸™à¹„à¸«à¸™à¸•à¹ˆà¸­à¸„à¸£à¸±à¸š? ğŸš€---ğŸ—ï¸ Database Schema - Part 4: Project Management & Ganttà¸•à¹ˆà¸­à¸ˆà¸²à¸ Phase 3 à¹€à¸£à¸²à¸ˆà¸°à¹€à¸à¸´à¹ˆà¸¡ Project Portfolio Management, WBS, Gantt Chart, Activity-Based Costing, à¹à¸¥à¸° Logical Framework Analysis (LFA)---ğŸ“‹ Step 1: Project Management Schema```prisma// prisma/schema.prisma (continued from Part 3)// ============================================================================// SECTION 15: PROJECT PORTFOLIO MANAGEMENT// ============================================================================enum ProjectStatus {  PROPOSED          // à¹€à¸ªà¸™à¸­à¹‚à¸„à¸£à¸‡à¸à¸²à¸£  UNDER_REVIEW      // à¸à¸³à¸¥à¸±à¸‡à¸à¸´à¸ˆà¸²à¸£à¸“à¸²  APPROVED          // à¸­à¸™à¸¸à¸¡à¸±à¸•à¸´à¹à¸¥à¹‰à¸§  PLANNING          // à¸à¸³à¸¥à¸±à¸‡à¸§à¸²à¸‡à¹à¸œà¸™  ACTIVE            // à¸”à¸³à¹€à¸™à¸´à¸™à¸à¸²à¸£  ON_HOLD           // à¸à¸±à¸à¸Šà¸±à¹ˆà¸§à¸„à¸£à¸²à¸§  AT_RISK           // à¸¡à¸µà¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¹ˆà¸¢à¸‡  DELAYED           // à¸¥à¹ˆà¸²à¸Šà¹‰à¸²  COMPLETED         // à¹€à¸ªà¸£à¹‡à¸ˆà¸ªà¸´à¹‰à¸™  CANCELLED         // à¸¢à¸à¹€à¸¥à¸´à¸  ARCHIVED          // à¹€à¸à¹‡à¸šà¸–à¸²à¸§à¸£}enum ProjectPriority {  CRITICAL          // à¸ªà¸³à¸„à¸±à¸à¸¡à¸²à¸  HIGH              // à¸ªà¸¹à¸‡  MEDIUM            // à¸›à¸²à¸™à¸à¸¥à¸²à¸‡  LOW               // à¸•à¹ˆà¸³}enum ProjectType {  STRATEGIC         // à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¸¢à¸¸à¸—à¸˜à¸¨à¸²à¸ªà¸•à¸£à¹Œ  OPERATIONAL       // à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¸›à¸à¸´à¸šà¸±à¸•à¸´à¸à¸²à¸£  IMPROVEMENT       // à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡  INNOVATION        // à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¸™à¸§à¸±à¸•à¸à¸£à¸£à¸¡  INFRASTRUCTURE    // à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¹‚à¸„à¸£à¸‡à¸ªà¸£à¹‰à¸²à¸‡à¸à¸·à¹‰à¸™à¸à¸²à¸™  RESEARCH          // à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¸§à¸´à¸ˆà¸±à¸¢}model Project {  id                String            @id @default(cuid())  organizationId    String  organization      Organization      @relation(fields: [organizationId], references: [id], onDelete: Cascade)    // Identification  projectCode       String            // "PRJ-2024-001"  projectName       String  projectDescription String           @db.Text    // Strategic alignment  linkedStrategyIds String[]          // Array of TOWS strategy IDs  linkedObjectiveIds String[]         // Array of BSC objective IDs    // Classification  projectType       ProjectType  priority          ProjectPriority   @default(MEDIUM)    // Scope  projectScope      String?           @db.Text  deliverables      Json?             // Array of expected deliverables  exclusions        String?           @db.Text // Out of scope    // Team  projectManagerId  String?  projectManager    User?             @relation("ProjectManager", fields: [projectManagerId], references: [id], onDelete: SetNull)    sponsorId         String?           // Executive sponsor  sponsor           User?             @relation("ProjectSponsor", fields: [sponsorId], references: [id], onDelete: SetNull)    teamId            String?  team              Team?             @relation(fields: [teamId], references: [id], onDelete: SetNull)    // Timeline  plannedStartDate  DateTime?  plannedEndDate    DateTime?  actualStartDate   DateTime?  actualEndDate     DateTime?    durationDays      Int?              // Planned duration  actualDurationDays Int?             // Actual duration    // Budget  totalBudget       Float?  budgetSpent       Float?            @default(0)  budgetRemaining   Float?            // Calculated: totalBudget - budgetSpent  budgetVariance    Float?            // Calculated: budgetRemaining  budgetVariancePercent Float?        // (variance / totalBudget) Ã— 100    // Progress  completionPercentage Float?         @default(0) // 0-100    weightedProgress  Float?            @default(0) // Weighted by WBS task weights    // Health indicators  scheduleHealth    HealthStatus?  budgetHealth      HealthStatus?  scopeHealth       HealthStatus?  overallHealth     HealthStatus?    // Risk level  riskLevel         RiskLevel?        @default(MEDIUM)    // Status  status            ProjectStatus     @default(PROPOSED)    // Approval workflow  submittedAt       DateTime?  submittedBy       String?    approvedAt        DateTime?  approvedBy        String?  approvalNotes     String?           @db.Text    // Metadata  tags              String[]  metadata          Json?    // Timestamps  createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt  deletedAt         DateTime?  createdById       String?    // Relations  wbsElements       WBSElement[]  milestones        Milestone[]  risks             ProjectRisk[]  issues            ProjectIssue[]  changes           ProjectChange[]  documents         ProjectDocument[]  statusReports     ProjectStatusReport[]  logframe          LogframeElement[]    @@unique([organizationId, projectCode])  @@index([organizationId])  @@index([status])  @@index([priority])  @@index([projectManagerId])  @@map("projects")}// Add to Organization model:// projects Project[]// Add to User model:// managedProjects Project[] @relation("ProjectManager")// sponsoredProjects Project[] @relation("ProjectSponsor")// Add to Team model:// projects Project[]enum HealthStatus {  HEALTHY           // à¹€à¸‚à¸µà¸¢à¸§ - à¹„à¸¡à¹ˆà¸¡à¸µà¸›à¸±à¸à¸«à¸²  AT_RISK           // à¹€à¸«à¸¥à¸·à¸­à¸‡ - à¸¡à¸µà¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¹ˆà¸¢à¸‡  CRITICAL          // à¹à¸”à¸‡ - à¸¡à¸µà¸›à¸±à¸à¸«à¸²à¸£à¹‰à¸²à¸¢à¹à¸£à¸‡  UNKNOWN           // à¹€à¸—à¸² - à¹„à¸¡à¹ˆà¸—à¸£à¸²à¸šà¸ªà¸–à¸²à¸™à¸°}enum RiskLevel {  VERY_LOW  LOW  MEDIUM  HIGH  VERY_HIGH  CRITICAL}// ============================================================================// SECTION 16: WORK BREAKDOWN STRUCTURE (WBS)// ============================================================================enum WBSElementType {  PHASE             // à¸£à¸°à¸¢à¸° (Level 1)  DELIVERABLE       // à¸œà¸¥à¸¥à¸±à¸à¸˜à¹Œ (Level 2)  ACTIVITY          // à¸à¸´à¸ˆà¸à¸£à¸£à¸¡ (Level 3)  TASK              // à¸‡à¸²à¸™ (Level 4)  SUBTASK           // à¸‡à¸²à¸™à¸¢à¹ˆà¸­à¸¢ (Level 5+)}enum TaskStatus {  NOT_STARTED  IN_PROGRESS  ON_HOLD  COMPLETED  CANCELLED}model WBSElement {  id                String          @id @default(cuid())  projectId         String  project           Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)    // Hierarchy  parentWBSId       String?  parentWBS         WBSElement?     @relation("WBSHierarchy", fields: [parentWBSId], references: [id], onDelete: Cascade)  childWBS          WBSElement[]    @relation("WBSHierarchy")    // Identification  wbsCode           String          // "1", "1.1", "1.1.1", "1.1.1.1"  elementName       String  elementDescription String?        @db.Text    // Type  elementType       WBSElementType    // Work details  workPackage       String?         @db.Text // Detailed work description  acceptanceCriteria String?        @db.Text    // Assignment  assignedToUserId  String?  assignedToUser    User?           @relation(fields: [assignedToUserId], references: [id], onDelete: SetNull)    assignedToTeamId  String?  assignedToTeam    Team?           @relation(fields: [assignedToTeamId], references: [id], onDelete: SetNull)    // Timeline  startDate         DateTime?  endDate           DateTime?  duration          Int?            // in days    actualStartDate   DateTime?  actualEndDate     DateTime?  actualDuration    Int?    // Progress  progressPercentage Float?         @default(0)  status            TaskStatus      @default(NOT_STARTED)    // Effort (Person-days)  estimatedEffort   Float?          // Person-days  actualEffort      Float?  remainingEffort   Float?    // Budget  budgetAllocated   Float?  budgetSpent       Float?          @default(0)    // Weighting (for calculating project progress)  weightPercentage  Float?          @default(0) // % of parent or project    // Gantt chart data  isMilestone       Boolean         @default(false)  isOnCriticalPath  Boolean         @default(false)  slack             Int?            @default(0) // Slack time in days    // Metadata  level             Int             @default(1) // Depth in WBS tree  displayOrder      Int             @default(0)    tags              String[]  metadata          Json?    // Timestamps  createdAt         DateTime        @default(now())  updatedAt         DateTime        @updatedAt    // Relations  dependencies      Dependency[]    @relation("PredecessorTask")  dependents        Dependency[]    @relation("SuccessorTask")  timeLogs          TimeLog[]    @@unique([projectId, wbsCode])  @@index([projectId])  @@index([parentWBSId])  @@index([assignedToUserId])  @@index([status])  @@map("wbs_elements")}// Add to User model:// assignedWBS WBSElement[]// Add to Team model:// assignedWBS WBSElement[]// ============================================================================// SECTION 17: DEPENDENCIES (for Gantt Chart)// ============================================================================enum DependencyType {  FS                // Finish-to-Start (à¸—à¸±à¹ˆà¸§à¹„à¸›)  SS                // Start-to-Start  FF                // Finish-to-Finish  SF                // Start-to-Finish (à¸«à¸²à¸¢à¸²à¸)}model Dependency {  id                String          @id @default(cuid())    predecessorWBSId  String  predecessorWBS    WBSElement      @relation("PredecessorTask", fields: [predecessorWBSId], references: [id], onDelete: Cascade)    successorWBSId    String  successorWBS      WBSElement      @relation("SuccessorTask", fields: [successorWBSId], references: [id], onDelete: Cascade)    // Dependency type  dependencyType    DependencyType  @default(FS)    // Lag/Lead time  lagDays           Int             @default(0) // Positive = lag, Negative = lead    // Critical path indicator  isOnCriticalPath  Boolean         @default(false)    // Metadata  notes             String?         @db.Text    createdAt         DateTime        @default(now())  updatedAt         DateTime        @updatedAt    @@unique([predecessorWBSId, successorWBSId])  @@index([predecessorWBSId])  @@index([successorWBSId])  @@map("dependencies")}// ============================================================================// SECTION 18: MILESTONES// ============================================================================enum MilestoneStatus {  UPCOMING  DUE_SOON          // à¹ƒà¸à¸¥à¹‰à¸–à¸¶à¸‡à¸à¸³à¸«à¸™à¸”  ACHIEVED          // à¸šà¸£à¸£à¸¥à¸¸à¹à¸¥à¹‰à¸§  MISSED            // à¸à¸¥à¸²à¸”  CANCELLED}model Milestone {  id                String          @id @default(cuid())  projectId         String  project           Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)    // Details  milestoneCode     String          // "M1", "M2"  milestoneName     String  milestoneDescription String?      @db.Text    // Criteria  successCriteria   String?         @db.Text  deliverables      Json?           // Array of deliverables    // Timeline  targetDate        DateTime  actualDate        DateTime?    // Status  status            MilestoneStatus @default(UPCOMING)    // Importance  importanceLevel   Int             @default(3) // 1-5 scale  isCritical        Boolean         @default(false)    // Verification  verifiedBy        String?  verifiedAt        DateTime?  verificationNotes String?         @db.Text    // Metadata  tags              String[]    createdAt         DateTime        @default(now())  updatedAt         DateTime        @updatedAt    @@unique([projectId, milestoneCode])  @@index([projectId])  @@index([status])  @@index([targetDate])  @@map("milestones")}// ============================================================================// SECTION 19: PROJECT RISKS// ============================================================================enum RiskCategory {  TECHNICAL         // à¹€à¸—à¸„à¸™à¸´à¸„  SCHEDULE          // à¸à¸³à¸«à¸™à¸”à¹€à¸§à¸¥à¸²  BUDGET            // à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“  RESOURCE          // à¸—à¸£à¸±à¸à¸¢à¸²à¸à¸£  SCOPE             // à¸‚à¸­à¸šà¹€à¸‚à¸•  QUALITY           // à¸„à¸¸à¸“à¸ à¸²à¸  EXTERNAL          // à¸›à¸±à¸ˆà¸ˆà¸±à¸¢à¸ à¸²à¸¢à¸™à¸­à¸  ORGANIZATIONAL    // à¸­à¸‡à¸„à¹Œà¸à¸£  STAKEHOLDER       // à¸œà¸¹à¹‰à¸¡à¸µà¸ªà¹ˆà¸§à¸™à¹„à¸”à¹‰à¸ªà¹ˆà¸§à¸™à¹€à¸ªà¸µà¸¢}enum RiskStatus {  IDENTIFIED        // à¸£à¸°à¸šà¸¸à¹à¸¥à¹‰à¸§  ANALYSED          // à¸§à¸´à¹€à¸„à¸£à¸²à¸°à¸«à¹Œà¹à¸¥à¹‰à¸§  PLANNED           // à¸§à¸²à¸‡à¹à¸œà¸™à¹à¸¥à¹‰à¸§  MONITORING        // à¸à¸³à¸¥à¸±à¸‡à¸•à¸´à¸”à¸•à¸²à¸¡  OCCURRED          // à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¹à¸¥à¹‰à¸§  MITIGATED         // à¸ˆà¸±à¸”à¸à¸²à¸£à¹à¸¥à¹‰à¸§  CLOSED            // à¸›à¸´à¸”}model ProjectRisk {  id                String          @id @default(cuid())  projectId         String  project           Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)    // Identification  riskCode          String          // "R001", "R002"  riskTitle         String  riskDescription   String          @db.Text    // Classification  riskCategory      RiskCategory    // Probability (0-1 scale or 1-5)  probability       Float           // 0.1 = 10%, 0.5 = 50%, etc.  probabilityLevel  Int             // 1-5 for display    // Impact (0-10 scale or 1-5)  impact            Float           // 0-10  impactLevel       Int             // 1-5 for display    // Risk Score = Probability Ã— Impact  riskScore         Float           // Calculated  riskLevel         RiskLevel       // Calculated from score    // Proximity (when might it occur?)  proximity         String?         // "Within 1 month", "Q2 2024"  proximityDate     DateTime?    // Response strategy  responseStrategy  RiskResponse?    // Mitigation  mitigationPlan    String?         @db.Text  mitigationActions Json?           // Array of actions  mitigationCost    Float?    // Contingency  contingencyPlan   String?         @db.Text  contingencyBudget Float?    // Owner  ownerId           String?  owner             User?           @relation(fields: [ownerId], references: [id], onDelete: SetNull)    // Status  status            RiskStatus      @default(IDENTIFIED)    // Outcome (if risk occurred)  didOccur          Boolean         @default(false)  occurredAt        DateTime?  actualImpact      String?         @db.Text    // Metadata  tags              String[]    createdAt         DateTime        @default(now())  updatedAt         DateTime        @updatedAt    @@unique([projectId, riskCode])  @@index([projectId])  @@index([status])  @@index([riskLevel])  @@map("project_risks")}// Add to User model:// ownedRisks ProjectRisk[]enum RiskResponse {  AVOID             // à¸«à¸¥à¸µà¸à¹€à¸¥à¸µà¹ˆà¸¢à¸‡  MITIGATE          // à¸¥à¸”à¸œà¸¥à¸à¸£à¸°à¸—à¸š  TRANSFER          // à¹‚à¸­à¸™à¸–à¹ˆà¸²à¸¢  ACCEPT            // à¸¢à¸­à¸¡à¸£à¸±à¸š  EXPLOIT           // à¹ƒà¸Šà¹‰à¸›à¸£à¸°à¹‚à¸¢à¸Šà¸™à¹Œ (à¸ªà¸³à¸«à¸£à¸±à¸šà¹‚à¸­à¸à¸²à¸ª)  SHARE             // à¹à¸šà¹ˆà¸‡à¸›à¸±à¸™  ENHANCE           // à¹€à¸à¸´à¹ˆà¸¡à¸à¸¹à¸™ (à¸ªà¸³à¸«à¸£à¸±à¸šà¹‚à¸­à¸à¸²à¸ª)}// ============================================================================// SECTION 20: PROJECT ISSUES// ============================================================================enum IssueSeverity {  BLOCKER           // à¸—à¸³à¹ƒà¸«à¹‰à¸«à¸¢à¸¸à¸”à¸‡à¸²à¸™  CRITICAL          // à¸£à¹‰à¸²à¸¢à¹à¸£à¸‡  MAJOR             // à¸ªà¸³à¸„à¸±à¸  MINOR             // à¹€à¸¥à¹‡à¸à¸™à¹‰à¸­à¸¢  TRIVIAL           // à¹„à¸¡à¹ˆà¸ªà¸³à¸„à¸±à¸}enum IssueStatus {  OPEN  IN_PROGRESS  RESOLVED  CLOSED  REOPENED}model ProjectIssue {  id                String          @id @default(cuid())  projectId         String  project           Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)    // Identification  issueCode         String          // "ISS-001"  issueTitle        String  issueDescription  String          @db.Text    // Classification  issueType         String?         // "Bug", "Task", "Enhancement"  severity          IssueSeverity    // Impact  impactDescription String?         @db.Text  affectedWBS       String[]        // Array of WBS IDs    // Resolution  resolutionPlan    String?         @db.Text  resolutionNotes   String?         @db.Text    // Assignment  reportedBy        String?  reporter          User?           @relation("IssueReporter", fields: [reportedBy], references: [id], onDelete: SetNull)    assignedTo        String?  assignee          User?           @relation("IssueAssignee", fields: [assignedTo], references: [id], onDelete: SetNull)    // Status  status            IssueStatus     @default(OPEN)    // Dates  raisedAt          DateTime        @default(now())  targetResolutionDate DateTime?  resolvedAt        DateTime?  closedAt          DateTime?    createdAt         DateTime        @default(now())  updatedAt         DateTime        @updatedAt    @@unique([projectId, issueCode])  @@index([projectId])  @@index([status])  @@index([severity])  @@map("project_issues")}// Add to User model:// reportedIssues ProjectIssue[] @relation("IssueReporter")// assignedIssues ProjectIssue[] @relation("IssueAssignee")// ============================================================================// SECTION 21: PROJECT CHANGES (Change Requests)// ============================================================================enum ChangeType {  SCOPE  SCHEDULE  BUDGET  RESOURCE  QUALITY  OTHER}enum ChangeRequestStatus {  SUBMITTED  UNDER_REVIEW  APPROVED  REJECTED  IMPLEMENTED  CANCELLED}model ProjectChange {  id                String              @id @default(cuid())  projectId         String  project           Project             @relation(fields: [projectId], references: [id], onDelete: Cascade)    // Identification  changeRequestCode String              // "CR-001"  changeTitle       String  changeDescription String              @db.Text    // Type  changeType        ChangeType    // Justification  justification     String              @db.Text  businessCase      String?             @db.Text    // Impact analysis  scopeImpact       String?             @db.Text  scheduleImpact    Int?                // Days  budgetImpact      Float?              // Cost  resourceImpact    String?             @db.Text  qualityImpact     String?             @db.Text  riskImpact        String?             @db.Text    // Priority  priority          ProjectPriority     @default(MEDIUM)  urgency           Int                 @default(3) // 1-5    // Submission  submittedBy       String  submitter         User                @relation("ChangeSubmitter", fields: [submittedBy], references: [id], onDelete: Cascade)  submittedAt       DateTime            @default(now())    // Review  reviewedBy        String?  reviewer          User?               @relation("ChangeReviewer", fields: [reviewedBy], references: [id], onDelete: SetNull)  reviewedAt        DateTime?  reviewNotes       String?             @db.Text    // Approval  approvedBy        String?  approver          User?               @relation("ChangeApprover", fields: [approvedBy], references: [id], onDelete: SetNull)  approvedAt        DateTime?  approvalNotes     String?             @db.Text    // Status  status            ChangeRequestStatus @default(SUBMITTED)    // Implementation  implementedAt     DateTime?  implementationNotes String?           @db.Text    createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt    @@unique([projectId, changeRequestCode])  @@index([projectId])  @@index([status])  @@map("project_changes")}// Add to User model:// submittedChanges ProjectChange[] @relation("ChangeSubmitter")// reviewedChanges ProjectChange[] @relation("ChangeReviewer")// approvedChanges ProjectChange[] @relation("ChangeApprover")// ============================================================================// SECTION 22: TIME TRACKING// ============================================================================model TimeLog {  id                String          @id @default(cuid())    wbsElementId      String?  wbsElement        WBSElement?     @relation(fields: [wbsElementId], references: [id], onDelete: SetNull)    userId            String  user              User            @relation(fields: [userId], references: [id], onDelete: Cascade)    // Time details  logDate           DateTime  hoursSpent        Float           // Hours (can be decimal: 2.5 = 2h 30m)    // Description  workDescription   String?         @db.Text    // Billing  isBillable        Boolean         @default(true)  billingRate       Float?          // Rate per hour  billingAmount     Float?          // hoursSpent Ã— billingRate    // Status  isApproved        Boolean         @default(false)  approvedBy        String?  approvedAt        DateTime?    createdAt         DateTime        @default(now())  updatedAt         DateTime        @updatedAt    @@index([wbsElementId])  @@index([userId])  @@index([logDate])  @@map("time_logs")}// Add to User model:// timeLogs TimeLog[]// ============================================================================// SECTION 23: PROJECT DOCUMENTS// ============================================================================enum DocumentType {  PROJECT_CHARTER  PROJECT_PLAN  SCHEDULE  BUDGET  RISK_REGISTER  ISSUE_LOG  CHANGE_LOG  STATUS_REPORT  MEETING_MINUTES  TECHNICAL_SPEC  REQUIREMENT_DOC  TEST_PLAN  DELIVERABLE  PRESENTATION  CONTRACT  OTHER}model ProjectDocument {  id                String          @id @default(cuid())  projectId         String  project           Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)    // Document details  documentName      String  documentType      DocumentType  description       String?         @db.Text    // File  fileName          String  fileSize          Int             // bytes  mimeType          String  fileUrl           String          // Storage URL (S3, etc.)    // Version  version           String          @default("1.0")  versionNotes      String?         @db.Text    // Access  isPublic          Boolean         @default(false)  accessLevel       String?         // "team", "stakeholders", "public"    // Upload  uploadedBy        String  uploader          User            @relation(fields: [uploadedBy], references: [id], onDelete: Cascade)  uploadedAt        DateTime        @default(now())    // Metadata  tags              String[]  metadata          Json?    updatedAt         DateTime        @updatedAt    @@index([projectId])  @@index([documentType])  @@map("project_documents")}// Add to User model:// uploadedDocuments ProjectDocument[]// ============================================================================// SECTION 24: PROJECT STATUS REPORTS// ============================================================================model ProjectStatusReport {  id                String          @id @default(cuid())  projectId         String  project           Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)    // Report period  reportDate        DateTime  reportPeriodStart DateTime  reportPeriodEnd   DateTime    // Overall status  overallStatus     HealthStatus  scheduleStatus    HealthStatus  budgetStatus      HealthStatus  scopeStatus       HealthStatus    // Progress  completionPercent Float    // Executive summary  executiveSummary  String          @db.Text    // Accomplishments  accomplishments   Json?           // Array of accomplishments    // Issues & risks  keyIssues         Json?           // Array of key issues  keyRisks          Json?           // Array of key risks    // Next period plans  nextSteps         Json?           // Array of planned activities    // Budget  budgetSpent       Float?  budgetRemaining   Float?  budgetForecast    Float?    // Metrics  metricsData       Json?           // Custom metrics    // Author  reportedBy        String  reporter          User            @relation(fields: [reportedBy], references: [id], onDelete: Cascade)    createdAt         DateTime        @default(now())  updatedAt         DateTime        @updatedAt    @@index([projectId, reportDate])  @@map("project_status_reports")}// Add to User model:// statusReports ProjectStatusReport[]// ============================================================================// SECTION 25: ACTIVITY-BASED COSTING (ABC)// ============================================================================enum ActivityCategory {  VALUE_ADDED       // à¹€à¸à¸´à¹ˆà¸¡à¸¡à¸¹à¸¥à¸„à¹ˆà¸²  NON_VALUE_ADDED   // à¹„à¸¡à¹ˆà¹€à¸à¸´à¹ˆà¸¡à¸¡à¸¹à¸¥à¸„à¹ˆà¸²  SUPPORT           // à¸ªà¸™à¸±à¸šà¸ªà¸™à¸¸à¸™}model ActivityPool {  id                String            @id @default(cuid())  organizationId    String    // Activity details  activityCode      String  activityName      String  activityDescription String?        @db.Text    // Classification  activityCategory  ActivityCategory    // Cost  totalCost         Float             @default(0)    // Period  fiscalYear        Int  fiscalQuarter     Int?    // Metadata  tags              String[]    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt    costDrivers       CostDriver[]    @@unique([organizationId, activityCode, fiscalYear])  @@index([organizationId])  @@map("activity_pools")}model CostDriver {  id                String          @id @default(cuid())  activityPoolId    String  activityPool      ActivityPool    @relation(fields: [activityPoolId], references: [id], onDelete: Cascade)    // Driver details  driverName        String  driverUnit        String          // "hours", "transactions", "sq.meters"    // Quantity  totalQuantity     Float           // Total driver quantity    // Cost per unit (calculated)  costPerUnit       Float?          // totalCost / totalQuantity    createdAt         DateTime        @default(now())  updatedAt         DateTime        @updatedAt    allocations       CostAllocation[]    @@unique([activityPoolId, driverName])  @@index([activityPoolId])  @@map("cost_drivers")}model CostAllocation {  id                String          @id @default(cuid())    activityPoolId    String  costDriverId      String  costDriver        CostDriver      @relation(fields: [costDriverId], references: [id], onDelete: Cascade)    projectId         String?  wbsId             String?    // Quantity used  driverQuantityUsed Float    // Allocated cost (calculated)  allocatedCost     Float?          // driverQuantityUsed Ã— costPerUnit    // Allocation date  allocationDate    DateTime        @default(now())    createdAt         DateTime        @default(now())  updatedAt         DateTime        @updatedAt    @@index([activityPoolId])  @@index([projectId])  @@map("cost_allocations")}model OverheadCost {  id                String          @id @default(cuid())  organizationId    String    // Cost classification  costCategory      String          // "Admin", "Facilities", "Utilities", "IT"  costDescription   String?    // Amount  costAmount        Float    // Allocation basis  allocationBasis   String?         @db.Text // How to allocate    // Period  fiscalYear        Int  fiscalQuarter     Int?    createdAt         DateTime        @default(now())  updatedAt         DateTime        @updatedAt    @@index([organizationId])  @@index([fiscalYear, fiscalQuarter])  @@map("overhead_costs")}```---ğŸŒ± Step 2: Seed Data for Projects```typescript// prisma/seed-projects.tsimport { PrismaClient, ProjectType, ProjectPriority, WBSElementType, DependencyType } from '@prisma/client'const prisma = new PrismaClient()async function seedProjects() {  console.log('ğŸ—ï¸ Seeding Projects...')  // Get NIEMS organization  const niems = await prisma.organization.findUnique({    where: { code: 'NIEMS' },  })  if (!niems) throw new Error('NIEMS not found')  // Get users  const admin = await prisma.user.findUnique({ where: { email: 'admin@niems.go.th' } })  const planner = await prisma.user.findUnique({ where: { email: 'planner@niems.go.th' } })  // Get strategies for linking  const strategies = await prisma.tOWSStrategy.findMany({    where: { organizationId: niems.id },    take: 2,  })  // Get objectives for linking  const objectives = await prisma.strategicObjective.findMany({    where: { organizationId: niems.id },    take: 2,  })  // =========================================================================  // 1. Create Projects  // =========================================================================  const project1 = await prisma.project.create({    data: {      organizationId: niems.id,      projectCode: 'PRJ-2024-001',      projectName: 'à¸à¸±à¸’à¸™à¸²à¸£à¸°à¸šà¸š EMS à¸”à¹‰à¸§à¸¢ AI à¹à¸¥à¸° IoT',      projectDescription: `à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¸à¸±à¸’à¸™à¸²à¸£à¸°à¸šà¸šà¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œà¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸”à¹‰à¸§à¸¢à¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µ AI à¹à¸¥à¸° IoT à¹€à¸à¸·à¹ˆà¸­à¸¢à¸à¸£à¸°à¸”à¸±à¸šà¸à¸²à¸£à¹ƒà¸«à¹‰à¸šà¸£à¸´à¸à¸²à¸£à¸¥à¸”à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡ à¹à¸¥à¸°à¹€à¸à¸´à¹ˆà¸¡à¸„à¸§à¸²à¸¡à¹à¸¡à¹ˆà¸™à¸¢à¸³à¹ƒà¸™à¸à¸²à¸£à¸§à¸´à¸™à¸´à¸ˆà¸‰à¸±à¸¢à¹€à¸šà¸·à¹‰à¸­à¸‡à¸•à¹‰à¸™à¸§à¸±à¸•à¸–à¸¸à¸›à¸£à¸°à¸ªà¸‡à¸„à¹Œ:1. à¸à¸±à¸’à¸™à¸² AI Triage System à¸ªà¸³à¸«à¸£à¸±à¸šà¸„à¸±à¸”à¸à¸£à¸­à¸‡à¸œà¸¹à¹‰à¸›à¹ˆà¸§à¸¢à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™2. à¸•à¸´à¸”à¸•à¸±à¹‰à¸‡ IoT Sensors à¹ƒà¸™à¸£à¸–à¸à¸¢à¸²à¸šà¸²à¸¥à¹à¸¥à¸°à¸«à¹‰à¸­à¸‡à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™3. à¸ªà¸£à¹‰à¸²à¸‡ Real-time Dashboard à¸ªà¸³à¸«à¸£à¸±à¸šà¸à¸²à¸£à¸•à¸´à¸”à¸•à¸²à¸¡à¹à¸¥à¸°à¸ˆà¸±à¸”à¸à¸²à¸£4. à¸à¸¶à¸à¸­à¸šà¸£à¸¡à¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¹ƒà¸™à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸£à¸°à¸šà¸šà¹ƒà¸«à¸¡à¹ˆ      `,      projectType: ProjectType.STRATEGIC,      priority: ProjectPriority.CRITICAL,      linkedStrategyIds: [strategies[0].id],      linkedObjectiveIds: [objectives[0].id, objectives[1].id],      projectManagerId: planner!.id,      sponsorId: admin!.id,      plannedStartDate: new Date('2024-01-01'),      plannedEndDate: new Date('2024-12-31'),      actualStartDate: new Date('2024-01-15'),      durationDays: 365,      totalBudget: 50000000,      budgetSpent: 15000000,      budgetRemaining: 35000000,      completionPercentage: 35,      scheduleHealth: 'HEALTHY',      budgetHealth: 'HEALTHY',      scopeHealth: 'HEALTHY',      overallHealth: 'HEALTHY',      riskLevel: 'MEDIUM',      status: 'ACTIVE',      approvedAt: new Date('2023-12-15'),      approvedBy: admin!.id,      createdById: planner!.id,    },  })  console.log('âœ… Created project:', project1.projectCode)  const project2 = await prisma.project.create({    data: {      organizationId: niems.id,      projectCode: 'PRJ-2024-002',      projectName: 'à¸‚à¸¢à¸²à¸¢à¹€à¸„à¸£à¸·à¸­à¸‚à¹ˆà¸²à¸¢à¸šà¸£à¸´à¸à¸²à¸£à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸à¸·à¹‰à¸™à¸—à¸µà¹ˆà¸«à¹ˆà¸²à¸‡à¹„à¸à¸¥',      projectDescription: `à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¸‚à¸¢à¸²à¸¢à¸à¸²à¸£à¹ƒà¸«à¹‰à¸šà¸£à¸´à¸à¸²à¸£à¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œà¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¹„à¸›à¸¢à¸±à¸‡à¸à¸·à¹‰à¸™à¸—à¸µà¹ˆà¸«à¹ˆà¸²à¸‡à¹„à¸à¸¥à¹€à¸à¸·à¹ˆà¸­à¸¥à¸”à¸„à¸§à¸²à¸¡à¹€à¸«à¸¥à¸·à¹ˆà¸­à¸¡à¸¥à¹‰à¸³à¹ƒà¸™à¸à¸²à¸£à¹€à¸‚à¹‰à¸²à¸–à¸¶à¸‡à¸šà¸£à¸´à¸à¸²à¸£à¸ªà¸¸à¸‚à¸ à¸²à¸à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢:- à¸„à¸£à¸­à¸šà¸„à¸¥à¸¸à¸¡ 20 à¸­à¸³à¹€à¸ à¸­à¸«à¹ˆà¸²à¸‡à¹„à¸à¸¥- à¸¥à¸”à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¹€à¸‰à¸¥à¸µà¹ˆà¸¢à¹€à¸«à¸¥à¸·à¸­ 30 à¸™à¸²à¸—à¸µ- à¹€à¸à¸´à¹ˆà¸¡à¸ˆà¸¸à¸”à¸šà¸£à¸´à¸à¸²à¸£ EMS 50 à¸ˆà¸¸à¸”      `,      projectType: ProjectType.STRATEGIC,      priority: ProjectPriority.HIGH,      linkedStrategyIds: [strategies[1].id],      linkedObjectiveIds: [objectives[1].id],      projectManagerId: planner!.id,      sponsorId: admin!.id,      plannedStartDate: new Date('2024-04-01'),      plannedEndDate: new Date('2025-03-31'),      durationDays: 365,      totalBudget: 30000000,      budgetSpent: 5000000,      budgetRemaining: 25000000,      completionPercentage: 15,      scheduleHealth: 'HEALTHY',      budgetHealth: 'HEALTHY',      scopeHealth: 'AT_RISK',      overallHealth: 'AT_RISK',      riskLevel: 'HIGH',      status: 'ACTIVE',      approvedAt: new Date('2024-03-15'),      approvedBy: admin!.id,      createdById: planner!.id,    },  })  console.log('âœ… Created project:', project2.projectCode)  // =========================================================================  // 2. Create WBS for Project 1  // =========================================================================  // Phase 1: Initiation  const phase1 = await prisma.wBSElement.create({    data: {      projectId: project1.id,      wbsCode: '1',      elementName: 'Phase 1: Initiation',      elementType: WBSElementType.PHASE,      startDate: new Date('2024-01-15'),      endDate: new Date('2024-02-28'),      duration: 45,      progressPercentage: 100,      status: 'COMPLETED',      weightPercentage: 10,      level: 1,      displayOrder: 1,    },  })  await prisma.wBSElement.create({    data: {      projectId: project1.id,      parentWBSId: phase1.id,      wbsCode: '1.1',      elementName: 'Project Charter',      elementType: WBSElementType.DELIVERABLE,      startDate: new Date('2024-01-15'),      endDate: new Date('2024-01-31'),      duration: 15,      progressPercentage: 100,      status: 'COMPLETED',      assignedToUserId: planner!.id,      estimatedEffort: 5,      actualEffort: 6,      budgetAllocated: 100000,      budgetSpent: 120000,      weightPercentage: 30,      level: 2,    },  })  await prisma.wBSElement.create({    data: {      projectId: project1.id,      parentWBSId: phase1.id,      wbsCode: '1.2',      elementName: 'Stakeholder Analysis',      elementType: WBSElementType.DELIVERABLE,      startDate: new Date('2024-02-01'),      endDate: new Date('2024-02-15'),      duration: 15,      progressPercentage: 100,      status: 'COMPLETED',      estimatedEffort: 3,      actualEffort: 4,      budgetAllocated: 80000,      budgetSpent: 90000,      weightPercentage: 20,      level: 2,    },  })  // Phase 2: Planning  const phase2 = await prisma.wBSElement.create({    data: {      projectId: project1.id,      wbsCode: '2',      elementName: 'Phase 2: Planning',      elementType: WBSElementType.PHASE,      startDate: new Date('2024-03-01'),      endDate: new Date('2024-04-30'),      duration: 60,      progressPercentage: 80,      status: 'IN_PROGRESS',      weightPercentage: 15,      level: 1,      displayOrder: 2,    },  })  const task21 = await prisma.wBSElement.create({    data: {      projectId: project1.id,      parentWBSId: phase2.id,      wbsCode: '2.1',      elementName: 'Technical Architecture Design',      elementType: WBSElementType.ACTIVITY,      startDate: new Date('2024-03-01'),      endDate: new Date('2024-03-31'),      duration: 30,      progressPercentage: 100,      status: 'COMPLETED',      assignedToUserId: planner!.id,      estimatedEffort: 10,      actualEffort: 12,      budgetAllocated: 500000,      budgetSpent: 550000,      weightPercentage: 40,      level: 2,    },  })  const task22 = await prisma.wBSElement.create({    data: {      projectId: project1.id,      parentWBSId: phase2.id,      wbsCode: '2.2',      elementName: 'Procurement Planning',      elementType: WBSElementType.ACTIVITY,      startDate: new Date('2024-04-01'),      endDate: new Date('2024-04-30'),      duration: 30,      progressPercentage: 60,      status: 'IN_PROGRESS',      estimatedEffort: 8,      budgetAllocated: 400000,      budgetSpent: 200000,      weightPercentage: 30,      level: 2,    },  })  // Phase 3: Execution  const phase3 = await prisma.wBSElement.create({    data: {      projectId: project1.id,      wbsCode: '3',      elementName: 'Phase 3: Execution',      elementType: WBSElementType.PHASE,      startDate: new Date('2024-05-01'),      endDate: new Date('2024-10-31'),      duration: 180,      progressPercentage: 20,      status: 'NOT_STARTED',      weightPercentage: 50,      level: 1,      displayOrder: 3,    },  })  const task31 = await prisma.wBSElement.create({    data: {      projectId: project1.id,      parentWBSId: phase3.id,      wbsCode: '3.1',      elementName: 'AI System Development',      elementType: WBSElementType.ACTIVITY,      startDate: new Date('2024-05-01'),      endDate: new Date('2024-08-31'),      duration: 120,      progressPercentage: 0,      status: 'NOT_STARTED',      estimatedEffort: 60,      budgetAllocated: 15000000,      weightPercentage: 50,      level: 2,      isOnCriticalPath: true,    },  })  const task32 = await prisma.wBSElement.create({    data: {      projectId: project1.id,      parentWBSId: phase3.id,      wbsCode: '3.2',      elementName: 'IoT Infrastructure Setup',      elementType: WBSElementType.ACTIVITY,      startDate: new Date('2024-06-01'),      endDate: new Date('2024-09-30'),      duration: 120,      progressPercentage: 0,      status: 'NOT_STARTED',      estimatedEffort: 40,      budgetAllocated: 10000000,      weightPercentage: 30,      level: 2,      isOnCriticalPath: true,    },  })  // Phase 4: Closure  const phase4 = await prisma.wBSElement.create({    data: {      projectId: project1.id,      wbsCode: '4',      elementName: 'Phase 4: Closure',      elementType: WBSElementType.PHASE,      startDate: new Date('2024-11-01'),      endDate: new Date('2024-12-31'),      duration: 60,      progressPercentage: 0,      status: 'NOT_STARTED',      weightPercentage: 10,      level: 1,      displayOrder: 4,    },  })  console.log('âœ… Created WBS elements')  // =========================================================================  // 3. Create Dependencies (Gantt Chart)  // =========================================================================  // Phase 1 â†’ Phase 2 (FS)  await prisma.dependency.create({    data: {      predecessorWBSId: phase1.id,      successorWBSId: phase2.id,      dependencyType: DependencyType.FS,      lagDays: 0,    },  })  // Task 2.1 â†’ Task 2.2 (FS)  await prisma.dependency.create({    data: {      predecessorWBSId: task21.id,      successorWBSId: task22.id,      dependencyType: DependencyType.FS,      lagDays: 0,      isOnCriticalPath: true,    },  })  // Phase 2 â†’ Phase 3 (FS)  await prisma.dependency.create({    data: {      predecessorWBSId: phase2.id,      successorWBSId: phase3.id,      dependencyType: DependencyType.FS,      lagDays: 0,      isOnCriticalPath: true,    },  })  // Task 3.1 â†’ Task 3.2 (SS with lag)  await prisma.dependency.create({    data: {      predecessorWBSId: task31.id,      successorWBSId: task32.id,      dependencyType: DependencyType.SS,      lagDays: 30, // Start 3.2 thirty days after 3.1 starts    },  })  // Phase 3 â†’ Phase 4 (FS)  await prisma.dependency.create({    data: {      predecessorWBSId: phase3.id,      successorWBSId: phase4.id,      dependencyType: DependencyType.FS,      lagDays: 0,    },  })  console.log('âœ… Created dependencies')  // =========================================================================  // 4. Create Milestones  // =========================================================================  await prisma.milestone.create({    data: {      projectId: project1.id,      milestoneCode: 'M1',      milestoneName: 'Project Kickoff',      milestoneDescription: 'à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸­à¸¢à¹ˆà¸²à¸‡à¹€à¸›à¹‡à¸™à¸—à¸²à¸‡à¸à¸²à¸£',      targetDate: new Date('2024-01-15'),      actualDate: new Date('2024-01-15'),      status: 'ACHIEVED',      importanceLevel: 4,      isCritical: true,      verifiedBy: admin!.id,      verifiedAt: new Date('2024-01-15'),    },  })  await prisma.milestone.create({    data: {      projectId: project1.id,      milestoneCode: 'M2',      milestoneName: 'Design Complete',      milestoneDescription: 'à¸à¸²à¸£à¸­à¸­à¸à¹à¸šà¸šà¸£à¸°à¸šà¸šà¹€à¸ªà¸£à¹‡à¸ˆà¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œ',      targetDate: new Date('2024-04-30'),      status: 'DUE_SOON',      importanceLevel: 5,      isCritical: true,    },  })  await prisma.milestone.create({    data: {      projectId: project1.id,      milestoneCode: 'M3',      milestoneName: 'System Go-Live',      milestoneDescription: 'à¸£à¸°à¸šà¸šà¹€à¸£à¸´à¹ˆà¸¡à¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¸ˆà¸£à¸´à¸‡',      targetDate: new Date('2024-11-01'),      status: 'UPCOMING',      importanceLevel: 5,      isCritical: true,    },  })  await prisma.milestone.create({    data: {      projectId: project1.id,      milestoneCode: 'M4',      milestoneName: 'Project Closure',      milestoneDescription: 'à¸›à¸´à¸”à¹‚à¸„à¸£à¸‡à¸à¸²à¸£',      targetDate: new Date('2024-12-31'),      status: 'UPCOMING',      importanceLevel: 4,    },  })  console.log('âœ… Created milestones')  // =========================================================================  // 5. Create Risks  // =========================================================================  await prisma.projectRisk.create({    data: {      projectId: project1.id,      riskCode: 'R001',      riskTitle: 'AI Model Accuracy Below Target',      riskDescription: 'à¹‚à¸¡à¹€à¸”à¸¥ AI à¸­à¸²à¸ˆà¸¡à¸µà¸„à¸§à¸²à¸¡à¹à¸¡à¹ˆà¸™à¸¢à¸³à¸•à¹ˆà¸³à¸à¸§à¹ˆà¸²à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢ 95%',      riskCategory: 'TECHNICAL',      probability: 0.3,      probabilityLevel: 2,      impact: 8,      impactLevel: 4,      riskScore: 2.4, // 0.3 Ã— 8      riskLevel: 'HIGH',      proximity: 'Q3 2024',      responseStrategy: 'MITIGATE',      mitigationPlan: `1. à¸ˆà¹‰à¸²à¸‡à¸—à¸µà¹ˆà¸›à¸£à¸¶à¸à¸©à¸²à¸œà¸¹à¹‰à¹€à¸Šà¸µà¹ˆà¸¢à¸§à¸Šà¸²à¸à¸”à¹‰à¸²à¸™ Medical AI2. à¹€à¸à¸´à¹ˆà¸¡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸ªà¸³à¸«à¸£à¸±à¸š Training3. à¸—à¸³ A/B Testing à¸à¸±à¸šà¸«à¸¥à¸²à¸¢ Model4. à¸¡à¸µ Fallback à¹ƒà¸«à¹‰à¹ƒà¸Šà¹‰ Human Triage à¸„à¸§à¸šà¸„à¸¹à¹ˆ      `,      mitigationCost: 2000000,      ownerId: planner!.id,      status: 'MONITORING',    },  })  await prisma.projectRisk.create({    data: {      projectId: project1.id,      riskCode: 'R002',      riskTitle: 'Budget Overrun',      riskDescription: 'à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“à¸­à¸²à¸ˆà¹€à¸à¸´à¸™à¹€à¸™à¸·à¹ˆà¸­à¸‡à¸ˆà¸²à¸à¸£à¸²à¸„à¸² Hardware à¹€à¸à¸´à¹ˆà¸¡à¸‚à¸¶à¹‰à¸™',      riskCategory: 'BUDGET',      probability: 0.4,      probabilityLevel: 2,      impact: 6,      impactLevel: 3,      riskScore: 2.4,      riskLevel: 'HIGH',      responseStrategy: 'MITIGATE',      mitigationPlan: 'à¸‚à¸­à¸­à¸™à¸¸à¸¡à¸±à¸•à¸´à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“à¸ªà¸³à¸£à¸­à¸‡ 20%',      contingencyBudget: 10000000,      ownerId: admin!.id,      status: 'PLANNED',    },  })  console.log('âœ… Created risks')  // =========================================================================  // 6. Create Issues  // =========================================================================  await prisma.projectIssue.create({    data: {      projectId: project1.id,      issueCode: 'ISS-001',      issueTitle: 'Vendor Delay in IoT Sensor Delivery',      issueDescription: 'Vendor à¹à¸ˆà¹‰à¸‡à¸§à¹ˆà¸²à¸ˆà¸°à¸ªà¹ˆà¸‡ IoT Sensors à¸¥à¹ˆà¸²à¸Šà¹‰à¸² 2 à¸ªà¸±à¸›à¸”à¸²à¸«à¹Œ',      issueType: 'Blocker',      severity: 'MAJOR',      impactDescription: 'à¸­à¸²à¸ˆà¸—à¸³à¹ƒà¸«à¹‰ Phase 3 à¹€à¸£à¸´à¹ˆà¸¡à¸Šà¹‰à¸²à¸à¸§à¹ˆà¸²à¹à¸œà¸™',      reportedBy: planner!.id,      assignedTo: admin!.id,      status: 'IN_PROGRESS',      targetResolutionDate: new Date('2024-05-15'),    },  })  console.log('âœ… Created issues')  // =========================================================================  // 7. Create Status Report  // =========================================================================  await prisma.projectStatusReport.create({    data: {      projectId: project1.id,      reportDate: new Date('2024-04-15'),      reportPeriodStart: new Date('2024-04-01'),      reportPeriodEnd: new Date('2024-04-15'),      overallStatus: 'HEALTHY',      scheduleStatus: 'HEALTHY',      budgetStatus: 'HEALTHY',      scopeStatus: 'HEALTHY',      completionPercent: 35,      executiveSummary: `à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¸”à¸³à¹€à¸™à¸´à¸™à¸à¸²à¸£à¸•à¸²à¸¡à¹à¸œà¸™à¹ƒà¸™à¸ à¸²à¸à¸£à¸§à¸¡ Phase 1 à¹à¸¥à¸° 2.1 à¹€à¸ªà¸£à¹‡à¸ˆà¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œà¹à¸¥à¹‰à¸§à¸à¸³à¸¥à¸±à¸‡à¸”à¸³à¹€à¸™à¸´à¸™à¸à¸²à¸£ Phase 2.2 (Procurement Planning) à¸„à¸²à¸”à¸§à¹ˆà¸²à¸ˆà¸°à¹€à¸ªà¸£à¹‡à¸ˆà¸•à¸²à¸¡à¸à¸³à¸«à¸™à¸”à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“à¹ƒà¸Šà¹‰à¸ˆà¹ˆà¸²à¸¢ 15 à¸¥à¹‰à¸²à¸™à¸šà¸²à¸— à¸„à¸´à¸”à¹€à¸›à¹‡à¸™ 30% à¸‚à¸­à¸‡à¸‡à¸šà¸£à¸§à¸¡ à¸ªà¸­à¸”à¸„à¸¥à¹‰à¸­à¸‡à¸à¸±à¸šà¸„à¸§à¸²à¸¡à¸„à¸·à¸šà¸«à¸™à¹‰à¸²      `,      accomplishments: {        items: [          'à¹€à¸ªà¸£à¹‡à¸ˆà¸ªà¸´à¹‰à¸™ Technical Architecture Design',          'à¸­à¸™à¸¸à¸¡à¸±à¸•à¸´ Project Charter',          'à¸ˆà¸±à¸”à¸—à¸³à¹à¸œà¸™à¸ˆà¸±à¸”à¸‹à¸·à¹‰à¸­à¸ˆà¸±à¸”à¸ˆà¹‰à¸²à¸‡à¹€à¸ªà¸£à¹‡à¸ˆ 60%',        ],      },      keyIssues: {        items: [          {            issue: 'Vendor à¸ªà¹ˆà¸‡ IoT Sensors à¸¥à¹ˆà¸²à¸Šà¹‰à¸²',            impact: 'à¸›à¸²à¸™à¸à¸¥à¸²à¸‡',            action: 'à¸•à¸´à¸”à¸•à¹ˆà¸­à¸«à¸² Vendor à¸ªà¸³à¸£à¸­à¸‡',          },        ],      },      keyRisks: {        items: [          {            risk: 'AI Model Accuracy',            probability: 'à¸›à¸²à¸™à¸à¸¥à¸²à¸‡',            impact: 'à¸ªà¸¹à¸‡',            mitigation: 'à¸ˆà¹‰à¸²à¸‡à¸—à¸µà¹ˆà¸›à¸£à¸¶à¸à¸©à¸²',          },        ],      },      nextSteps: {        items: [          'à¹€à¸£à¸´à¹ˆà¸¡ Procurement Process à¸ à¸²à¸¢à¹ƒà¸™ 1 à¸ªà¸±à¸›à¸”à¸²à¸«à¹Œ',          'Finalize IoT Sensor Specifications',          'à¹€à¸•à¸£à¸µà¸¢à¸¡à¸—à¸µà¸¡ Development',        ],      },      budgetSpent: 15000000,      budgetRemaining: 35000000,      budgetForecast: 50000000,      reportedBy: planner!.id,    },  })  console.log('âœ… Created status report')  console.log('\nğŸ‰ Projects seed completed!')}seedProjects()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })```---ğŸ“¦ Step 3: Update package.json```json{  "scripts": {    "db:seed-projects": "tsx prisma/seed-projects.ts",    "db:seed-all": "pnpm db:seed && pnpm db:seed-rbac && pnpm db:seed-tows-bsc && pnpm db:seed-projects"  }}```---ğŸ” Step 4: Query Examples```typescript// lib/queries/project-queries.ts// 1. Get complete project with Gantt dataexport async function getProjectGanttData(projectId: string) {  const project = await prisma.project.findUnique({    where: { id: projectId },    include: {      wbsElements: {        include: {          dependencies: {            include: {              successorWBS: true,            },          },          dependents: {            include: {              predecessorWBS: true,            },          },          assignedToUser: {            select: {              id: true,              fullName: true,              avatar: true,            },          },        },        orderBy: { wbsCode: 'asc' },      },      milestones: {        orderBy: { targetDate: 'asc' },      },    },  })  // Format for Gantt chart library (e.g., dhtmlxGantt, Frappe Gantt)  const ganttTasks = project?.wbsElements.map((wbs) => ({    id: wbs.id,    text: wbs.elementName,    start_date: wbs.startDate,    end_date: wbs.endDate,    duration: wbs.duration,    progress: wbs.progressPercentage / 100,    parent: wbs.parentWBSId || '0',    type: wbs.isMilestone ? 'milestone' : 'task',    assignee: wbs.assignedToUser?.fullName,    is_critical: wbs.isOnCriticalPath,  }))  const ganttLinks = project?.wbsElements.flatMap((wbs) =>    wbs.dependencies.map((dep) => ({      id: dep.id,      source: wbs.id,      target: dep.successorWBSId,      type: dep.dependencyType.toLowerCase(),      lag: dep.lagDays,    }))  )  return {    project,    tasks: ganttTasks,    links: ganttLinks,    milestones: project?.milestones,  }}// 2. Calculate critical pathexport async function calculateCriticalPath(projectId: string) {  const wbsElements = await prisma.wBSElement.findMany({    where: { projectId },    include: {      dependencies: {        include: {          successorWBS: true,        },      },    },  })  // Implement CPM (Critical Path Method) algorithm  // This is a simplified version - real implementation would be more complex  const earlyStart: Record<string, number> = {}  const earlyFinish: Record<string, number> = {}  const lateStart: Record<string, number> = {}  const lateFinish: Record<string, number> = {}  const slack: Record<string, number> = {}  // Forward pass  for (const wbs of wbsElements) {    if (wbs.dependencies.length === 0) {      earlyStart[wbs.id] = 0    } else {      const maxPredecessorFinish = Math.max(        ...wbs.dependencies.map((dep) => earlyFinish[dep.predecessorWBSId] + dep.lagDays)      )      earlyStart[wbs.id] = maxPredecessorFinish    }    earlyFinish[wbs.id] = earlyStart[wbs.id] + (wbs.duration || 0)  }  // Project duration  const projectDuration = Math.max(...Object.values(earlyFinish))  // Backward pass  for (const wbs of [...wbsElements].reverse()) {    const successors = wbsElements.filter((w) =>      w.dependencies.some((d) => d.predecessorWBSId === wbs.id)    )    if (successors.length === 0) {      lateFinish[wbs.id] = projectDuration    } else {      const minSuccessorStart = Math.min(        ...successors.map((s) => {          const dep = s.dependencies.find((d) => d.predecessorWBSId === wbs.id)!          return lateStart[s.id] - dep.lagDays        })      )      lateFinish[wbs.id] = minSuccessorStart    }    lateStart[wbs.id] = lateFinish[wbs.id] - (wbs.duration || 0)    slack[wbs.id] = lateStart[wbs.id] - earlyStart[wbs.id]  }  // Critical path = tasks with zero slack  const criticalPath = wbsElements.filter((wbs) => slack[wbs.id] === 0)  // Update database  for (const wbs of wbsElements) {    await prisma.wBSElement.update({      where: { id: wbs.id },      data: {        isOnCriticalPath: slack[wbs.id] === 0,        slack: slack[wbs.id],      },    })  }  return {    projectDuration,    criticalPath: criticalPath.map((w) => w.wbsCode),    schedule: wbsElements.map((wbs) => ({      wbsCode: wbs.wbsCode,      name: wbs.elementName,      earlyStart: earlyStart[wbs.id],      earlyFinish: earlyFinish[wbs.id],      lateStart: lateStart[wbs.id],      lateFinish: lateFinish[wbs.id],      slack: slack[wbs.id],      isCritical: slack[wbs.id] === 0,    })),  }}// 3. Update project progress (roll-up from WBS)export async function updateProjectProgress(projectId: string) {  const wbsElements = await prisma.wBSElement.findMany({    where: {      projectId,      parentWBSId: null, // Top-level only    },    include: {      childWBS: {        include: {          childWBS: {            include: {              childWBS: true,            },          },        },      },    },  })  function calculateProgress(wbs: any): number {    if (wbs.childWBS.length === 0) {      return wbs.progressPercentage || 0    }    const childProgress = wbs.childWBS.map((child: any) => {      const progress = calculateProgress(child)      const weight = child.weightPercentage || 0      return (progress * weight) / 100    })    return childProgress.reduce((sum: number, p: number) => sum + p, 0)  }  const topLevelProgress = wbsElements.map((wbs) => {    const progress = calculateProgress(wbs)    const weight = wbs.weightPercentage || 0    return (progress * weight) / 100  })  const overallProgress = topLevelProgress.reduce((sum, p) => sum + p, 0)  await prisma.project.update({    where: { id: projectId },    data: {      completionPercentage: overallProgress,      weightedProgress: overallProgress,    },  })  return overallProgress}// 4. Get project portfolio dashboardexport async function getProjectPortfolioDashboard(organizationId: string) {  const projects = await prisma.project.findMany({    where: {      organizationId,      deletedAt: null,      status: {        in: ['ACTIVE', 'AT_RISK', 'DELAYED'],      },    },    include: {      projectManager: {        select: {          id: true,          fullName: true,          avatar: true,        },      },      _count: {        select: {          risks: { where: { status: { in: ['IDENTIFIED', 'MONITORING'] } } },          issues: { where: { status: 'OPEN' } },          milestones: { where: { status: 'MISSED' } },        },      },    },    orderBy: {      priority: 'asc',    },  })  return projects.map((project) => ({    ...project,    scheduleVariance: calculateScheduleVariance(project),    costVariance: project.budgetVariancePercent,    riskCount: project._count.risks,    issueCount: project._count.issues,    missedMilestones: project._count.milestones,  }))}function calculateScheduleVariance(project: any): number {  if (!project.actualStartDate || !project.plannedEndDate) return 0  const today = new Date()  const totalDays =    (project.plannedEndDate.getTime() - project.actualStartDate.getTime()) /    (1000 * 60 * 60 * 24)  const elapsedDays =    (today.getTime() - project.actualStartDate.getTime()) / (1000 * 60 * 60 * 24)  const plannedProgress = (elapsedDays / totalDays) * 100  const actualProgress = project.completionPercentage  return actualProgress - plannedProgress}```---âœ… Summary - What We Have NowComplete System Schema âœ…Phase 1: FoundationUsers, Organizations, SWOT, DelphiPhase 2: RBAC & Audit7 Roles, Permissions, Audit TrailPhase 3: Strategic ExecutionTOWS, BSC, Strategy Map, Hoshin KanriPhase 4: Project Management âœ…Projects with full lifecycleWBS (5-level hierarchy)Gantt Chart (dependencies, critical path)Milestones trackingRisk ManagementIssue TrackingChange RequestsTime TrackingDocumentsStatus ReportsActivity-Based Costing---ğŸš€ Next Steps```bash# Run all seedspnpm db:seed-all# Open Prisma Studiopnpm db:studio```à¸à¸£à¹‰à¸­à¸¡à¸—à¸³à¸­à¸°à¹„à¸£à¸•à¹ˆà¸­à¸„à¸£à¸±à¸š?Phase 5: OKR System â†’ Complete cascading OKRsPhase 6: Logical Framework â†’ LFA for program evaluationCreate tRPC API â†’ Build all endpointsBuild React UI â†’ Start frontend developmentGenerate complete documentation â†’ ER diagrams, API docsà¸šà¸­à¸à¸¡à¸²à¹„à¸”à¹‰à¹€à¸¥à¸¢à¸„à¸£à¸±à¸š! ğŸ¯---ğŸ“Š Database Schema - Part 5: Complete KPI System & Cascadingà¸•à¹ˆà¸­à¸ˆà¸²à¸ Phase 4 à¹€à¸£à¸²à¸ˆà¸°à¸‚à¸¢à¸²à¸¢ KPI System à¹ƒà¸«à¹‰à¸„à¸£à¸šà¸–à¹‰à¸§à¸™ à¸£à¸­à¸‡à¸£à¸±à¸š Cascading, Benchmarking, KPI Library, Automated Data Collection, à¹à¸¥à¸° Advanced Analytics---ğŸ“‹ Step 1: Extended KPI Schema```prisma// prisma/schema.prisma (continued from Part 4)// ============================================================================// SECTION 26: EXTENDED KPI SYSTEM// ============================================================================// Update existing KPI model with additional fields// Add these fields to the existing KPI model:model KPI {  // ... existing fields ...    // Cascading  parentKPIId       String?  parentKPI         KPI?              @relation("KPICascade", fields: [parentKPIId], references: [id], onDelete: SetNull)  childKPIs         KPI[]             @relation("KPICascade")    // Cascading weight  contributionToParent Float?         // % contribution to parent KPI    // KPI Library reference  kpiTemplateId     String?  kpiTemplate       KPITemplate?      @relation(fields: [kpiTemplateId], references: [id], onDelete: SetNull)    // Data collection  dataCollectionMethod DataCollectionMethod @default(MANUAL)  automationConfig  Json?             // Config for automated collection    // Calculation  calculationType   CalculationType   @default(SIMPLE)  calculationFormula String?          @db.Text // SQL or formula  dependentKPIs     String[]          // Array of KPI IDs for composite KPIs    // Benchmarking  industryBenchmark Float?  nationalBenchmark Float?  internalBenchmark Float?    // Performance bands  excellentThreshold Float?           // >= this = Excellent  goodThreshold     Float?            // >= this = Good    acceptableThreshold Float?          // >= this = Acceptable  poorThreshold     Float?            // < this = Poor    // Trend analysis  trendDirection    TrendDirection?  trendStrength     Float?            // -1 to 1    // Statistical data  mean              Float?  median            Float?  standardDeviation Float?  variance          Float?    // Forecasting  forecastedValue   Float?  forecastConfidence Float?           // 0-1  forecastMethod    String?           // "Linear", "Exponential", "ARIMA"    // Relations (add to existing)  cascadingRules    KPICascadingRule[]  benchmarks        KPIBenchmark[]  alerts            KPIAlert[]  improvements      KPIImprovement[]  dataPoints        KPIDataPoint[]    @@index([parentKPIId])  @@index([kpiTemplateId])  @@index([dataCollectionMethod])}enum DataCollectionMethod {  MANUAL            // à¸à¸£à¸­à¸à¸¡à¸·à¸­  IMPORT            // à¸™à¸³à¹€à¸‚à¹‰à¸²à¸ˆà¸²à¸à¹„à¸Ÿà¸¥à¹Œ  API               // à¸”à¸¶à¸‡à¸ˆà¸²à¸ API  DATABASE_QUERY    // Query à¸ˆà¸²à¸ Database  IOT_SENSOR        // à¸ˆà¸²à¸ IoT Sensors  WEB_SCRAPING      // Scrape à¸ˆà¸²à¸à¹€à¸§à¹‡à¸š  CALCULATION       // à¸„à¸³à¸™à¸§à¸“à¸ˆà¸²à¸ KPI à¸­à¸·à¹ˆà¸™}enum CalculationType {  SIMPLE            // Simple value  SUM               // à¸œà¸¥à¸£à¸§à¸¡  AVERAGE           // à¸„à¹ˆà¸²à¹€à¸‰à¸¥à¸µà¹ˆà¸¢  PERCENTAGE        // à¸£à¹‰à¸­à¸¢à¸¥à¸°  RATIO             // à¸­à¸±à¸•à¸£à¸²à¸ªà¹ˆà¸§à¸™  WEIGHTED_AVERAGE  // à¸„à¹ˆà¸²à¹€à¸‰à¸¥à¸µà¹ˆà¸¢à¸–à¹ˆà¸§à¸‡à¸™à¹‰à¸³à¸«à¸™à¸±à¸  COMPOSITE         // à¸£à¸§à¸¡à¸«à¸¥à¸²à¸¢ KPI  CUSTOM_FORMULA    // Formula à¸à¸³à¸«à¸™à¸”à¹€à¸­à¸‡}enum TrendDirection {  STRONGLY_INCREASING   // à¹€à¸à¸´à¹ˆà¸¡à¸‚à¸¶à¹‰à¸™à¸¡à¸²à¸  INCREASING            // à¹€à¸à¸´à¹ˆà¸¡à¸‚à¸¶à¹‰à¸™  STABLE                // à¸„à¸‡à¸—à¸µà¹ˆ  DECREASING            // à¸¥à¸”à¸¥à¸‡  STRONGLY_DECREASING   // à¸¥à¸”à¸¥à¸‡à¸¡à¸²à¸  VOLATILE              // à¸œà¸±à¸™à¸œà¸§à¸™}// ============================================================================// SECTION 27: KPI LIBRARY & TEMPLATES// ============================================================================enum KPICategory {  // BSC Perspectives  FINANCIAL  CUSTOMER  INTERNAL_PROCESS  LEARNING_GROWTH    // Functional areas  OPERATIONS  SALES  MARKETING  HR  IT  QUALITY  SAFETY  ENVIRONMENT  COMPLIANCE    // EMS specific  RESPONSE_TIME  PATIENT_OUTCOME  RESOURCE_UTILIZATION  TRAINING  EQUIPMENT}enum IndustryType {  HEALTHCARE  EMERGENCY_SERVICES  PUBLIC_SECTOR  MANUFACTURING  RETAIL  FINANCE  EDUCATION  TECHNOLOGY  GENERAL}model KPITemplate {  id                String            @id @default(cuid())    // Template info  templateCode      String            @unique  templateName      String  templateDescription String?         @db.Text    // Classification  category          KPICategory  industry          IndustryType    // Measurement details  measurementUnit   String  measurementFormula String?          @db.Text  dataSource        String?    // Type & Polarity  kpiType           KPIType  polarity          KPIPolarity    // Calculation  calculationType   CalculationType  calculationFormula String?          @db.Text    // Reporting  reportingFrequency ReportingFrequency    // Best practices  bestPractices     String?           @db.Text  commonPitfalls    String?           @db.Text    // Benchmarks  industryAverage   Float?  topPerformerValue Float?    // Metadata  tags              String[]  isPublic          Boolean           @default(true)    // Usage tracking  timesUsed         Int               @default(0)    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt    // Relations  kpis              KPI[]    @@index([category])  @@index([industry])  @@map("kpi_templates")}// ============================================================================// SECTION 28: KPI CASCADING RULES// ============================================================================enum CascadingType {  PROPORTIONAL      // à¹à¸šà¹ˆà¸‡à¸•à¸²à¸¡à¸ªà¸±à¸”à¸ªà¹ˆà¸§à¸™  ADDITIVE          // à¸£à¸§à¸¡à¸à¸±à¸™ (parent = sum of children)  WEIGHTED          // à¸–à¹ˆà¸§à¸‡à¸™à¹‰à¸³à¸«à¸™à¸±à¸  CUSTOM            // à¸à¸³à¸«à¸™à¸”à¹€à¸­à¸‡}model KPICascadingRule {  id                String            @id @default(cuid())    parentKPIId       String  parentKPI         KPI               @relation(fields: [parentKPIId], references: [id], onDelete: Cascade)    // Cascading configuration  cascadingType     CascadingType    // Allocation rules  allocationFormula String?           @db.Text  allocationBasis   String?           // "Headcount", "Budget", "Volume"    // Auto-cascade settings  autoCascade       Boolean           @default(false)  cascadeTargets    Boolean           @default(true)  cascadeActuals    Boolean           @default(false)    // Aggregation  aggregationMethod String?           // "SUM", "AVERAGE", "WEIGHTED_AVG", "MAX", "MIN"    // Validation  validateTotal     Boolean           @default(true) // Child KPIs must add up to parent  allowedVariance   Float?            // Allowed variance %    isActive          Boolean           @default(true)    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt    @@index([parentKPIId])  @@map("kpi_cascading_rules")}// ============================================================================// SECTION 29: KPI BENCHMARKING// ============================================================================enum BenchmarkType {  INTERNAL          // à¹€à¸—à¸µà¸¢à¸šà¸ à¸²à¸¢à¹ƒà¸™à¸­à¸‡à¸„à¹Œà¸à¸£ (à¸‚à¹‰à¸²à¸¡à¹à¸œà¸™à¸)  INDUSTRY          // à¹€à¸—à¸µà¸¢à¸šà¸­à¸¸à¸•à¸ªà¸²à¸«à¸à¸£à¸£à¸¡  NATIONAL          // à¹€à¸—à¸µà¸¢à¸šà¸£à¸°à¸”à¸±à¸šà¸›à¸£à¸°à¹€à¸—à¸¨  INTERNATIONAL     // à¹€à¸—à¸µà¸¢à¸šà¸£à¸°à¸”à¸±à¸šà¸ªà¸²à¸à¸¥  BEST_IN_CLASS     // à¹€à¸—à¸µà¸¢à¸šà¸à¸±à¸šà¸œà¸¹à¹‰à¸™à¸³  HISTORICAL        // à¹€à¸—à¸µà¸¢à¸šà¸à¸±à¸šà¹ƒà¸™à¸­à¸”à¸µà¸•}model KPIBenchmark {  id                String            @id @default(cuid())    kpiId             String  kpi               KPI               @relation(fields: [kpiId], references: [id], onDelete: Cascade)    // Benchmark details  benchmarkType     BenchmarkType  benchmarkSource   String            // Organization or data source  benchmarkValue    Float    // Context  benchmarkYear     Int?  benchmarkQuarter  Int?  region            String?    // Statistical details  percentile25      Float?  percentile50      Float?            // Median  percentile75      Float?  percentile90      Float?    sampleSize        Int?    // Comparison  gapToTarget       Float?            // Current - Benchmark  gapPercentage     Float?    // Metadata  notes             String?           @db.Text  sourceUrl         String?    isActive          Boolean           @default(true)    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt    @@index([kpiId])  @@index([benchmarkType])  @@map("kpi_benchmarks")}// ============================================================================// SECTION 30: KPI DATA POINTS (High-frequency data)// ============================================================================model KPIDataPoint {  id                String            @id @default(cuid())    kpiId             String  kpi               KPI               @relation(fields: [kpiId], references: [id], onDelete: Cascade)    // Timestamp (precise for real-time data)  timestamp         DateTime    // Value  value             Float    // Data quality  quality           DataQuality       @default(GOOD)    // Source  sourceSystem      String?           // "Manual", "API", "Sensor-001"  collectionMethod  String?    // Validation  isValidated       Boolean           @default(false)  isAnomaly         Boolean           @default(false)  anomalyScore      Float?            // 0-1    // Context  metadata          Json?    createdAt         DateTime          @default(now())    @@index([kpiId, timestamp])  @@index([timestamp])  @@map("kpi_data_points")}enum DataQuality {  EXCELLENT  GOOD  FAIR  POOR  MISSING}// ============================================================================// SECTION 31: KPI ALERTS & NOTIFICATIONS// ============================================================================enum AlertType {  THRESHOLD         // à¹€à¸à¸´à¸™à¹€à¸à¸“à¸‘à¹Œ  TREND             // à¹à¸™à¸§à¹‚à¸™à¹‰à¸¡  ANOMALY           // à¸œà¸´à¸”à¸›à¸à¸•à¸´  MISSED_TARGET     // à¸à¸¥à¸²à¸”à¹€à¸›à¹‰à¸²  DUE_DATE          // à¹ƒà¸à¸¥à¹‰à¸„à¸£à¸šà¸à¸³à¸«à¸™à¸”  DATA_QUALITY      // à¸„à¸¸à¸“à¸ à¸²à¸à¸‚à¹‰à¸­à¸¡à¸¹à¸¥}enum AlertSeverity {  INFO  WARNING  CRITICAL  URGENT}enum AlertStatus {  ACTIVE  ACKNOWLEDGED  RESOLVED  DISMISSED  EXPIRED}model KPIAlert {  id                String            @id @default(cuid())    kpiId             String  kpi               KPI               @relation(fields: [kpiId], references: [id], onDelete: Cascade)    // Alert details  alertType         AlertType  severity          AlertSeverity    // Condition  condition         String            @db.Text // "value < 80", "trend = DECREASING"  threshold         Float?    // Message  alertTitle        String  alertMessage      String            @db.Text    // Auto-generated data  triggerValue      Float?  triggerTimestamp  DateTime    // Status  status            AlertStatus       @default(ACTIVE)    // Acknowledgment  acknowledgedBy    String?  acknowledgedAt    DateTime?  acknowledgedNote  String?           @db.Text    // Resolution  resolvedBy        String?  resolvedAt        DateTime?  resolutionNote    String?           @db.Text    // Notification  notificationSent  Boolean           @default(false)  notifiedUsers     String[]          // Array of user IDs    // Expiration  expiresAt         DateTime?    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt    @@index([kpiId, status])  @@index([severity, status])  @@index([triggerTimestamp])  @@map("kpi_alerts")}// ============================================================================// SECTION 32: KPI IMPROVEMENT INITIATIVES// ============================================================================enum ImprovementStatus {  PROPOSED  APPROVED  IN_PROGRESS  COMPLETED  CANCELLED  ON_HOLD}model KPIImprovement {  id                String              @id @default(cuid())    kpiId             String  kpi               KPI                 @relation(fields: [kpiId], references: [id], onDelete: Cascade)    // Initiative details  initiativeCode    String  initiativeName    String  description       String              @db.Text    // Problem statement  currentState      String              @db.Text  desiredState      String              @db.Text  rootCause         String?             @db.Text    // Target improvement  baselineValue     Float  targetValue       Float  targetDate        DateTime    currentValue      Float?  achievementRate   Float?              // Progress toward target    // Action plan  actionPlan        Json?               // Array of actions    // Resources  budgetRequired    Float?  budgetAllocated   Float?  teamMembers       String[]            // Array of user IDs    // Owner  ownerId           String  owner             User                @relation(fields: [ownerId], references: [id], onDelete: Cascade)    // Status  status            ImprovementStatus   @default(PROPOSED)    // Progress tracking  progressUpdates   Json?               // Array of progress updates    // Dates  startDate         DateTime?  completionDate    DateTime?    // Results  actualImprovement Float?  lessonsLearned    String?             @db.Text  successFactors    String?             @db.Text    createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt    @@unique([kpiId, initiativeCode])  @@index([kpiId])  @@index([status])  @@index([ownerId])  @@map("kpi_improvements")}// Add to User model:// kpiImprovements KPIImprovement[]// ============================================================================// SECTION 33: KPI DASHBOARD CONFIGURATIONS// ============================================================================enum DashboardType {  EXECUTIVE         // à¸ªà¸³à¸«à¸£à¸±à¸šà¸œà¸¹à¹‰à¸šà¸£à¸´à¸«à¸²à¸£  OPERATIONAL       // à¸ªà¸³à¸«à¸£à¸±à¸šà¸›à¸à¸´à¸šà¸±à¸•à¸´à¸à¸²à¸£  STRATEGIC         // à¸¢à¸¸à¸—à¸˜à¸¨à¸²à¸ªà¸•à¸£à¹Œ  DEPARTMENTAL      // à¸£à¸°à¸”à¸±à¸šà¹à¸œà¸™à¸  PERSONAL          // à¸ªà¹ˆà¸§à¸™à¸šà¸¸à¸„à¸„à¸¥  PUBLIC            // à¸ªà¸²à¸˜à¸²à¸£à¸“à¸°}model KPIDashboard {  id                String            @id @default(cuid())  organizationId    String    // Dashboard details  dashboardCode     String  dashboardName     String  description       String?           @db.Text    // Type  dashboardType     DashboardType    // Layout configuration (JSON)  layoutConfig      Json              // Grid layout, widget positions    // Widgets (JSON array)  widgets           Json              // Array of widget configs    // Filters  defaultFilters    Json?             // Default filter values    // Access  isPublic          Boolean           @default(false)  ownerId           String  owner             User              @relation(fields: [ownerId], references: [id], onDelete: Cascade)    sharedWith        String[]          // Array of user/team IDs    // Settings  refreshInterval   Int?              // Auto-refresh in seconds    // Usage  viewCount         Int               @default(0)  lastViewedAt      DateTime?    isActive          Boolean           @default(true)    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt    @@unique([organizationId, dashboardCode])  @@index([organizationId])  @@index([ownerId])  @@index([dashboardType])  @@map("kpi_dashboards")}// Add to User model:// dashboards KPIDashboard[]// ============================================================================// SECTION 34: KPI REVIEW & APPROVAL WORKFLOW// ============================================================================enum ReviewStatus {  DRAFT  SUBMITTED  UNDER_REVIEW  APPROVED  REJECTED  REVISION_NEEDED}enum ReviewType {  MONTHLY  QUARTERLY  SEMI_ANNUAL  ANNUAL  AD_HOC}model KPIReview {  id                String            @id @default(cuid())    kpiId             String  kpi               KPI               @relation(fields: [kpiId], references: [id], onDelete: Cascade)    // Review details  reviewType        ReviewType  reviewPeriodStart DateTime  reviewPeriodEnd   DateTime    // Performance summary  periodValue       Float?  targetValue       Float?  achievementRate   Float?  variance          Float?    // Analysis  performanceAnalysis String?         @db.Text  trendAnalysis     String?           @db.Text    // Issues & Actions  issues            Json?             // Array of issues  correctiveActions Json?             // Array of actions    // Improvement opportunities  recommendations   String?           @db.Text    // Attachments  attachments       String[]          // Array of file URLs    // Submission  submittedBy       String  submitter         User              @relation("ReviewSubmitter", fields: [submittedBy], references: [id], onDelete: Cascade)  submittedAt       DateTime?    // Review  reviewedBy        String?  reviewer          User?             @relation("ReviewReviewer", fields: [reviewedBy], references: [id], onDelete: SetNull)  reviewedAt        DateTime?  reviewNotes       String?           @db.Text    // Status  status            ReviewStatus      @default(DRAFT)    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt    @@index([kpiId])  @@index([status])  @@index([reviewPeriodEnd])  @@map("kpi_reviews")}// Add to User model:// submittedReviews KPIReview[] @relation("ReviewSubmitter")// reviewedKPIReviews KPIReview[] @relation("ReviewReviewer")// Add to KPI model:// reviews KPIReview[]// ============================================================================// SECTION 35: KPI ANALYTICS & STATISTICS// ============================================================================model KPIStatistics {  id                String            @id @default(cuid())    kpiId             String            @unique    // Time period  calculatedFor     String            // "2024-Q1", "2024-04", "2024"    // Descriptive statistics  count             Int  sum               Float?  mean              Float  median            Float?  mode              Float?    // Dispersion  range             Float?  variance          Float?  standardDeviation Float?  coefficientOfVariation Float?    // Distribution  min               Float  max               Float  q1                Float?            // 25th percentile  q3                Float?            // 75th percentile  iqr               Float?            // Interquartile range    // Outliers  outlierCount      Int               @default(0)  outlierValues     Float[]    // Trend  trendDirection    TrendDirection?  trendStrength     Float?            // Correlation coefficient  linearSlope       Float?    // Forecasting (simple)  nextPeriodForecast Float?  forecastError     Float?            // MAPE    // Performance  achievementRate   Float?  averageAchievement Float?    // Last calculation  calculatedAt      DateTime          @default(now())    @@index([kpiId])  @@index([calculatedFor])  @@map("kpi_statistics")}// ============================================================================// SECTION 36: KPI CORRELATION ANALYSIS// ============================================================================model KPICorrelation {  id                String            @id @default(cuid())    kpi1Id            String  kpi2Id            String    // Correlation coefficient (-1 to 1)  correlationCoefficient Float    // Statistical significance  pValue            Float?  isSignificant     Boolean           @default(false)    // Sample size  sampleSize        Int    // Time period  periodStart       DateTime  periodEnd         DateTime    // Interpretation  correlationType   CorrelationType?  strength          CorrelationStrength?    // Causality (if analyzed)  possibleCausation String?           @db.Text    calculatedAt      DateTime          @default(now())    @@unique([kpi1Id, kpi2Id])  @@index([kpi1Id])  @@index([kpi2Id])  @@index([correlationCoefficient])  @@map("kpi_correlations")}enum CorrelationType {  POSITIVE          // à¹€à¸à¸´à¹ˆà¸¡à¸‚à¸¶à¹‰à¸™à¸à¸£à¹‰à¸­à¸¡à¸à¸±à¸™  NEGATIVE          // à¸•à¸£à¸‡à¸‚à¹‰à¸²à¸¡  NONE              // à¹„à¸¡à¹ˆà¸¡à¸µà¸„à¸§à¸²à¸¡à¸ªà¸±à¸¡à¸à¸±à¸™à¸˜à¹Œ}// ============================================================================// SECTION 37: KPI DATA QUALITY TRACKING// ============================================================================model KPIDataQualityCheck {  id                String            @id @default(cuid())    kpiId             String    // Check details  checkDate         DateTime          @default(now())  checkType         DataQualityCheckType    // Results  passed            Boolean  qualityScore      Float             // 0-100    // Issues found  issuesFound       Json?             // Array of issues    // Dimensions assessed  accuracy          Float?            // 0-100  completeness      Float?  consistency       Float?  timeliness        Float?  validity          Float?    // Recommendations  recommendations   String?           @db.Text    // Follow-up  actionRequired    Boolean           @default(false)  actionTaken       String?           @db.Text    checkedBy         String?    @@index([kpiId, checkDate])  @@map("kpi_data_quality_checks")}enum DataQualityCheckType {  AUTOMATED         // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´  MANUAL            // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸”à¹‰à¸§à¸¢à¸¡à¸·à¸­  AUDIT             // Audit  VALIDATION        // Validation}// ============================================================================// SECTION 38: KPI CHANGE LOG// ============================================================================model KPIChangeLog {  id                String            @id @default(cuid())    kpiId             String    // Change details  changeType        KPIChangeType    // What changed  fieldChanged      String  oldValue          String?           @db.Text  newValue          String?           @db.Text    // Why  changeReason      String?           @db.Text    // Who  changedBy         String  changedByUser     User              @relation(fields: [changedBy], references: [id], onDelete: Cascade)    // When  changedAt         DateTime          @default(now())    // Approval (if required)  requiresApproval  Boolean           @default(false)  approvedBy        String?  approvedAt        DateTime?    @@index([kpiId, changedAt])  @@index([changeType])  @@map("kpi_change_logs")}// Add to User model:// kpiChangeLogs KPIChangeLog[]enum KPIChangeType {  DEFINITION        // à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸™à¸´à¸¢à¸²à¸¡  TARGET            // à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢  FORMULA           // à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸ªà¸¹à¸•à¸£  FREQUENCY         // à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸„à¸§à¸²à¸¡à¸–à¸µà¹ˆ  OWNER             // à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸œà¸¹à¹‰à¸£à¸±à¸šà¸œà¸´à¸”à¸Šà¸­à¸š  STATUS            // à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸ªà¸–à¸²à¸™à¸°  OTHER             // à¸­à¸·à¹ˆà¸™à¹†}```---ğŸŒ± Step 2: Seed Data for Complete KPI System```typescript// prisma/seed-kpi-system.tsimport { PrismaClient, KPICategory, IndustryType, BenchmarkType, AlertType } from '@prisma/client'const prisma = new PrismaClient()async function seedKPISystem() {  console.log('ğŸ“Š Seeding Complete KPI System...')  const niems = await prisma.organization.findUnique({ where: { code: 'NIEMS' } })  if (!niems) throw new Error('NIEMS not found')  const admin = await prisma.user.findUnique({ where: { email: 'admin@niems.go.th' } })  const planner = await prisma.user.findUnique({ where: { email: 'planner@niems.go.th' } })  // =========================================================================  // 1. Create KPI Templates (Library)  // =========================================================================  const templates = [    {      code: 'EMS-RT-001',      name: 'Average Emergency Response Time',      desc: 'à¹€à¸§à¸¥à¸²à¹€à¸‰à¸¥à¸µà¹ˆà¸¢à¹ƒà¸™à¸à¸²à¸£à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™ à¸•à¸±à¹‰à¸‡à¹à¸•à¹ˆà¸£à¸±à¸šà¹à¸ˆà¹‰à¸‡à¸ˆà¸™à¸–à¸¶à¸‡à¸–à¸¶à¸‡à¸—à¸µà¹ˆà¹€à¸à¸´à¸”à¹€à¸«à¸•à¸¸',      category: KPICategory.RESPONSE_TIME,      industry: IndustryType.EMERGENCY_SERVICES,      unit: 'à¸™à¸²à¸—à¸µ',      formula: 'AVG(arrival_time - notification_time)',      type: 'LAGGING',      polarity: 'LOWER_BETTER',      calcType: 'AVERAGE',      frequency: 'MONTHLY',      bestPractice: 'à¸„à¸§à¸£à¸•à¸´à¸”à¸•à¸²à¸¡ real-time à¹à¸¥à¸°à¸§à¸´à¹€à¸„à¸£à¸²à¸°à¸«à¹Œà¸•à¸²à¸¡ peak hours',      industryAvg: 15,      topPerformer: 8,    },    {      code: 'EMS-PO-001',      name: 'Patient Survival Rate',      desc: 'à¸­à¸±à¸•à¸£à¸²à¸à¸²à¸£à¸£à¸­à¸”à¸Šà¸µà¸§à¸´à¸•à¸‚à¸­à¸‡à¸œà¸¹à¹‰à¸›à¹ˆà¸§à¸¢à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™',      category: KPICategory.PATIENT_OUTCOME,      industry: IndustryType.EMERGENCY_SERVICES,      unit: '%',      formula: '(survived_patients / total_emergency_cases) Ã— 100',      type: 'LAGGING',      polarity: 'HIGHER_BETTER',      calcType: 'PERCENTAGE',      frequency: 'MONTHLY',      bestPractice: 'à¹à¸¢à¸à¸§à¸´à¹€à¸„à¸£à¸²à¸°à¸«à¹Œà¸•à¸²à¸¡à¸›à¸£à¸°à¹€à¸ à¸—à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™ (cardiac, trauma, stroke)',      industryAvg: 92,      topPerformer: 97,    },    {      code: 'EMS-RU-001',      name: 'Ambulance Utilization Rate',      desc: 'à¸­à¸±à¸•à¸£à¸²à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¸£à¸–à¸à¸¢à¸²à¸šà¸²à¸¥',      category: KPICategory.RESOURCE_UTILIZATION,      industry: IndustryType.EMERGENCY_SERVICES,      unit: '%',      formula: '(active_hours / total_available_hours) Ã— 100',      type: 'LAGGING',      polarity: 'TARGET_BETTER',      calcType: 'PERCENTAGE',      frequency: 'DAILY',      bestPractice: 'à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢à¸—à¸µà¹ˆà¸”à¸µà¸„à¸·à¸­ 60-70% (à¹„à¸¡à¹ˆà¸ªà¸¹à¸‡à¸«à¸£à¸·à¸­à¸•à¹ˆà¸³à¹€à¸à¸´à¸™à¹„à¸›)',      industryAvg: 65,      topPerformer: 68,    },    {      code: 'FIN-CE-001',      name: 'Cost per Emergency Response',      desc: 'à¸•à¹‰à¸™à¸—à¸¸à¸™à¹€à¸‰à¸¥à¸µà¹ˆà¸¢à¸•à¹ˆà¸­à¸«à¸™à¸¶à¹ˆà¸‡à¸à¸²à¸£à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™',      category: KPICategory.FINANCIAL,      industry: IndustryType.EMERGENCY_SERVICES,      unit: 'à¸šà¸²à¸—',      formula: 'total_operational_cost / total_emergency_responses',      type: 'LAGGING',      polarity: 'LOWER_BETTER',      calcType: 'RATIO',      frequency: 'MONTHLY',      bestPractice: 'à¸•à¸´à¸”à¸•à¸²à¸¡à¸„à¸§à¸šà¸„à¸¹à¹ˆà¸à¸±à¸š quality metrics',      industryAvg: 5000,      topPerformer: 3500,    },    {      code: 'HR-TR-001',      name: 'Staff Training Hours',      desc: 'à¸ˆà¸³à¸™à¸§à¸™à¸Šà¸±à¹ˆà¸§à¹‚à¸¡à¸‡à¸à¸²à¸£à¸à¸¶à¸à¸­à¸šà¸£à¸¡à¹€à¸‰à¸¥à¸µà¹ˆà¸¢à¸•à¹ˆà¸­à¸„à¸™à¸•à¹ˆà¸­à¸›à¸µ',      category: KPICategory.TRAINING,      industry: IndustryType.HEALTHCARE,      unit: 'à¸Šà¸±à¹ˆà¸§à¹‚à¸¡à¸‡',      formula: 'SUM(training_hours) / total_staff',      type: 'LEADING',      polarity: 'HIGHER_BETTER',      calcType: 'AVERAGE',      frequency: 'QUARTERLY',      bestPractice: 'à¸„à¸§à¸£à¸¡à¸µà¸­à¸¢à¹ˆà¸²à¸‡à¸™à¹‰à¸­à¸¢ 40 à¸Šà¸±à¹ˆà¸§à¹‚à¸¡à¸‡à¸•à¹ˆà¸­à¸›à¸µ',      industryAvg: 45,      topPerformer: 60,    },  ]  const createdTemplates: any[] = []  for (const t of templates) {    const template = await prisma.kPITemplate.create({      data: {        templateCode: t.code,        templateName: t.name,        templateDescription: t.desc,        category: t.category,        industry: t.industry,        measurementUnit: t.unit,        measurementFormula: t.formula,        kpiType: t.type as any,        polarity: t.polarity as any,        calculationType: t.calcType as any,        reportingFrequency: t.frequency as any,        bestPractices: t.bestPractice,        industryAverage: t.industryAvg,        topPerformerValue: t.topPerformer,        timesUsed: 0,      },    })    createdTemplates.push(template)    console.log(`  âœ… Created template: ${t.code}`)  }  // =========================================================================  // 2. Create Cascading KPIs  // =========================================================================  // Get an existing objective  const objective = await prisma.strategicObjective.findFirst({    where: {      organizationId: niems.id,      objectiveCode: 'C1',    },  })  if (!objective) throw new Error('Objective C1 not found')  // Parent KPI (Organization level)  const parentKPI = await prisma.kPI.create({    data: {      objectiveId: objective.id,      kpiCode: 'C1.1-ORG',      kpiName: 'à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¹€à¸‰à¸¥à¸µà¹ˆà¸¢ (à¸£à¸°à¸”à¸±à¸šà¸­à¸‡à¸„à¹Œà¸à¸£)',      kpiDescription: 'à¹€à¸§à¸¥à¸²à¹€à¸‰à¸¥à¸µà¹ˆà¸¢à¹ƒà¸™à¸à¸²à¸£à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸—à¸±à¹ˆà¸§à¸›à¸£à¸°à¹€à¸—à¸¨',      measurementUnit: 'à¸™à¸²à¸—à¸µ',      kpiType: 'LAGGING',      polarity: 'LOWER_BETTER',      baselineValue: 15,      baselineYear: 2023,      targetValue: 12,      targetYear: 2027,      currentValue: 14,      reportingFrequency: 'MONTHLY',      dataCollectionMethod: 'CALCULATION',      calculationType: 'WEIGHTED_AVERAGE',      kpiTemplateId: createdTemplates[0].id,      greenThreshold: 12,      yellowThreshold: 14,      weightPercentage: 70,      isActive: true,    },  })  // Child KPIs (Regional level)  const regions = [    { name: 'à¸ à¸²à¸„à¹€à¸«à¸™à¸·à¸­', baseline: 16, current: 15, target: 13, weight: 20 },    { name: 'à¸ à¸²à¸„à¸•à¸°à¸§à¸±à¸™à¸­à¸­à¸à¹€à¸‰à¸µà¸¢à¸‡à¹€à¸«à¸™à¸·à¸­', baseline: 17, current: 15.5, target: 14, weight: 25 },    { name: 'à¸ à¸²à¸„à¸à¸¥à¸²à¸‡', baseline: 14, current: 13, target: 11, weight: 30 },    { name: 'à¸ à¸²à¸„à¹ƒà¸•à¹‰', baseline: 16, current: 14.5, target: 13, weight: 25 },  ]  const childKPIs: any[] = []  for (let i = 0; i < regions.length; i++) {    const r = regions[i]    const childKPI = await prisma.kPI.create({      data: {        objectiveId: objective.id,        kpiCode: `C1.1-R${i + 1}`,        kpiName: `à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™ - ${r.name}`,        kpiDescription: `à¹€à¸§à¸¥à¸²à¹€à¸‰à¸¥à¸µà¹ˆà¸¢à¹ƒà¸™à¸à¸²à¸£à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¹ƒà¸™${r.name}`,        measurementUnit: 'à¸™à¸²à¸—à¸µ',        kpiType: 'LAGGING',        polarity: 'LOWER_BETTER',        baselineValue: r.baseline,        baselineYear: 2023,        targetValue: r.target,        targetYear: 2027,        currentValue: r.current,        reportingFrequency: 'MONTHLY',        dataCollectionMethod: 'DATABASE_QUERY',        calculationType: 'AVERAGE',        parentKPIId: parentKPI.id,        contributionToParent: r.weight,        kpiTemplateId: createdTemplates[0].id,        greenThreshold: r.target,        yellowThreshold: r.baseline,        isActive: true,      },    })    childKPIs.push(childKPI)  }  console.log('âœ… Created cascading KPIs')  // Create cascading rule  await prisma.kPICascadingRule.create({    data: {      parentKPIId: parentKPI.id,      cascadingType: 'WEIGHTED',      aggregationMethod: 'WEIGHTED_AVG',      autoCascade: true,      cascadeTargets: true,      cascadeActuals: true,      validateTotal: true,      allowedVariance: 5,      isActive: true,    },  })  console.log('âœ… Created cascading rule')  // =========================================================================  // 3. Create Benchmarks  // =========================================================================  await prisma.kPIBenchmark.create({    data: {      kpiId: parentKPI.id,      benchmarkType: 'NATIONAL',      benchmarkSource: 'Ministry of Public Health - National Average',      benchmarkValue: 13,      benchmarkYear: 2024,      percentile25: 10,      percentile50: 13,      percentile75: 16,      percentile90: 20,      sampleSize: 77,      notes: 'à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸ˆà¸²à¸à¸£à¸°à¸šà¸š EMS à¸—à¸±à¹ˆà¸§à¸›à¸£à¸°à¹€à¸—à¸¨ 77 à¸ˆà¸±à¸‡à¸«à¸§à¸±à¸”',      isActive: true,    },  })  await prisma.kPIBenchmark.create({    data: {      kpiId: parentKPI.id,      benchmarkType: 'INTERNATIONAL',      benchmarkSource: 'WHO - Global EMS Standards',      benchmarkValue: 10,      benchmarkYear: 2023,      percentile50: 10,      percentile90: 15,      notes: 'à¸¡à¸²à¸•à¸£à¸à¸²à¸™à¸ªà¸²à¸à¸¥à¸ˆà¸²à¸ WHO',      sourceUrl: 'https://www.who.int/ems-standards',      isActive: true,    },  })  await prisma.kPIBenchmark.create({    data: {      kpiId: parentKPI.id,      benchmarkType: 'BEST_IN_CLASS',      benchmarkSource: 'Singapore SCDF',      benchmarkValue: 8,      benchmarkYear: 2024,      notes: 'Singapore Civil Defence Force - à¸œà¸¹à¹‰à¸™à¸³à¹ƒà¸™à¸ à¸¹à¸¡à¸´à¸ à¸²à¸„à¸­à¸²à¹€à¸‹à¸µà¸¢à¸™',      isActive: true,    },  })  console.log('âœ… Created benchmarks')  // =========================================================================  // 4. Create KPI Data Points (Simulated time series)  // =========================================================================  const startDate = new Date('2024-01-01')  const dataPoints = []  for (let i = 0; i < 90; i++) {    // 90 days of data    const date = new Date(startDate)    date.setDate(date.getDate() + i)    // Simulate improving trend with some noise    const baseValue = 15 - (i / 90) * 1 // Improving from 15 to 14    const noise = (Math.random() - 0.5) * 2 // Â±1 minute noise    const value = Math.max(10, Math.min(20, baseValue + noise))    dataPoints.push({      kpiId: parentKPI.id,      timestamp: date,      value,      quality: 'GOOD',      sourceSystem: 'EMS Database',      collectionMethod: 'Automated Query',      isValidated: true,      isAnomaly: false,    })  }  await prisma.kPIDataPoint.createMany({ data: dataPoints })  console.log(`âœ… Created ${dataPoints.length} data points`)  // =========================================================================  // 5. Create KPI Alerts  // =========================================================================  await prisma.kPIAlert.create({    data: {      kpiId: parentKPI.id,      alertType: 'THRESHOLD',      severity: 'WARNING',      condition: 'current_value > yellow_threshold',      threshold: 14,      alertTitle: 'à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¹€à¸à¸´à¸™à¹€à¸à¸“à¸‘à¹Œà¹€à¸«à¸¥à¸·à¸­à¸‡',      alertMessage: `à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¹€à¸‰à¸¥à¸µà¹ˆà¸¢à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™à¸„à¸·à¸­ 14.5 à¸™à¸²à¸—à¸µ à¹€à¸à¸´à¸™à¹€à¸à¸“à¸‘à¹Œà¹€à¸«à¸¥à¸·à¸­à¸‡à¸—à¸µà¹ˆ 14 à¸™à¸²à¸—à¸µà¹à¸™à¸°à¸™à¸³à¹ƒà¸«à¹‰:1. à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸à¸·à¹‰à¸™à¸—à¸µà¹ˆà¸—à¸µà¹ˆà¸¡à¸µà¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸ªà¸¹à¸‡2. à¸§à¸´à¹€à¸„à¸£à¸²à¸°à¸«à¹Œà¸ªà¸²à¹€à¸«à¸•à¸¸ (traffic, staff shortage, equipment)3. à¸à¸´à¸ˆà¸²à¸£à¸“à¸²à¸¡à¸²à¸•à¸£à¸à¸²à¸£à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡      `,      triggerValue: 14.5,      triggerTimestamp: new Date(),      status: 'ACTIVE',      notificationSent: true,      notifiedUsers: [admin!.id, planner!.id],    },  })  await prisma.kPIAlert.create({    data: {      kpiId: parentKPI.id,      alertType: 'TREND',      severity: 'INFO',      alertTitle: 'à¹à¸™à¸§à¹‚à¸™à¹‰à¸¡à¸à¸²à¸£à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡à¸Šà¸°à¸¥à¸­à¸•à¸±à¸§',      alertMessage: 'à¸à¸²à¸£à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¹ƒà¸™à¹€à¸”à¸·à¸­à¸™à¸™à¸µà¹‰à¸Šà¸°à¸¥à¸­à¸à¸§à¹ˆà¸²à¹€à¸”à¸·à¸­à¸™à¸—à¸µà¹ˆà¹à¸¥à¹‰à¸§',      triggerTimestamp: new Date(),      status: 'ACKNOWLEDGED',      acknowledgedBy: planner!.id,      acknowledgedAt: new Date(),      acknowledgedNote: 'à¸£à¸±à¸šà¸—à¸£à¸²à¸š à¸ˆà¸°à¸§à¸´à¹€à¸„à¸£à¸²à¸°à¸«à¹Œà¸ªà¸²à¹€à¸«à¸•à¸¸à¹ƒà¸™à¸à¸²à¸£à¸›à¸£à¸°à¸Šà¸¸à¸¡à¸ªà¸±à¸›à¸”à¸²à¸«à¹Œà¸«à¸™à¹‰à¸²',      notificationSent: true,      notifiedUsers: [planner!.id],    },  })  console.log('âœ… Created KPI alerts')  // =========================================================================  // 6. Create KPI Improvement Initiative  // =========================================================================  await prisma.kPIImprovement.create({    data: {      kpiId: parentKPI.id,      initiativeCode: 'IMP-2024-001',      initiativeName: 'à¸¥à¸”à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸”à¹‰à¸§à¸¢ AI Dispatch System',      description: `à¸™à¸³à¸£à¸°à¸šà¸š AI à¸¡à¸²à¸Šà¹ˆà¸§à¸¢à¹ƒà¸™à¸à¸²à¸£à¸ˆà¸±à¸”à¸ªà¸£à¸£à¸£à¸–à¸à¸¢à¸²à¸šà¸²à¸¥à¹à¸¥à¸°à¹€à¸ªà¹‰à¸™à¸—à¸²à¸‡à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´à¹€à¸à¸·à¹ˆà¸­à¸¥à¸”à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸ˆà¸²à¸ 15 à¸™à¸²à¸—à¸µ à¹€à¸›à¹‡à¸™ 12 à¸™à¸²à¸—à¸µ à¸ à¸²à¸¢à¹ƒà¸™à¸ªà¸´à¹‰à¸™à¸›à¸µ 2024      `,      currentState: 'à¹ƒà¸Šà¹‰à¸£à¸°à¸šà¸š manual dispatch à¸—à¸³à¹ƒà¸«à¹‰à¹ƒà¸Šà¹‰à¹€à¸§à¸¥à¸²à¸™à¸²à¸™à¹ƒà¸™à¸à¸²à¸£à¸•à¸±à¸”à¸ªà¸´à¸™à¹ƒà¸ˆ',      desiredState: 'à¸£à¸°à¸šà¸š AI à¸ˆà¸±à¸”à¸ªà¸£à¸£à¸£à¸–à¹à¸¥à¸°à¹€à¸ªà¹‰à¸™à¸—à¸²à¸‡à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´à¸ à¸²à¸¢à¹ƒà¸™ 30 à¸§à¸´à¸™à¸²à¸—à¸µ',      rootCause: `1. à¸à¸²à¸£à¸•à¸±à¸”à¸ªà¸´à¸™à¹ƒà¸ˆà¸‚à¸­à¸‡ dispatcher à¹ƒà¸Šà¹‰à¹€à¸§à¸¥à¸² 2-3 à¸™à¸²à¸—à¸µ2. à¸à¸²à¸£à¹€à¸¥à¸·à¸­à¸à¹€à¸ªà¹‰à¸™à¸—à¸²à¸‡à¹„à¸¡à¹ˆà¹€à¸«à¸¡à¸²à¸°à¸ªà¸¡à¹€à¸™à¸·à¹ˆà¸­à¸‡à¸ˆà¸²à¸à¹„à¸¡à¹ˆà¸¡à¸µà¸‚à¹‰à¸­à¸¡à¸¹à¸¥ real-time traffic3. à¸à¸²à¸£à¸›à¸£à¸°à¸ªà¸²à¸™à¸‡à¸²à¸™à¸à¸±à¸šà¹‚à¸£à¸‡à¸à¸¢à¸²à¸šà¸²à¸¥à¸¥à¹ˆà¸²à¸Šà¹‰à¸²      `,      baselineValue: 15,      targetValue: 12,      targetDate: new Date('2024-12-31'),      currentValue: 14,      achievementRate: 33, // (15-14)/(15-12) Ã— 100      actionPlan: {        actions: [          {            id: 1,            action: 'Develop AI Dispatch Algorithm',            owner: 'Tech Team',            deadline: '2024-06-30',            status: 'IN_PROGRESS',          },          {            id: 2,            action: 'Integrate with Real-time Traffic API',            owner: 'Integration Team',            deadline: '2024-07-31',            status: 'NOT_STARTED',          },          {            id: 3,            action: 'Pilot Test in Bangkok',            owner: 'Operations Team',            deadline: '2024-09-30',            status: 'NOT_STARTED',          },          {            id: 4,            action: 'Nationwide Rollout',            owner: 'Project Manager',            deadline: '2024-12-31',            status: 'NOT_STARTED',          },        ],      },      budgetRequired: 5000000,      budgetAllocated: 5000000,      teamMembers: [planner!.id],      ownerId: planner!.id,      status: 'IN_PROGRESS',      startDate: new Date('2024-04-01'),    },  })  console.log('âœ… Created improvement initiative')  // =========================================================================  // 7. Create KPI Dashboard  // =========================================================================  await prisma.kPIDashboard.create({    data: {      organizationId: niems.id,      dashboardCode: 'DASH-EXE-001',      dashboardName: 'Executive KPI Dashboard',      description: 'Dashboard à¸ªà¸³à¸«à¸£à¸±à¸šà¸œà¸¹à¹‰à¸šà¸£à¸´à¸«à¸²à¸£ à¹à¸ªà¸”à¸‡ KPI à¸ªà¸³à¸„à¸±à¸à¸£à¸°à¸”à¸±à¸šà¸­à¸‡à¸„à¹Œà¸à¸£',      dashboardType: 'EXECUTIVE',      layoutConfig: {        type: 'grid',        columns: 12,        rows: 'auto',      },      widgets: {        widgets: [          {            id: 'w1',            type: 'kpi-card',            position: { x: 0, y: 0, w: 3, h: 2 },            config: {              kpiId: parentKPI.id,              showTrend: true,              showSparkline: true,            },          },          {            id: 'w2',            type: 'line-chart',            position: { x: 3, y: 0, w: 6, h: 4 },            config: {              kpiIds: [parentKPI.id],              timeRange: '90d',              showBenchmark: true,            },          },          {            id: 'w3',            type: 'gauge',            position: { x: 9, y: 0, w: 3, h: 2 },            config: {              kpiId: parentKPI.id,              min: 0,              max: 20,              thresholds: [12, 14, 16],            },          },          {            id: 'w4',            type: 'regional-map',            position: { x: 0, y: 4, w: 6, h: 4 },            config: {              kpiIds: childKPIs.map((k: any) => k.id),              mapType: 'thailand-regions',            },          },          {            id: 'w5',            type: 'benchmark-comparison',            position: { x: 6, y: 4, w: 6, h: 4 },            config: {              kpiId: parentKPI.id,              showIndustry: true,              showNational: true,              showBestInClass: true,            },          },        ],      },      defaultFilters: {        dateRange: 'last-90-days',        region: 'all',      },      isPublic: false,      ownerId: admin!.id,      sharedWith: [planner!.id],      refreshInterval: 300, // 5 minutes      isActive: true,    },  })  console.log('âœ… Created KPI dashboard')  // =========================================================================  // 8. Create KPI Review  // =========================================================================  await prisma.kPIReview.create({    data: {      kpiId: parentKPI.id,      reviewType: 'MONTHLY',      reviewPeriodStart: new Date('2024-03-01'),      reviewPeriodEnd: new Date('2024-03-31'),      periodValue: 14.2,      targetValue: 13.5,      achievementRate: 85,      variance: 0.7,      performanceAnalysis: `à¹€à¸”à¸·à¸­à¸™à¸¡à¸µà¸™à¸²à¸„à¸¡ 2024 à¸¡à¸µà¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¹€à¸‰à¸¥à¸µà¹ˆà¸¢ 14.2 à¸™à¸²à¸—à¸µ à¸”à¸µà¸‚à¸¶à¹‰à¸™à¸ˆà¸²à¸à¹€à¸”à¸·à¸­à¸™à¸à¹ˆà¸­à¸™à¸—à¸µà¹ˆ 14.5 à¸™à¸²à¸—à¸µà¸›à¸±à¸ˆà¸ˆà¸±à¸¢à¸—à¸µà¹ˆà¸—à¸³à¹ƒà¸«à¹‰à¸”à¸µà¸‚à¸¶à¹‰à¸™:- à¹€à¸à¸´à¹ˆà¸¡à¸£à¸–à¸à¸¢à¸²à¸šà¸²à¸¥à¹ƒà¸™à¸Šà¹ˆà¸§à¸‡ peak hours- à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡à¸à¸²à¸£à¸à¸¶à¸à¸­à¸šà¸£à¸¡ dispatcher- à¸•à¸´à¸”à¸•à¸±à¹‰à¸‡à¸£à¸°à¸šà¸š GPS trackingà¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸–à¸¶à¸‡à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢ 13.5 à¸™à¸²à¸—à¸µ à¹€à¸™à¸·à¹ˆà¸­à¸‡à¸ˆà¸²à¸:- Traffic congestion à¹ƒà¸™à¸à¸·à¹‰à¸™à¸—à¸µà¹ˆà¹€à¸¡à¸·à¸­à¸‡- à¸‚à¸²à¸”à¹à¸„à¸¥à¸™à¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¹ƒà¸™à¸šà¸²à¸‡à¸à¸·à¹‰à¸™à¸—à¸µà¹ˆ      `,      trendAnalysis: 'à¹à¸™à¸§à¹‚à¸™à¹‰à¸¡à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡à¸•à¹ˆà¸­à¹€à¸™à¸·à¹ˆà¸­à¸‡ à¹à¸•à¹ˆà¸Šà¸°à¸¥à¸­à¸¥à¸‡à¹€à¸¥à¹‡à¸à¸™à¹‰à¸­à¸¢',      issues: {        issues: [          {            issue: 'Traffic congestion in urban areas',            severity: 'Medium',            impact: '+2 minutes average',          },          {            issue: 'Staff shortage in rural areas',            severity: 'High',            impact: '+3 minutes in affected areas',          },        ],      },      correctiveActions: {        actions: [          {            action: 'Implement AI dispatch system (Q2)',            responsible: 'Tech Team',            deadline: '2024-06-30',          },          {            action: 'Recruit additional staff for rural areas',            responsible: 'HR Team',            deadline: '2024-05-31',          },        ],      },      recommendations: 'à¸à¸´à¸ˆà¸²à¸£à¸“à¸² incentive à¸ªà¸³à¸«à¸£à¸±à¸šà¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¹ƒà¸™à¸à¸·à¹‰à¸™à¸—à¸µà¹ˆà¸«à¹ˆà¸²à¸‡à¹„à¸à¸¥',      submittedBy: planner!.id,      submittedAt: new Date('2024-04-05'),      reviewedBy: admin!.id,      reviewedAt: new Date('2024-04-07'),      reviewNotes: 'à¸­à¸™à¸¸à¸¡à¸±à¸•à¸´à¹à¸œà¸™à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡ à¸ˆà¸±à¸”à¸ªà¸£à¸£à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“à¹€à¸à¸´à¹ˆà¸¡à¹€à¸•à¸´à¸¡',      status: 'APPROVED',    },  })  console.log('âœ… Created KPI review')  // =========================================================================  // 9. Calculate KPI Statistics  // =========================================================================  const dataPointValues = dataPoints.map((dp) => dp.value).sort((a, b) => a - b)  const count = dataPointValues.length  const sum = dataPointValues.reduce((a, b) => a + b, 0)  const mean = sum / count  const median = dataPointValues[Math.floor(count / 2)]  const q1 = dataPointValues[Math.floor(count * 0.25)]  const q3 = dataPointValues[Math.floor(count * 0.75)]  const min = dataPointValues[0]  const max = dataPointValues[count - 1]  const variance =    dataPointValues.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / count  const stdDev = Math.sqrt(variance)  await prisma.kPIStatistics.create({    data: {      kpiId: parentKPI.id,      calculatedFor: '2024-Q1',      count,      sum,      mean,      median,      q1,      q3,      min,      max,      range: max - min,      variance,      standardDeviation: stdDev,      coefficientOfVariation: (stdDev / mean) * 100,      iqr: q3 - q1,      outlierCount: 0,      outlierValues: [],      trendDirection: 'DECREASING',      trendStrength: -0.85,      linearSlope: -0.011,      nextPeriodForecast: 13.8,      forecastError: 3.5,      achievementRate: 85,      averageAchievement: 83,    },  })  console.log('âœ… Created KPI statistics')  // =========================================================================  // 10. Create KPI Correlation  // =========================================================================  // Get another KPI for correlation  const kpi2 = await prisma.kPI.findFirst({    where: {      kpiCode: 'L1.1',      objectiveId: { not: null },    },  })  if (kpi2) {    await prisma.kPICorrelation.create({      data: {        kpi1Id: parentKPI.id,        kpi2Id: kpi2.id,        correlationCoefficient: -0.72,        pValue: 0.001,        isSignificant: true,        sampleSize: 90,        periodStart: new Date('2024-01-01'),        periodEnd: new Date('2024-03-31'),        correlationType: 'NEGATIVE',        strength: 'STRONG',        possibleCausation: `à¸à¸²à¸£à¸à¸¶à¸à¸­à¸šà¸£à¸¡à¸šà¸¸à¸„à¸¥à¸²à¸à¸£ (L1.1) à¸¡à¸µà¸„à¸§à¸²à¸¡à¸ªà¸±à¸¡à¸à¸±à¸™à¸˜à¹Œà¹€à¸Šà¸´à¸‡à¸¥à¸šà¸à¸±à¸šà¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡ (C1.1)à¸¢à¸´à¹ˆà¸‡à¸à¸¶à¸à¸­à¸šà¸£à¸¡à¸¡à¸²à¸ à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸¢à¸´à¹ˆà¸‡à¸¥à¸”à¸¥à¸‡à¹à¸ªà¸”à¸‡à¹ƒà¸«à¹‰à¹€à¸«à¹‡à¸™à¸§à¹ˆà¸²à¸à¸²à¸£à¸¥à¸‡à¸—à¸¸à¸™à¹ƒà¸™à¸à¸²à¸£à¸à¸±à¸’à¸™à¸²à¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¸ªà¹ˆà¸‡à¸œà¸¥à¸”à¸µà¸•à¹ˆà¸­à¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸ à¸²à¸à¸à¸²à¸£à¹ƒà¸«à¹‰à¸šà¸£à¸´à¸à¸²à¸£        `,      },    })    console.log('âœ… Created KPI correlation')  }  // =========================================================================  // 11. Create Data Quality Check  // =========================================================================  await prisma.kPIDataQualityCheck.create({    data: {      kpiId: parentKPI.id,      checkDate: new Date(),      checkType: 'AUTOMATED',      passed: true,      qualityScore: 92,      issuesFound: {        issues: [          {            type: 'Missing Data',            count: 2,            severity: 'Low',            dates: ['2024-03-15', '2024-03-16'],          },          {            type: 'Outlier',            count: 1,            severity: 'Low',            value: 25,            date: '2024-03-20',          },        ],      },      accuracy: 95,      completeness: 97,      consistency: 93,      timeliness: 88,      validity: 96,      recommendations: 'à¸•à¸´à¸”à¸•à¸²à¸¡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹ƒà¸™ source system à¹ƒà¸«à¹‰à¸ªà¸¡à¹ˆà¸³à¹€à¸ªà¸¡à¸­à¸¡à¸²à¸à¸‚à¸¶à¹‰à¸™',      actionRequired: false,    },  })  console.log('âœ… Created data quality check')  // =========================================================================  // 12. Create Change Log  // =========================================================================  await prisma.kPIChangeLog.create({    data: {      kpiId: parentKPI.id,      changeType: 'TARGET',      fieldChanged: 'targetValue',      oldValue: '13',      newValue: '12',      changeReason: 'à¸›à¸£à¸±à¸šà¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢à¹ƒà¸«à¹‰à¸—à¹‰à¸²à¸—à¸²à¸¢à¸¡à¸²à¸à¸‚à¸¶à¹‰à¸™à¸•à¸²à¸¡à¸¡à¸•à¸´à¸—à¸µà¹ˆà¸›à¸£à¸°à¸Šà¸¸à¸¡à¸œà¸¹à¹‰à¸šà¸£à¸´à¸«à¸²à¸£',      changedBy: admin!.id,      changedAt: new Date('2024-03-01'),      requiresApproval: true,      approvedBy: admin!.id,      approvedAt: new Date('2024-03-01'),    },  })  await prisma.kPIChangeLog.create({    data: {      kpiId: parentKPI.id,      changeType: 'FORMULA',      fieldChanged: 'calculationFormula',      oldValue: 'Simple average',      newValue: 'Weighted average by case volume',      changeReason: 'à¸›à¸£à¸±à¸šà¸ªà¸¹à¸•à¸£à¹ƒà¸«à¹‰à¸ªà¸°à¸—à¹‰à¸­à¸™à¸„à¸§à¸²à¸¡à¹€à¸›à¹‡à¸™à¸ˆà¸£à¸´à¸‡à¸¡à¸²à¸à¸‚à¸¶à¹‰à¸™ à¹‚à¸”à¸¢à¸–à¹ˆà¸§à¸‡à¸™à¹‰à¸³à¸«à¸™à¸±à¸à¸•à¸²à¸¡à¸ˆà¸³à¸™à¸§à¸™à¹€à¸„à¸ª',      changedBy: planner!.id,      changedAt: new Date('2024-02-15'),      requiresApproval: true,      approvedBy: admin!.id,      approvedAt: new Date('2024-02-16'),    },  })  console.log('âœ… Created change logs')  console.log('\nğŸ‰ Complete KPI System seed completed!')}seedKPISystem()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })```---ğŸ“¦ Step 3: Update package.json```json{  "scripts": {    "db:seed-kpi": "tsx prisma/seed-kpi-system.ts",    "db:seed-all": "pnpm db:seed && pnpm db:seed-rbac && pnpm db:seed-tows-bsc && pnpm db:seed-projects && pnpm db:seed-kpi"  }}```---ğŸ” Step 4: Advanced Query Examples```typescript// lib/queries/kpi-advanced-queries.ts// 1. Get KPI with full cascading hierarchyexport async function getKPICascadeTree(kpiId: string) {  const kpi = await prisma.kPI.findUnique({    where: { id: kpiId },    include: {      childKPIs: {        include: {          childKPIs: {            include: {              childKPIs: true,            },          },        },      },      parentKPI: true,      cascadingRules: true,    },  })  // Build tree structure  function buildTree(kpi: any): any {    return {      id: kpi.id,      code: kpi.kpiCode,      name: kpi.kpiName,      current: kpi.currentValue,      target: kpi.targetValue,      achievement: kpi.achievementRate,      weight: kpi.contributionToParent,      trafficLight: kpi.trafficLight,      children: kpi.childKPIs?.map(buildTree) || [],    }  }  return buildTree(kpi)}// 2. Calculate KPI rollup (bottom-up)export async function rollupKPIValues(parentKPIId: string) {  const parent = await prisma.kPI.findUnique({    where: { id: parentKPIId },    include: {      childKPIs: {        where: { isActive: true },      },      cascadingRules: true,    },  })  if (!parent || !parent.childKPIs.length) return null  const rule = parent.cascadingRules[0]  let calculatedValue = 0  switch (rule?.aggregationMethod) {    case 'SUM':      calculatedValue = parent.childKPIs.reduce(        (sum, child) => sum + (child.currentValue || 0),        0      )      break    case 'AVERAGE':      calculatedValue =        parent.childKPIs.reduce((sum, child) => sum + (child.currentValue || 0), 0) /        parent.childKPIs.length      break    case 'WEIGHTED_AVG':      const totalWeight = parent.childKPIs.reduce(        (sum, child) => sum + (child.contributionToParent || 0),        0      )      calculatedValue = parent.childKPIs.reduce(        (sum, child) =>          sum + ((child.currentValue || 0) * (child.contributionToParent || 0)) / totalWeight,        0      )      break    case 'MAX':      calculatedValue = Math.max(...parent.childKPIs.map((c) => c.currentValue || 0))      break    case 'MIN':      calculatedValue = Math.min(...parent.childKPIs.map((c) => c.currentValue || 0))      break  }  // Update parent KPI  await prisma.kPI.update({    where: { id: parentKPIId },    data: {      currentValue: calculatedValue,      lastUpdated: new Date(),    },  })  return calculatedValue}// 3. Get KPI with trend analysisexport async function getKPIWithTrendAnalysis(kpiId: string, days: number = 90) {  const kpi = await prisma.kPI.findUnique({    where: { id: kpiId },    include: {      dataPoints: {        where: {          timestamp: {            gte: new Date(Date.now() - days * 24 * 60 * 60 * 1000),          },        },        orderBy: { timestamp: 'asc' },      },      benchmarks: {        where: { isActive: true },      },    },  })  if (!kpi) return null  // Calculate trend  const values = kpi.dataPoints.map((dp) => dp.value)  const n = values.length  if (n < 2) {    return { kpi, trend: null }  }  // Linear regression  const xMean = (n - 1) / 2  const yMean = values.reduce((a, b) => a + b, 0) / n  let numerator = 0  let denominator = 0  values.forEach((y, x) => {    numerator += (x - xMean) * (y - yMean)    denominator += Math.pow(x - xMean, 2)  })  const slope = numerator / denominator  const intercept = yMean - slope * xMean  // Correlation coefficient  const yVariance = values.reduce((sum, y) => sum + Math.pow(y - yMean, 2), 0) / n  const r = numerator / Math.sqrt(denominator * yVariance * n)  // Forecast next period  const forecast = slope * n + intercept  // Trend direction  let direction: string  if (Math.abs(r) < 0.3) direction = 'STABLE'  else if (r > 0.7) direction = 'STRONGLY_INCREASING'  else if (r > 0.3) direction = 'INCREASING'  else if (r < -0.7) direction = 'STRONGLY_DECREASING'  else direction = 'DECREASING'  return {    kpi,    trend: {      slope,      correlation: r,      direction,      forecast,      confidence: Math.abs(r),    },    dataPoints: kpi.dataPoints,    benchmarks: kpi.benchmarks,  }}// 4. Benchmark comparison dashboardexport async function getKPIBenchmarkComparison(kpiId: string) {  const kpi = await prisma.kPI.findUnique({    where: { id: kpiId },    include: {      benchmarks: {        where: { isActive: true },        orderBy: { benchmarkValue: 'asc' },      },    },  })  if (!kpi) return null  const current = kpi.currentValue || 0  const target = kpi.targetValue  const comparisons = kpi.benchmarks.map((benchmark) => {    const gap = current - benchmark.benchmarkValue    const gapPercentage = (gap / benchmark.benchmarkValue) * 100    let status: 'BETTER' | 'WORSE' | 'EQUAL'    if (kpi.polarity === 'HIGHER_BETTER') {      status = current > benchmark.benchmarkValue ? 'BETTER' : current < benchmark.benchmarkValue ? 'WORSE' : 'EQUAL'    } else {      status = current < benchmark.benchmarkValue ? 'BETTER' : current > benchmark.benchmarkValue ? 'WORSE' : 'EQUAL'    }    return {      type: benchmark.benchmarkType,      source: benchmark.benchmarkSource,      value: benchmark.benchmarkValue,      current,      gap,      gapPercentage: Math.abs(gapPercentage),      status,    }  })  return {    kpi: {      id: kpi.id,      code: kpi.kpiCode,      name: kpi.kpiName,      current,      target,      unit: kpi.measurementUnit,      polarity: kpi.polarity,    },    comparisons,  }}// 5. KPI Alert Engine (to be run periodically)export async function evaluateKPIAlerts() {  const kpis = await prisma.kPI.findMany({    where: {      isActive: true,      currentValue: { not: null },    },  })  const alerts = []  for (const kpi of kpis) {    // Threshold alerts    if (kpi.redThreshold && kpi.currentValue! >= kpi.redThreshold) {      alerts.push({        kpiId: kpi.id,        alertType: 'THRESHOLD',        severity: 'CRITICAL',        alertTitle: `${kpi.kpiName} à¸–à¸¶à¸‡à¹€à¸à¸“à¸‘à¹Œà¹à¸”à¸‡`,        alertMessage: `KPI ${kpi.kpiCode} à¸¡à¸µà¸„à¹ˆà¸² ${kpi.currentValue} ${kpi.measurementUnit} à¹€à¸à¸´à¸™à¹€à¸à¸“à¸‘à¹Œà¹à¸”à¸‡ ${kpi.redThreshold}`,        triggerValue: kpi.currentValue,        triggerTimestamp: new Date(),        status: 'ACTIVE',      })    }    // Achievement alerts    if (kpi.achievementRate && kpi.achievementRate < 60) {      alerts.push({        kpiId: kpi.id,        alertType: 'MISSED_TARGET',        severity: 'WARNING',        alertTitle: `${kpi.kpiName} à¸•à¹ˆà¸³à¸à¸§à¹ˆà¸²à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢`,        alertMessage: `à¸šà¸£à¸£à¸¥à¸¸à¹€à¸à¸µà¸¢à¸‡ ${kpi.achievementRate.toFixed(1)}% à¸‚à¸­à¸‡à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢`,        triggerValue: kpi.achievementRate,        triggerTimestamp: new Date(),        status: 'ACTIVE',      })    }  }  // Create alerts  if (alerts.length > 0) {    await prisma.kPIAlert.createMany({      data: alerts,      skipDuplicates: true,    })  }  return alerts}// 6. KPI Dashboard Data Aggregationexport async function getKPIDashboardData(  organizationId: string,  perspectiveType?: string) {  const objectives = await prisma.strategicObjective.findMany({    where: {      organizationId,      ...(perspectiveType && { perspective: { perspectiveType: perspectiveType as any } }),      status: 'APPROVED',    },    include: {      perspective: true,      kpis: {        where: { isActive: true },        include: {          actuals: {            orderBy: { measurementDate: 'desc' },            take: 1,          },          alerts: {            where: { status: 'ACTIVE' },          },          improvements: {            where: { status: 'IN_PROGRESS' },          },        },      },    },  })  return objectives.map((obj) => ({    objective: {      id: obj.id,      code: obj.objectiveCode,      name: obj.objectiveName,      perspective: obj.perspective.nameTh,      perspectiveColor: obj.perspective.color,    },    kpis: obj.kpis.map((kpi) => ({      id: kpi.id,      code: kpi.kpiCode,      name: kpi.kpiName,      current: kpi.currentValue,      target: kpi.targetValue,      unit: kpi.measurementUnit,      achievement: kpi.achievementRate,      trafficLight: kpi.trafficLight,      trend: kpi.trendDirection,      lastUpdated: kpi.lastUpdated,      activeAlerts: kpi.alerts.length,      activeImprovements: kpi.improvements.length,    })),  }))}```---âœ… Complete System SummaryğŸ¯ Full Schema CoveragePhase 1: Foundation (Users, Orgs, SWOT, Delphi) âœ…Phase 2: RBAC & Audit Trail âœ…Phase 3: TOWS, BSC, Strategy Map âœ…Phase 4: Projects, Gantt, WBS âœ…Phase 5: Complete KPI System âœ…KPI Cascading (3+ levels)KPI Library & TemplatesBenchmarking (5 types)Automated Data CollectionAlerts & NotificationsImprovement InitiativesDashboardsReviews & ApprovalsTrend AnalysisCorrelation AnalysisData Quality TrackingChange Management---ğŸš€ Run Everything```bash# Run complete seedpnpm db:seed-all# Or step by steppnpm db:seed           # Foundationpnpm db:seed-rbac      # RBACpnpm db:seed-tows-bsc  # Strategypnpm db:seed-projects  # Projectspnpm db:seed-kpi       # KPI System# Open Prisma Studiopnpm db:studio```---ğŸ“Š What's Next?à¹€à¸£à¸²à¸ªà¸²à¸¡à¸²à¸£à¸–à¸—à¸³à¸•à¹ˆà¸­:Phase 6: OKR System â†’ Cascading OKRs, Check-insPhase 7: Logframe Analysis â†’ LFA for program evaluationGenerate API (tRPC) â†’ Complete CRUD + business logicBuild React UI â†’ Components, pages, dashboardsCreate Documentation â†’ ER diagrams, API docs, user guidesà¸à¸£à¹‰à¸­à¸¡à¸—à¸³à¸­à¸°à¹„à¸£à¸•à¹ˆà¸­à¸„à¸£à¸±à¸š? ğŸ¯---ğŸ¯ Database Schema - Part 6: OKR System (Objectives & Key Results)à¸•à¹ˆà¸­à¸ˆà¸²à¸ Phase 5 à¹€à¸£à¸²à¸ˆà¸°à¸ªà¸£à¹‰à¸²à¸‡ Complete OKR System à¸£à¸­à¸‡à¸£à¸±à¸š Cascading, Check-ins, Alignment, CFRs (Conversations, Feedback, Recognition), à¹à¸¥à¸° OKR Grading---ğŸ“‹ Step 1: OKR System Schema```prisma// prisma/schema.prisma (continued from Part 5)// ============================================================================// SECTION 39: OKR SYSTEM (Objectives & Key Results)// ============================================================================enum OKRCycleStatus {  DRAFT  PLANNING  ACTIVE  COMPLETED  ARCHIVED}enum OKRType {  COMPANY           // à¸£à¸°à¸”à¸±à¸šà¸­à¸‡à¸„à¹Œà¸à¸£  DEPARTMENT        // à¸£à¸°à¸”à¸±à¸šà¹à¸œà¸™à¸  TEAM              // à¸£à¸°à¸”à¸±à¸šà¸—à¸µà¸¡  INDIVIDUAL        // à¸£à¸°à¸”à¸±à¸šà¸šà¸¸à¸„à¸„à¸¥}model OKRCycle {  id                String            @id @default(cuid())  organizationId    String  organization      Organization      @relation(fields: [organizationId], references: [id], onDelete: Cascade)    // Cycle details  cycleName         String            // "Q1 2024", "H1 2024", "FY 2024"  cycleDescription  String?           @db.Text    // Timeline  startDate         DateTime  endDate           DateTime    // Type  cycleType         CycleType         @default(QUARTERLY)    // Status  status            OKRCycleStatus    @default(DRAFT)    // Settings  allowSelfSetting  Boolean           @default(true)  // à¸­à¸™à¸¸à¸à¸²à¸•à¹ƒà¸«à¹‰à¸•à¸±à¹‰à¸‡ OKR à¹€à¸­à¸‡  requireApproval   Boolean           @default(true)  // à¸•à¹‰à¸­à¸‡à¸­à¸™à¸¸à¸¡à¸±à¸•à¸´à¸à¹ˆà¸­à¸™à¹€à¸£à¸´à¹ˆà¸¡    checkInFrequency  CheckInFrequency  @default(WEEKLY)    // Grading  gradingScale      GradingScale      @default(PERCENTAGE) // 0-100% à¸«à¸£à¸·à¸­ 0.0-1.0    // Milestones  planningDeadline  DateTime?         // à¸§à¸±à¸™à¸ªà¸¸à¸”à¸—à¹‰à¸²à¸¢à¸‚à¸­à¸‡à¸à¸²à¸£à¸§à¸²à¸‡à¹à¸œà¸™  midCycleReview    DateTime?         // Mid-cycle review  finalReviewDate   DateTime?         // Final review    // Metadata  tags              String[]    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt    // Relations  okrs              OKR[]    @@unique([organizationId, cycleName])  @@index([organizationId])  @@index([status])  @@index([startDate, endDate])  @@map("okr_cycles")}// Add to Organization model:// okrCycles OKRCycle[]enum CycleType {  MONTHLY  QUARTERLY  SEMI_ANNUAL  ANNUAL  CUSTOM}enum CheckInFrequency {  DAILY  WEEKLY  BIWEEKLY  MONTHLY}enum GradingScale {  PERCENTAGE        // 0-100%  DECIMAL           // 0.0-1.0 (Google style)  BINARY            // Done/Not Done}// ============================================================================// SECTION 40: OBJECTIVES// ============================================================================enum OKRStatus {  DRAFT  SUBMITTED  APPROVED  ACTIVE  AT_RISK  ON_TRACK  COMPLETED  CANCELLED  ARCHIVED}model OKR {  id                String            @id @default(cuid())    cycleId           String  cycle             OKRCycle          @relation(fields: [cycleId], references: [id], onDelete: Cascade)    organizationId    String    // Objective details  objectiveCode     String?           // "O1", "O2" (optional)  objectiveTitle    String            // Clear, qualitative, aspirational  objectiveDescription String?        @db.Text    // Type & Level  okrType           OKRType    // Cascading (Parent-Child)  parentOKRId       String?  parentOKR         OKR?              @relation("OKRCascade", fields: [parentOKRId], references: [id], onDelete: SetNull)  childOKRs         OKR[]             @relation("OKRCascade")    // Alignment  alignedToStrategyIds String[]       // Array of TOWS strategy IDs  alignedToObjectiveIds String[]      // Array of BSC objective IDs    // Ownership  ownerUserId       String  ownerUser         User              @relation("OKROwner", fields: [ownerUserId], references: [id], onDelete: Cascade)    ownerTeamId       String?  ownerTeam         Team?             @relation(fields: [ownerTeamId], references: [id], onDelete: SetNull)    ownerDepartmentId String?  ownerDepartment   Department?       @relation(fields: [ownerDepartmentId], references: [id], onDelete: SetNull)    // Contributors (shared ownership)  contributorIds    String[]          // Array of user IDs    // Priority  priority          OKRPriority       @default(MEDIUM)    // Visibility  isPublic          Boolean           @default(true)  visibilityLevel   VisibilityLevel   @default(ORGANIZATION)    // Progress (calculated from Key Results)  progressPercentage Float            @default(0) // 0-100    // Confidence (how confident in achieving?)  confidence        ConfidenceLevel?  @default(MEDIUM)    // Status  status            OKRStatus         @default(DRAFT)    // Approval workflow  submittedAt       DateTime?  submittedBy       String?    approvedAt        DateTime?  approvedBy        String?  approvalNotes     String?           @db.Text    // Grading (at end of cycle)  finalScore        Float?            // 0-100 or 0.0-1.0  grade             OKRGrade?    selfAssessment    String?           @db.Text  managerAssessment String?           @db.Text    // Lessons learned  whatWentWell      String?           @db.Text  whatDidntGoWell   String?           @db.Text  lessonsLearned    String?           @db.Text    // Metadata  tags              String[]    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt  deletedAt         DateTime?    // Relations  keyResults        KeyResult[]  checkIns          OKRCheckIn[]  comments          OKRComment[]  alignments        OKRAlignment[]    @relation("SourceOKR")  alignedFrom       OKRAlignment[]    @relation("TargetOKR")    @@index([cycleId])  @@index([ownerUserId])  @@index([ownerTeamId])  @@index([ownerDepartmentId])  @@index([status])  @@index([parentOKRId])  @@map("okrs")}// Add to User model:// ownedOKRs OKR[] @relation("OKROwner")// Add to Team model:// okrs OKR[]// Add to Department model:// okrs OKR[]enum OKRPriority {  CRITICAL  HIGH  MEDIUM  LOW}enum VisibilityLevel {  PRIVATE           // à¹€à¸‰à¸à¸²à¸°à¹€à¸ˆà¹‰à¸²à¸‚à¸­à¸‡  TEAM              // à¹€à¸‰à¸à¸²à¸°à¸—à¸µà¸¡  DEPARTMENT        // à¹€à¸‰à¸à¸²à¸°à¹à¸œà¸™à¸  ORGANIZATION      // à¸—à¸±à¹‰à¸‡à¸­à¸‡à¸„à¹Œà¸à¸£  PUBLIC            // à¸ªà¸²à¸˜à¸²à¸£à¸“à¸°}enum ConfidenceLevel {  VERY_LOW          // 0-20%  LOW               // 21-40%  MEDIUM            // 41-60%  HIGH              // 61-80%  VERY_HIGH         // 81-100%}enum OKRGrade {  EXCEEDS           // à¹€à¸à¸´à¸™à¹€à¸›à¹‰à¸² (>100% à¸«à¸£à¸·à¸­ >1.0)  ACHIEVES          // à¸–à¸¶à¸‡à¹€à¸›à¹‰à¸² (70-100% à¸«à¸£à¸·à¸­ 0.7-1.0)  PARTIALLY         // à¸šà¸²à¸‡à¸ªà¹ˆà¸§à¸™ (40-69% à¸«à¸£à¸·à¸­ 0.4-0.69)  NOT_ACHIEVED      // à¹„à¸¡à¹ˆà¸–à¸¶à¸‡ (<40% à¸«à¸£à¸·à¸­ <0.4)}// ============================================================================// SECTION 41: KEY RESULTS// ============================================================================enum KeyResultType {  METRIC            // Quantitative (number-based)  MILESTONE         // Binary (done/not done)  BASELINE          // Starting from baseline to target}enum KeyResultStatus {  NOT_STARTED  ON_TRACK  AT_RISK  BEHIND  COMPLETED  CANCELLED}model KeyResult {  id                String            @id @default(cuid())    okrId             String  okr               OKR               @relation(fields: [okrId], references: [id], onDelete: Cascade)    // Key Result details  keyResultCode     String?           // "KR1", "KR2"  keyResultTitle    String            // Specific, measurable, time-bound  keyResultDescription String?        @db.Text    // Type  keyResultType     KeyResultType    // Measurement  measurementUnit   String?           // "%", "à¸£à¸²à¸¢", "à¸šà¸²à¸—"    // Values (for METRIC and BASELINE types)  startValue        Float?            // à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸—à¸µà¹ˆ  targetValue       Float?            // à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢  currentValue      Float?            // à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™    // For MILESTONE type  milestoneSteps    Json?             // Array of steps with completion status  completedSteps    Int?              @default(0)  totalSteps        Int?    // Progress calculation  progressPercentage Float            @default(0)    // Weighting (contribution to parent OKR)  weight            Float             @default(1) // à¸–à¹‰à¸²à¸—à¸¸à¸ KR à¹€à¸—à¹ˆà¸²à¸à¸±à¸™ à¹ƒà¸«à¹‰ 1    // Ownership  ownerUserId       String?  ownerUser         User?             @relation(fields: [ownerUserId], references: [id], onDelete: SetNull)    // Due date (can be before OKR cycle end)  dueDate           DateTime?    // Status  status            KeyResultStatus   @default(NOT_STARTED)    // Confidence  confidence        ConfidenceLevel?  @default(MEDIUM)    // Health  healthStatus      HealthStatus?    // Grading  finalScore        Float?  grade             OKRGrade?    // Metadata  displayOrder      Int               @default(0)  tags              String[]    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt    // Relations  updates           KeyResultUpdate[]    @@index([okrId])  @@index([ownerUserId])  @@index([status])  @@map("key_results")}// Add to User model:// keyResults KeyResult[]// ============================================================================// SECTION 42: KEY RESULT UPDATES// ============================================================================model KeyResultUpdate {  id                String            @id @default(cuid())    keyResultId       String  keyResult         KeyResult         @relation(fields: [keyResultId], references: [id], onDelete: Cascade)    // Update details  previousValue     Float?  newValue          Float    progressChange    Float?            // Change in percentage    // For milestone type  completedSteps    Int?    // Comments  updateNote        String?           @db.Text    // Challenges & Actions  challenges        String?           @db.Text  nextActions       String?           @db.Text    // Confidence adjustment  previousConfidence ConfidenceLevel?  newConfidence     ConfidenceLevel?    // Who updated  updatedBy         String  updatedByUser     User              @relation(fields: [updatedBy], references: [id], onDelete: Cascade)    // When  updateDate        DateTime          @default(now())    createdAt         DateTime          @default(now())    @@index([keyResultId, updateDate])  @@index([updatedBy])  @@map("key_result_updates")}// Add to User model:// keyResultUpdates KeyResultUpdate[]// ============================================================================// SECTION 43: OKR CHECK-INS// ============================================================================enum CheckInStatus {  DRAFT  SUBMITTED  REVIEWED  OVERDUE}model OKRCheckIn {  id                String            @id @default(cuid())    okrId             String  okr               OKR               @relation(fields: [okrId], references: [id], onDelete: Cascade)    // Check-in period  checkInDate       DateTime          @default(now())  weekNumber        Int?              // Week of the cycle    // Overall progress  overallProgress   Float             // 0-100  progressChange    Float?            // Change since last check-in    // Status & Health  status            CheckInStatus     @default(DRAFT)  healthStatus      HealthStatus  confidence        ConfidenceLevel    // Narrative  accomplishments   String?           @db.Text // à¸ªà¸´à¹ˆà¸‡à¸—à¸µà¹ˆà¸—à¸³à¸ªà¸³à¹€à¸£à¹‡à¸ˆ  challenges        String?           @db.Text // à¸­à¸¸à¸›à¸ªà¸£à¸£à¸„  nextSteps         String?           @db.Text // à¹à¸œà¸™à¸•à¹ˆà¸­à¹„à¸›  helpNeeded        String?           @db.Text // à¸„à¸§à¸²à¸¡à¸Šà¹ˆà¸§à¸¢à¹€à¸«à¸¥à¸·à¸­à¸—à¸µà¹ˆà¸•à¹‰à¸­à¸‡à¸à¸²à¸£    // Key Results snapshot (JSON)  keyResultsSnapshot Json?            // Snapshot of all KR values at check-in    // Mood/Sentiment  mood              CheckInMood?    // Submitted by  submittedBy       String  submittedByUser   User              @relation("CheckInSubmitter", fields: [submittedBy], references: [id], onDelete: Cascade)  submittedAt       DateTime?    // Reviewed by (manager/supervisor)  reviewedBy        String?  reviewer          User?             @relation("CheckInReviewer", fields: [reviewedBy], references: [id], onDelete: SetNull)  reviewedAt        DateTime?  reviewNotes       String?           @db.Text    // Metadata  isLate            Boolean           @default(false)    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt    @@index([okrId, checkInDate])  @@index([submittedBy])  @@index([healthStatus])  @@map("okr_check_ins")}// Add to User model:// submittedCheckIns OKRCheckIn[] @relation("CheckInSubmitter")// reviewedCheckIns OKRCheckIn[] @relation("CheckInReviewer")enum CheckInMood {  GREAT             // ğŸ˜Š Great  GOOD              // ğŸ™‚ Good  OKAY              // ğŸ˜ Okay  CONCERNED         // ğŸ˜Ÿ Concerned  STRESSED          // ğŸ˜° Stressed}// ============================================================================// SECTION 44: OKR ALIGNMENT// ============================================================================enum AlignmentType {  SUPPORTS          // à¸ªà¸™à¸±à¸šà¸ªà¸™à¸¸à¸™  DEPENDS_ON        // à¸à¸¶à¹ˆà¸‡à¸à¸²  INFLUENCES        // à¸¡à¸µà¸­à¸´à¸—à¸˜à¸´à¸à¸¥  BLOCKS            // à¸‚à¸±à¸”à¸‚à¸§à¸²à¸‡ (negative)}model OKRAlignment {  id                String            @id @default(cuid())    sourceOKRId       String  sourceOKR         OKR               @relation("SourceOKR", fields: [sourceOKRId], references: [id], onDelete: Cascade)    targetOKRId       String  targetOKR         OKR               @relation("TargetOKR", fields: [targetOKRId], references: [id], onDelete: Cascade)    // Alignment type  alignmentType     AlignmentType    // Strength (0-1)  alignmentStrength Float?            @default(0.5)    // Description  description       String?           @db.Text    // Validation  isVerified        Boolean           @default(false)  verifiedBy        String?  verifiedAt        DateTime?    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt    @@unique([sourceOKRId, targetOKRId])  @@index([sourceOKRId])  @@index([targetOKRId])  @@map("okr_alignments")}// ============================================================================// SECTION 45: OKR COMMENTS (Conversations)// ============================================================================model OKRComment {  id                String            @id @default(cuid())    okrId             String  okr               OKR               @relation(fields: [okrId], references: [id], onDelete: Cascade)    // Comment content  commentText       String            @db.Text    // Thread (for replies)  parentCommentId   String?  parentComment     OKRComment?       @relation("CommentThread", fields: [parentCommentId], references: [id], onDelete: Cascade)  replies           OKRComment[]      @relation("CommentThread")    // Author  authorId          String  author            User              @relation(fields: [authorId], references: [id], onDelete: Cascade)    // Type  commentType       CommentType       @default(COMMENT)    // Mentions  mentionedUsers    String[]          // Array of user IDs    // Reactions  reactions         Json?             // {emoji: count}    // Attachments  attachments       String[]          // Array of file URLs    // Edit tracking  isEdited          Boolean           @default(false)  editedAt          DateTime?    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt  deletedAt         DateTime?    @@index([okrId, createdAt])  @@index([authorId])  @@index([parentCommentId])  @@map("okr_comments")}// Add to User model:// okrComments OKRComment[]enum CommentType {  COMMENT           // à¸„à¸§à¸²à¸¡à¸„à¸´à¸”à¹€à¸«à¹‡à¸™à¸—à¸±à¹ˆà¸§à¹„à¸›  QUESTION          // à¸„à¸³à¸–à¸²à¸¡  SUGGESTION        // à¸‚à¹‰à¸­à¹€à¸ªà¸™à¸­à¹à¸™à¸°  CONCERN           // à¸„à¸§à¸²à¸¡à¸à¸±à¸‡à¸§à¸¥  PRAISE            // à¸Šà¸·à¹ˆà¸™à¸Šà¸¡  REQUEST           // à¸„à¸³à¸‚à¸­}// ============================================================================// SECTION 46: CFR - FEEDBACK// ============================================================================enum FeedbackType {  POSITIVE          // à¹€à¸Šà¸´à¸‡à¸šà¸§à¸  CONSTRUCTIVE      // à¹€à¸Šà¸´à¸‡à¸ªà¸£à¹‰à¸²à¸‡à¸ªà¸£à¸£à¸„à¹Œ  DEVELOPMENTAL     // à¹€à¸à¸·à¹ˆà¸­à¸à¸±à¸’à¸™à¸²  RECOGNITION       // à¸¢à¸à¸¢à¹ˆà¸­à¸‡à¸Šà¸¡à¹€à¸Šà¸¢}enum FeedbackStatus {  DRAFT  SENT  ACKNOWLEDGED  ARCHIVED}model OKRFeedback {  id                String            @id @default(cuid())    okrId             String?           // Optional: can be general feedback    // Feedback direction  fromUserId        String  fromUser          User              @relation("FeedbackGiver", fields: [fromUserId], references: [id], onDelete: Cascade)    toUserId          String  toUser            User              @relation("FeedbackReceiver", fields: [toUserId], references: [id], onDelete: Cascade)    // Feedback type  feedbackType      FeedbackType    // Content  feedbackTitle     String?  feedbackContent   String            @db.Text    // Context  relatedToOKR      Boolean           @default(true)  specificKeyResultId String?    // Actionable items  suggestedActions  Json?             // Array of suggested actions    // Privacy  isAnonymous       Boolean           @default(false)  isPrivate         Boolean           @default(false)    // Status  status            FeedbackStatus    @default(SENT)    // Acknowledgment  acknowledgedAt    DateTime?  acknowledgmentNote String?          @db.Text    // Sentiment (AI-analyzed)  sentimentScore    Float?            // -1 to 1    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt    @@index([fromUserId])  @@index([toUserId])  @@index([okrId])  @@map("okr_feedback")}// Add to User model:// givenFeedback OKRFeedback[] @relation("FeedbackGiver")// receivedFeedback OKRFeedback[] @relation("FeedbackReceiver")// ============================================================================// SECTION 47: CFR - RECOGNITION// ============================================================================enum RecognitionType {  SHOUTOUT          // Shout-out à¸—à¸±à¹ˆà¸§à¹„à¸›  ACHIEVEMENT       // à¸„à¸§à¸²à¸¡à¸ªà¸³à¹€à¸£à¹‡à¸ˆ  TEAMWORK          // à¸à¸²à¸£à¸—à¸³à¸‡à¸²à¸™à¹€à¸›à¹‡à¸™à¸—à¸µà¸¡  INNOVATION        // à¸™à¸§à¸±à¸•à¸à¸£à¸£à¸¡  LEADERSHIP        // à¸ à¸²à¸§à¸°à¸œà¸¹à¹‰à¸™à¸³  CUSTOMER_FOCUS    // à¸¡à¸¸à¹ˆà¸‡à¸¥à¸¹à¸à¸„à¹‰à¸²  EXCELLENCE        // à¸„à¸§à¸²à¸¡à¹€à¸›à¹‡à¸™à¹€à¸¥à¸´à¸¨}model OKRRecognition {  id                String            @id @default(cuid())    okrId             String?    // Recognition details  recognitionType   RecognitionType  recognitionTitle  String  recognitionMessage String           @db.Text    // Giver  fromUserId        String  fromUser          User              @relation("RecognitionGiver", fields: [fromUserId], references: [id], onDelete: Cascade)    // Recipients (can be multiple)  toUserIds         String[]          // Array of user IDs    // Team recognition  toTeamId          String?    // Visibility  isPublic          Boolean           @default(true)    // Badges/Points (gamification)  badgeAwarded      String?  pointsAwarded     Int?              @default(0)    // Reactions  reactions         Json?             // {emoji: [userIds]}  viewCount         Int               @default(0)    // Featured  isFeatured        Boolean           @default(false)  featuredUntil     DateTime?    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt    @@index([fromUserId])  @@index([okrId])  @@index([createdAt])  @@map("okr_recognitions")}// Add to User model:// givenRecognitions OKRRecognition[] @relation("RecognitionGiver")// ============================================================================// SECTION 48: OKR REVIEW MEETINGS// ============================================================================enum ReviewMeetingType {  ONE_ON_ONE        // 1:1 meeting  TEAM_REVIEW       // Team OKR review  DEPARTMENT_REVIEW // Department review  ALL_HANDS         // All-hands meeting  MID_CYCLE         // Mid-cycle review  END_CYCLE         // End-of-cycle review}model OKRReviewMeeting {  id                String              @id @default(cuid())    cycleId           String    // Meeting details  meetingType       ReviewMeetingType  meetingTitle      String  meetingDescription String?           @db.Text    // Schedule  scheduledDate     DateTime  duration          Int?                // Minutes  location          String?  meetingUrl        String?             // For virtual meetings    // Participants  organizerId       String  organizer         User                @relation("MeetingOrganizer", fields: [organizerId], references: [id], onDelete: Cascade)    participantIds    String[]            // Array of user IDs    // Agenda  agendaItems       Json?               // Array of agenda items    // OKRs to review  okrIds            String[]            // Array of OKR IDs    // Meeting notes  meetingNotes      String?             @db.Text  actionItems       Json?               // Array of action items  decisions         Json?               // Array of decisions made    // Recording  recordingUrl      String?    // Status  status            MeetingStatus       @default(SCHEDULED)    // Completion  completedAt       DateTime?    createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt    @@index([cycleId])  @@index([organizerId])  @@index([scheduledDate])  @@map("okr_review_meetings")}// Add to User model:// organizedMeetings OKRReviewMeeting[] @relation("MeetingOrganizer")enum MeetingStatus {  SCHEDULED  IN_PROGRESS  COMPLETED  CANCELLED  RESCHEDULED}// ============================================================================// SECTION 49: OKR TEMPLATES// ============================================================================enum OKRTemplateCategory {  GROWTH            // à¸à¸²à¸£à¹€à¸•à¸´à¸šà¹‚à¸•  INNOVATION        // à¸™à¸§à¸±à¸•à¸à¸£à¸£à¸¡  EFFICIENCY        // à¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸ à¸²à¸  QUALITY           // à¸„à¸¸à¸“à¸ à¸²à¸  CUSTOMER          // à¸¥à¸¹à¸à¸„à¹‰à¸²  TEAM              // à¸—à¸µà¸¡  PERSONAL          // à¸ªà¹ˆà¸§à¸™à¸šà¸¸à¸„à¸„à¸¥  LEADERSHIP        // à¸ à¸²à¸§à¸°à¸œà¸¹à¹‰à¸™à¸³  GENERAL           // à¸—à¸±à¹ˆà¸§à¹„à¸›}model OKRTemplate {  id                String              @id @default(cuid())    // Template details  templateName      String  templateDescription String?          @db.Text    // Category  category          OKRTemplateCategory    // Objective template  objectiveTemplate String              @db.Text    // Key Results templates (JSON array)  keyResultTemplates Json               // Array of KR templates    // Best practices  bestPractices     String?             @db.Text  examples          String?             @db.Text    // Suitable for  suitableFor       OKRType[]           // Array of OKR types    // Usage  timesUsed         Int                 @default(0)    // Visibility  isPublic          Boolean             @default(true)    // Creator  createdBy         String?    createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt    @@index([category])  @@map("okr_templates")}// ============================================================================// SECTION 50: OKR ANALYTICS// ============================================================================model OKRAnalytics {  id                String              @id @default(cuid())    cycleId           String              @unique    // Overall statistics  totalOKRs         Int  activeOKRs        Int  completedOKRs     Int  cancelledOKRs     Int    // By type  companyOKRs       Int  departmentOKRs    Int  teamOKRs          Int  individualOKRs    Int    // Progress statistics  averageProgress   Float  medianProgress    Float    // Grading distribution  exceedsCount      Int                 @default(0)  achievesCount     Int                 @default(0)  partiallyCount    Int                 @default(0)  notAchievedCount  Int                 @default(0)    // Health distribution  onTrackCount      Int                 @default(0)  atRiskCount       Int                 @default(0)  behindCount       Int                 @default(0)    // Engagement metrics  checkInRate       Float?              // % of expected check-ins completed  commentCount      Int                 @default(0)  feedbackCount     Int                 @default(0)  recognitionCount  Int                 @default(0)    // Alignment metrics  alignmentScore    Float?              // 0-100  cascadingDepth    Int?                // Max depth of cascading    // Calculated at  calculatedAt      DateTime            @default(now())    @@index([cycleId])  @@map("okr_analytics")}// ============================================================================// SECTION 51: OKR NOTIFICATIONS// ============================================================================enum OKRNotificationType {  CHECK_IN_DUE  CHECK_IN_OVERDUE  OKR_AT_RISK  OKR_APPROVED  OKR_REJECTED  COMMENT_MENTION  FEEDBACK_RECEIVED  RECOGNITION_RECEIVED  REVIEW_MEETING_SCHEDULED  CYCLE_STARTING  CYCLE_ENDING  KEY_RESULT_UPDATED}model OKRNotification {  id                String                @id @default(cuid())    userId            String    // Notification details  notificationType  OKRNotificationType  title             String  message           String                @db.Text    // Related entities  okrId             String?  keyResultId       String?  checkInId         String?  commentId         String?    // Action URL  actionUrl         String?    // Status  isRead            Boolean               @default(false)  readAt            DateTime?    // Priority  priority          NotificationPriority  @default(MEDIUM)    // Delivery  sentVia           String[]              // ["email", "in-app", "push"]    createdAt         DateTime              @default(now())  expiresAt         DateTime?    @@index([userId, isRead])  @@index([notificationType])  @@index([createdAt])  @@map("okr_notifications")}```---ğŸŒ± Step 2: Seed Data for OKR System```typescript// prisma/seed-okr.tsimport { PrismaClient, CycleType, OKRType, KeyResultType, AlignmentType } from '@prisma/client'const prisma = new PrismaClient()async function seedOKR() {  console.log('ğŸ¯ Seeding OKR System...')  const niems = await prisma.organization.findUnique({ where: { code: 'NIEMS' } })  if (!niems) throw new Error('NIEMS not found')  const admin = await prisma.user.findUnique({ where: { email: 'admin@niems.go.th' } })  const planner = await prisma.user.findUnique({ where: { email: 'planner@niems.go.th' } })  const manager = await prisma.user.findUnique({ where: { email: 'manager@niems.go.th' } })  // Get team  const team = await prisma.team.findFirst({ where: { organizationId: niems.id } })  // Get department  const department = await prisma.department.findFirst({    where: { organizationId: niems.id },  })  // =========================================================================  // 1. Create OKR Cycle  // =========================================================================  const cycle = await prisma.oKRCycle.create({    data: {      organizationId: niems.id,      cycleName: 'Q2 2024',      cycleDescription: 'OKR à¹„à¸•à¸£à¸¡à¸²à¸ª 2 à¸›à¸µ 2024 (à¹€à¸¡à¸©à¸²à¸¢à¸™ - à¸¡à¸´à¸–à¸¸à¸™à¸²à¸¢à¸™)',      startDate: new Date('2024-04-01'),      endDate: new Date('2024-06-30'),      cycleType: CycleType.QUARTERLY,      status: 'ACTIVE',      allowSelfSetting: true,      requireApproval: true,      checkInFrequency: 'WEEKLY',      gradingScale: 'PERCENTAGE',      planningDeadline: new Date('2024-03-31'),      midCycleReview: new Date('2024-05-15'),      finalReviewDate: new Date('2024-07-07'),    },  })  console.log('âœ… Created OKR cycle:', cycle.cycleName)  // =========================================================================  // 2. Create Company-Level OKR  // =========================================================================  const companyOKR = await prisma.oKR.create({    data: {      cycleId: cycle.id,      organizationId: niems.id,      objectiveCode: 'O1',      objectiveTitle: 'à¸¢à¸à¸£à¸°à¸”à¸±à¸šà¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸ à¸²à¸à¸à¸²à¸£à¹ƒà¸«à¹‰à¸šà¸£à¸´à¸à¸²à¸£à¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œà¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸—à¸±à¹ˆà¸§à¸›à¸£à¸°à¹€à¸—à¸¨',      objectiveDescription: `à¹€à¸à¸·à¹ˆà¸­à¹ƒà¸«à¹‰à¸šà¸£à¸´à¸à¸²à¸£à¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œà¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸—à¸µà¹ˆà¸£à¸§à¸”à¹€à¸£à¹‡à¸§ à¸¡à¸µà¸„à¸¸à¸“à¸ à¸²à¸ à¹à¸¥à¸°à¸„à¸£à¸­à¸šà¸„à¸¥à¸¸à¸¡à¸—à¸±à¹ˆà¸§à¸–à¸¶à¸‡à¹‚à¸”à¸¢à¸¡à¸¸à¹ˆà¸‡à¹€à¸™à¹‰à¸™à¸à¸²à¸£à¹ƒà¸Šà¹‰à¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µà¹à¸¥à¸°à¸à¸²à¸£à¸à¸±à¸’à¸™à¸²à¸šà¸¸à¸„à¸¥à¸²à¸à¸£      `,      okrType: OKRType.COMPANY,      ownerUserId: admin!.id,      priority: 'CRITICAL',      isPublic: true,      visibilityLevel: 'ORGANIZATION',      progressPercentage: 45,      confidence: 'HIGH',      status: 'ACTIVE',      approvedAt: new Date('2024-03-25'),      approvedBy: admin!.id,    },  })  console.log('âœ… Created company OKR')  // Create Key Results for Company OKR  const companyKR1 = await prisma.keyResult.create({    data: {      okrId: companyOKR.id,      keyResultCode: 'KR1',      keyResultTitle: 'à¸¥à¸”à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¹€à¸‰à¸¥à¸µà¹ˆà¸¢à¸ˆà¸²à¸ 15 à¸™à¸²à¸—à¸µ à¹€à¸«à¸¥à¸·à¸­ 12 à¸™à¸²à¸—à¸µ',      keyResultType: KeyResultType.METRIC,      measurementUnit: 'à¸™à¸²à¸—à¸µ',      startValue: 15,      targetValue: 12,      currentValue: 13.5,      progressPercentage: 50, // (15-13.5)/(15-12) = 50%      weight: 1,      ownerUserId: planner!.id,      status: 'ON_TRACK',      confidence: 'MEDIUM',      healthStatus: 'HEALTHY',      displayOrder: 1,    },  })  const companyKR2 = await prisma.keyResult.create({    data: {      okrId: companyOKR.id,      keyResultCode: 'KR2',      keyResultTitle: 'à¹€à¸à¸´à¹ˆà¸¡à¸­à¸±à¸•à¸£à¸²à¸à¸²à¸£à¸£à¸­à¸”à¸Šà¸µà¸§à¸´à¸•à¸‚à¸­à¸‡à¸œà¸¹à¹‰à¸›à¹ˆà¸§à¸¢à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¹€à¸›à¹‡à¸™ 95%',      keyResultType: KeyResultType.METRIC,      measurementUnit: '%',      startValue: 92,      targetValue: 95,      currentValue: 93.5,      progressPercentage: 50, // (93.5-92)/(95-92) = 50%      weight: 1,      status: 'ON_TRACK',      confidence: 'MEDIUM',      healthStatus: 'HEALTHY',      displayOrder: 2,    },  })  const companyKR3 = await prisma.keyResult.create({    data: {      okrId: companyOKR.id,      keyResultCode: 'KR3',      keyResultTitle: 'à¸•à¸´à¸”à¸•à¸±à¹‰à¸‡à¸£à¸°à¸šà¸š AI Dispatch à¹ƒà¸™ 10 à¸ˆà¸±à¸‡à¸«à¸§à¸±à¸”à¸™à¸³à¸£à¹ˆà¸­à¸‡',      keyResultType: KeyResultType.MILESTONE,      milestoneSteps: {        steps: [          { id: 1, name: 'à¹€à¸¥à¸·à¸­à¸à¸ˆà¸±à¸‡à¸«à¸§à¸±à¸”à¸™à¸³à¸£à¹ˆà¸­à¸‡', completed: true },          { id: 2, name: 'à¸­à¸­à¸à¹à¸šà¸šà¸£à¸°à¸šà¸š', completed: true },          { id: 3, name: 'à¸à¸±à¸’à¸™à¸²à¸£à¸°à¸šà¸š', completed: true },          { id: 4, name: 'à¸—à¸”à¸ªà¸­à¸šà¸£à¸°à¸šà¸š', completed: false },          { id: 5, name: 'à¸•à¸´à¸”à¸•à¸±à¹‰à¸‡à¹à¸¥à¸°à¸à¸¶à¸à¸­à¸šà¸£à¸¡ 10 à¸ˆà¸±à¸‡à¸«à¸§à¸±à¸”', completed: false },        ],      },      completedSteps: 3,      totalSteps: 5,      progressPercentage: 60,      weight: 1,      status: 'ON_TRACK',      confidence: 'HIGH',      healthStatus: 'HEALTHY',      dueDate: new Date('2024-06-30'),      displayOrder: 3,    },  })  console.log('âœ… Created company Key Results')  // =========================================================================  // 3. Create Department-Level OKR (cascaded from company)  // =========================================================================  const deptOKR = await prisma.oKR.create({    data: {      cycleId: cycle.id,      organizationId: niems.id,      objectiveCode: 'O2',      objectiveTitle: 'à¸à¸±à¸’à¸™à¸²à¸£à¸°à¸šà¸šà¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µà¹€à¸à¸·à¹ˆà¸­à¸ªà¸™à¸±à¸šà¸ªà¸™à¸¸à¸™à¸à¸²à¸£à¹ƒà¸«à¹‰à¸šà¸£à¸´à¸à¸²à¸£ EMS',      objectiveDescription: 'à¸™à¸³à¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µ AI à¹à¸¥à¸° IoT à¸¡à¸²à¹ƒà¸Šà¹‰à¹ƒà¸™à¸à¸²à¸£à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡à¸£à¸°à¸šà¸šà¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œà¸‰à¸¸à¸à¹€à¸‰à¸´à¸™',      okrType: OKRType.DEPARTMENT,      parentOKRId: companyOKR.id,      ownerUserId: manager!.id,      ownerDepartmentId: department?.id,      priority: 'HIGH',      isPublic: true,      visibilityLevel: 'ORGANIZATION',      progressPercentage: 55,      confidence: 'HIGH',      status: 'ACTIVE',      approvedAt: new Date('2024-03-28'),      approvedBy: admin!.id,    },  })  console.log('âœ… Created department OKR')  // Create Key Results for Department OKR  await prisma.keyResult.create({    data: {      okrId: deptOKR.id,      keyResultCode: 'KR1',      keyResultTitle: 'à¸à¸±à¸’à¸™à¸²à¹à¸¥à¸°à¸—à¸”à¸ªà¸­à¸š AI Dispatch Algorithm à¹ƒà¸«à¹‰à¸¡à¸µà¸„à¸§à¸²à¸¡à¹à¸¡à¹ˆà¸™à¸¢à¸³ 90%',      keyResultType: KeyResultType.METRIC,      measurementUnit: '%',      startValue: 0,      targetValue: 90,      currentValue: 75,      progressPercentage: 83, // (75-0)/(90-0) = 83%      weight: 1,      ownerUserId: planner!.id,      status: 'ON_TRACK',      confidence: 'MEDIUM',      healthStatus: 'HEALTHY',      displayOrder: 1,    },  })  await prisma.keyResult.create({    data: {      okrId: deptOKR.id,      keyResultCode: 'KR2',      keyResultTitle: 'à¸•à¸´à¸”à¸•à¸±à¹‰à¸‡ IoT Sensors à¹ƒà¸™à¸£à¸–à¸à¸¢à¸²à¸šà¸²à¸¥ 50 à¸„à¸±à¸™',      keyResultType: KeyResultType.METRIC,      measurementUnit: 'à¸„à¸±à¸™',      startValue: 0,      targetValue: 50,      currentValue: 20,      progressPercentage: 40,      weight: 1,      status: 'AT_RISK',      confidence: 'LOW',      healthStatus: 'AT_RISK',      displayOrder: 2,    },  })  console.log('âœ… Created department Key Results')  // =========================================================================  // 4. Create Team-Level OKR (cascaded from department)  // =========================================================================  const teamOKR = await prisma.oKR.create({    data: {      cycleId: cycle.id,      organizationId: niems.id,      objectiveCode: 'O3',      objectiveTitle: 'à¸ªà¹ˆà¸‡à¸¡à¸­à¸š AI Dispatch System à¸—à¸µà¹ˆà¸à¸£à¹‰à¸­à¸¡à¹ƒà¸Šà¹‰à¸‡à¸²à¸™',      objectiveDescription: 'à¸à¸±à¸’à¸™à¸² AI system à¹ƒà¸«à¹‰à¸„à¸£à¸šà¸—à¸¸à¸ features à¹à¸¥à¸°à¸œà¹ˆà¸²à¸™à¸à¸²à¸£à¸—à¸”à¸ªà¸­à¸š',      okrType: OKRType.TEAM,      parentOKRId: deptOKR.id,      ownerUserId: planner!.id,      ownerTeamId: team?.id,      contributorIds: [manager!.id],      priority: 'HIGH',      isPublic: true,      visibilityLevel: 'ORGANIZATION',      progressPercentage: 60,      confidence: 'MEDIUM',      status: 'ACTIVE',      approvedAt: new Date('2024-03-30'),      approvedBy: manager!.id,    },  })  console.log('âœ… Created team OKR')  // Create Key Results for Team OKR  await prisma.keyResult.create({    data: {      okrId: teamOKR.id,      keyResultCode: 'KR1',      keyResultTitle: 'à¸—à¸”à¸ªà¸­à¸šà¸£à¸°à¸šà¸šà¸à¸±à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸ˆà¸£à¸´à¸‡ 10,000 cases à¹ƒà¸«à¹‰à¸œà¹ˆà¸²à¸™ accuracy > 90%',      keyResultType: KeyResultType.METRIC,      measurementUnit: 'cases',      startValue: 0,      targetValue: 10000,      currentValue: 6500,      progressPercentage: 65,      weight: 1,      ownerUserId: planner!.id,      status: 'ON_TRACK',      confidence: 'MEDIUM',      healthStatus: 'HEALTHY',      displayOrder: 1,    },  })  await prisma.keyResult.create({    data: {      okrId: teamOKR.id,      keyResultCode: 'KR2',      keyResultTitle: 'Integrate à¸à¸±à¸š 3 external systems (GPS, Hospital, Traffic)',      keyResultType: KeyResultType.MILESTONE,      milestoneSteps: {        steps: [          { id: 1, name: 'GPS API Integration', completed: true },          { id: 2, name: 'Hospital System Integration', completed: true },          { id: 3, name: 'Traffic Data Integration', completed: false },        ],      },      completedSteps: 2,      totalSteps: 3,      progressPercentage: 67,      weight: 1,      status: 'ON_TRACK',      confidence: 'HIGH',      healthStatus: 'HEALTHY',      displayOrder: 2,    },  })  console.log('âœ… Created team Key Results')  // =========================================================================  // 5. Create Individual OKR  // =========================================================================  const individualOKR = await prisma.oKR.create({    data: {      cycleId: cycle.id,      organizationId: niems.id,      objectiveCode: 'O4',      objectiveTitle: 'à¸à¸±à¸’à¸™à¸²à¸—à¸±à¸à¸©à¸° Machine Learning à¹à¸¥à¸° Leadership',      objectiveDescription: 'à¹€à¸à¸´à¹ˆà¸¡à¸„à¸§à¸²à¸¡à¹€à¸Šà¸µà¹ˆà¸¢à¸§à¸Šà¸²à¸à¸”à¹‰à¸²à¸™ ML à¹à¸¥à¸°à¸—à¸±à¸à¸©à¸°à¸à¸²à¸£à¹€à¸›à¹‡à¸™à¸œà¸¹à¹‰à¸™à¸³à¸—à¸µà¸¡',      okrType: OKRType.INDIVIDUAL,      parentOKRId: teamOKR.id,      ownerUserId: planner!.id,      priority: 'MEDIUM',      isPublic: true,      visibilityLevel: 'TEAM',      progressPercentage: 50,      confidence: 'HIGH',      status: 'ACTIVE',      approvedAt: new Date('2024-04-01'),      approvedBy: manager!.id,    },  })  console.log('âœ… Created individual OKR')  // Create Key Results for Individual OKR  await prisma.keyResult.create({    data: {      okrId: individualOKR.id,      keyResultCode: 'KR1',      keyResultTitle: 'Complete Advanced ML Course à¹à¸¥à¸°à¸—à¸³ capstone project',      keyResultType: KeyResultType.MILESTONE,      milestoneSteps: {        steps: [          { id: 1, name: 'Complete 10 modules', completed: true },          { id: 2, name: 'Submit capstone project', completed: false },          { id: 3, name: 'Present to team', completed: false },        ],      },      completedSteps: 1,      totalSteps: 3,      progressPercentage: 33,      weight: 1,      ownerUserId: planner!.id,      status: 'ON_TRACK',      confidence: 'HIGH',      displayOrder: 1,    },  })  await prisma.keyResult.create({    data: {      okrId: individualOKR.id,      keyResultCode: 'KR2',      keyResultTitle: 'Lead 2 team workshops à¹à¸¥à¸°à¹„à¸”à¹‰à¸„à¸°à¹à¸™à¸™à¸„à¸§à¸²à¸¡à¸à¸¶à¸‡à¸à¸­à¹ƒà¸ˆ > 4.5/5',      keyResultType: KeyResultType.METRIC,      measurementUnit: 'workshops',      startValue: 0,      targetValue: 2,      currentValue: 1,      progressPercentage: 50,      weight: 1,      status: 'ON_TRACK',      confidence: 'MEDIUM',      displayOrder: 2,    },  })  console.log('âœ… Created individual Key Results')  // =========================================================================  // 6. Create OKR Alignments  // =========================================================================  await prisma.oKRAlignment.create({    data: {      sourceOKRId: deptOKR.id,      targetOKRId: companyOKR.id,      alignmentType: AlignmentType.SUPPORTS,      alignmentStrength: 0.9,      description: 'Department OKR à¸ªà¸™à¸±à¸šà¸ªà¸™à¸¸à¸™ Company OKR à¹‚à¸”à¸¢à¸•à¸£à¸‡à¸œà¹ˆà¸²à¸™à¸à¸²à¸£à¸à¸±à¸’à¸™à¸²à¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µ',      isVerified: true,      verifiedBy: admin!.id,      verifiedAt: new Date(),    },  })  await prisma.oKRAlignment.create({    data: {      sourceOKRId: teamOKR.id,      targetOKRId: deptOKR.id,      alignmentType: AlignmentType.SUPPORTS,      alignmentStrength: 0.95,      description: 'Team OKR à¸ªà¹ˆà¸‡à¸¡à¸­à¸š system à¸—à¸µà¹ˆà¹ƒà¸Šà¹‰à¸šà¸£à¸£à¸¥à¸¸ Department OKR',      isVerified: true,      verifiedBy: manager!.id,      verifiedAt: new Date(),    },  })  console.log('âœ… Created OKR alignments')  // =========================================================================  // 7. Create Key Result Updates  // =========================================================================  await prisma.keyResultUpdate.create({    data: {      keyResultId: companyKR1.id,      previousValue: 14,      newValue: 13.5,      progressChange: 16.67,      updateNote: 'à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¹„à¸”à¹‰à¸”à¸µà¸‚à¸¶à¹‰à¸™à¸ˆà¸²à¸à¸à¸²à¸£à¸à¸¶à¸à¸­à¸šà¸£à¸¡ dispatcher',      challenges: 'à¸¢à¸±à¸‡à¸¡à¸µà¸›à¸±à¸à¸«à¸² traffic congestion à¹ƒà¸™à¸Šà¹ˆà¸§à¸‡ peak hours',      nextActions: 'à¸ˆà¸°à¸—à¸”à¸¥à¸­à¸‡à¹ƒà¸Šà¹‰ AI dispatch à¹ƒà¸™à¸à¸·à¹‰à¸™à¸—à¸µà¹ˆà¸™à¸³à¸£à¹ˆà¸­à¸‡ 2 à¸ˆà¸±à¸‡à¸«à¸§à¸±à¸”',      previousConfidence: 'MEDIUM',      newConfidence: 'MEDIUM',      updatedBy: planner!.id,      updateDate: new Date('2024-05-01'),    },  })  await prisma.keyResultUpdate.create({    data: {      keyResultId: companyKR2.id,      previousValue: 93,      newValue: 93.5,      progressChange: 16.67,      updateNote: 'à¸­à¸±à¸•à¸£à¸²à¸à¸²à¸£à¸£à¸­à¸”à¸Šà¸µà¸§à¸´à¸•à¹€à¸à¸´à¹ˆà¸¡à¸‚à¸¶à¹‰à¸™à¸ˆà¸²à¸à¸à¸²à¸£à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡à¹‚à¸›à¸£à¹‚à¸•à¸„à¸­à¸¥',      nextActions: 'à¸ˆà¸°à¹€à¸à¸´à¹ˆà¸¡à¸à¸²à¸£à¸à¸¶à¸à¸­à¸šà¸£à¸¡ Advanced Cardiac Life Support',      previousConfidence: 'MEDIUM',      newConfidence: 'MEDIUM',      updatedBy: planner!.id,      updateDate: new Date('2024-05-01'),    },  })  console.log('âœ… Created key result updates')  // =========================================================================  // 8. Create OKR Check-ins  // =========================================================================  await prisma.oKRCheckIn.create({    data: {      okrId: teamOKR.id,      checkInDate: new Date('2024-05-06'),      weekNumber: 5,      overallProgress: 60,      progressChange: 10,      status: 'SUBMITTED',      healthStatus: 'HEALTHY',      confidence: 'MEDIUM',      accomplishments: `à¸ªà¸±à¸›à¸”à¸²à¸«à¹Œà¸™à¸µà¹‰à¸—à¸³à¹„à¸”à¹‰:- à¸—à¸”à¸ªà¸­à¸š AI algorithm à¸à¸±à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸ˆà¸£à¸´à¸‡ 6,500 cases- Integrate à¸ªà¸³à¹€à¸£à¹‡à¸ˆà¸à¸±à¸š Hospital System API- Fix bugs 15 issues      `,      challenges: `à¸­à¸¸à¸›à¸ªà¸£à¸£à¸„:- Traffic Data API à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹€à¸ªà¸–à¸µà¸¢à¸£ à¸¡à¸µ downtime à¸šà¹ˆà¸­à¸¢- à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ training à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹€à¸à¸µà¸¢à¸‡à¸à¸­à¸ªà¸³à¸«à¸£à¸±à¸šà¸šà¸²à¸‡à¸ à¸¹à¸¡à¸´à¸ à¸²à¸„      `,      nextSteps: `à¸ªà¸±à¸›à¸”à¸²à¸«à¹Œà¸«à¸™à¹‰à¸²:- à¸ˆà¸°à¸—à¸”à¸ªà¸­à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹€à¸à¸´à¹ˆà¸¡à¸­à¸µà¸ 2,000 cases- à¸«à¸² alternative Traffic Data provider- à¹€à¸£à¸´à¹ˆà¸¡ integration à¸à¸±à¸š Traffic API      `,      helpNeeded: 'à¸•à¹‰à¸­à¸‡à¸à¸²à¸£ access à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ historical traffic à¸ˆà¸²à¸ DOH',      mood: 'GOOD',      keyResultsSnapshot: {        kr1: { current: 6500, target: 10000, progress: 65 },        kr2: { completed: 2, total: 3, progress: 67 },      },      submittedBy: planner!.id,      submittedAt: new Date('2024-05-06'),      reviewedBy: manager!.id,      reviewedAt: new Date('2024-05-07'),      reviewNotes: 'à¸„à¸§à¸²à¸¡à¸„à¸·à¸šà¸«à¸™à¹‰à¸²à¸”à¸µà¸¡à¸²à¸ à¸ˆà¸°à¸›à¸£à¸°à¸ªà¸²à¸™à¸‡à¸²à¸™ DOH à¹€à¸£à¸·à¹ˆà¸­à¸‡ traffic data à¹ƒà¸«à¹‰',    },  })  await prisma.oKRCheckIn.create({    data: {      okrId: individualOKR.id,      checkInDate: new Date('2024-05-13'),      weekNumber: 6,      overallProgress: 50,      progressChange: 15,      status: 'SUBMITTED',      healthStatus: 'HEALTHY',      confidence: 'HIGH',      accomplishments: `- à¹€à¸£à¸µà¸¢à¸™à¸ˆà¸š Module 10: Deep Learning for Time Series- à¹€à¸£à¸´à¹ˆà¸¡à¸—à¸³ capstone project: Predicting Emergency Demand- à¸ˆà¸±à¸” workshop à¹€à¸£à¸·à¹ˆà¸­à¸‡ "Introduction to ML for EMS"      `,      challenges: 'à¸¢à¸±à¸‡à¸«à¸²à¹€à¸§à¸¥à¸²à¸—à¸³ capstone project à¹„à¸”à¹‰à¹„à¸¡à¹ˆà¸¡à¸²à¸à¹€à¸—à¹ˆà¸²à¸—à¸µà¹ˆà¸„à¸§à¸£',      nextSteps: `- à¸ˆà¸°à¹ƒà¸Šà¹‰à¹€à¸§à¸¥à¸²à¸§à¸±à¸™à¸«à¸¢à¸¸à¸”à¸—à¸³ capstone project- à¹€à¸•à¸£à¸µà¸¢à¸¡ workshop à¸„à¸£à¸±à¹‰à¸‡à¸—à¸µà¹ˆ 2      `,      mood: 'GREAT',      submittedBy: planner!.id,      submittedAt: new Date('2024-05-13'),      reviewedBy: manager!.id,      reviewedAt: new Date('2024-05-14'),      reviewNotes: 'Great progress! Workshop à¹„à¸”à¹‰à¸£à¸±à¸š feedback à¸”à¸µà¸¡à¸²à¸',    },  })  console.log('âœ… Created check-ins')  // =========================================================================  // 9. Create OKR Comments  // =========================================================================  await prisma.oKRComment.create({    data: {      okrId: teamOKR.id,      commentText: 'à¸„à¸§à¸²à¸¡à¸„à¸·à¸šà¸«à¸™à¹‰à¸²à¸”à¸µà¸¡à¸²à¸! AI algorithm à¸—à¸³à¸‡à¸²à¸™à¹„à¸”à¹‰à¹à¸¡à¹ˆà¸™à¸¢à¸³à¸‚à¸¶à¹‰à¸™à¹€à¸£à¸·à¹ˆà¸­à¸¢à¹† ğŸ‘',      authorId: manager!.id,      commentType: 'PRAISE',      reactions: {        'ğŸ‘': 3,        'ğŸ‰': 2,      },    },  })  const comment1 = await prisma.oKRComment.create({    data: {      okrId: teamOKR.id,      commentText: 'à¸¡à¸µà¸„à¸³à¸–à¸²à¸¡à¹€à¸£à¸·à¹ˆà¸­à¸‡ Traffic API à¸„à¸·à¸­à¸ˆà¸°à¹ƒà¸Šà¹‰ provider à¹„à¸«à¸™à¸”à¸µà¸„à¸£à¸±à¸š?',      authorId: planner!.id,      commentType: 'QUESTION',      mentionedUsers: [manager!.id],    },  })  // Reply to comment  await prisma.oKRComment.create({    data: {      okrId: teamOKR.id,      parentCommentId: comment1.id,      commentText: 'à¹à¸™à¸°à¸™à¸³ Google Maps Platform à¸«à¸£à¸·à¸­ HERE Maps à¸„à¸£à¸±à¸š à¸¡à¸µ API à¸—à¸µà¹ˆ stable',      authorId: manager!.id,      commentType: 'COMMENT',    },  })  console.log('âœ… Created comments')  // =========================================================================  // 10. Create Feedback  // =========================================================================  await prisma.oKRFeedback.create({    data: {      okrId: individualOKR.id,      fromUserId: manager!.id,      toUserId: planner!.id,      feedbackType: 'POSITIVE',      feedbackTitle: 'Excellent Leadership in Workshop',      feedbackContent: `Your workshop on ML for EMS was fantastic! à¸Šà¸­à¸šà¸¡à¸²à¸à¸—à¸µà¹ˆà¸„à¸¸à¸“:1. à¸­à¸˜à¸´à¸šà¸²à¸¢à¹„à¸”à¹‰à¸Šà¸±à¸”à¹€à¸ˆà¸™ à¹€à¸‚à¹‰à¸²à¹ƒà¸ˆà¸‡à¹ˆà¸²à¸¢2. à¸¡à¸µ hands-on exercise à¸—à¸µà¹ˆà¹€à¸à¸µà¹ˆà¸¢à¸§à¸‚à¹‰à¸­à¸‡à¸à¸±à¸šà¸‡à¸²à¸™à¸ˆà¸£à¸´à¸‡3. à¸•à¸­à¸šà¸„à¸³à¸–à¸²à¸¡à¹„à¸”à¹‰à¸”à¸µ à¹à¸¥à¸°à¸¡à¸µ patienceTeam members à¹ƒà¸«à¹‰ feedback à¸§à¹ˆà¸²à¹€à¸›à¹‡à¸™à¸›à¸£à¸°à¹‚à¸¢à¸Šà¸™à¹Œà¸¡à¸²à¸ à¹à¸¥à¸°à¸­à¸¢à¸²à¸à¹ƒà¸«à¹‰à¸ˆà¸±à¸”à¸•à¹ˆà¸­à¹€à¸™à¸·à¹ˆà¸­à¸‡Keep up the great work! ğŸŒŸ      `,      relatedToOKR: true,      specificKeyResultId: individualOKR.id,      isAnonymous: false,      isPrivate: false,      status: 'SENT',      sentimentScore: 0.95,    },  })  await prisma.oKRFeedback.create({    data: {      okrId: teamOKR.id,      fromUserId: admin!.id,      toUserId: planner!.id,      feedbackType: 'CONSTRUCTIVE',      feedbackTitle: 'Communication with Stakeholders',      feedbackContent: `à¸œà¸¡à¸ªà¸±à¸‡à¹€à¸à¸•à¸§à¹ˆà¸²à¸„à¸§à¸²à¸¡à¸„à¸·à¸šà¸«à¸™à¹‰à¸²à¸‚à¸­à¸‡à¹‚à¸›à¸£à¹€à¸ˆà¸„à¸”à¸µà¸¡à¸²à¸ à¹à¸•à¹ˆà¸­à¸¢à¸²à¸à¹à¸™à¸°à¸™à¸³à¹ƒà¸«à¹‰:1. Update stakeholders à¸šà¹ˆà¸­à¸¢à¸‚à¸¶à¹‰à¸™ à¹‚à¸”à¸¢à¹€à¸‰à¸à¸²à¸°à¹€à¸¡à¸·à¹ˆà¸­à¸¡à¸µà¸›à¸±à¸à¸«à¸²2. à¹€à¸•à¸£à¸µà¸¢à¸¡ demo version à¹ƒà¸«à¹‰ stakeholders à¸—à¸”à¸¥à¸­à¸‡à¹ƒà¸Šà¹‰à¹€à¸£à¹‡à¸§à¹†3. à¸ˆà¸±à¸”à¸—à¸³ documentation à¸ªà¸³à¸«à¸£à¸±à¸š end users à¸„à¸§à¸šà¸„à¸¹à¹ˆà¹„à¸›à¸”à¹‰à¸§à¸¢à¸–à¹‰à¸²à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸„à¸§à¸²à¸¡à¸Šà¹ˆà¸§à¸¢à¹€à¸«à¸¥à¸·à¸­à¹ƒà¸™à¸à¸²à¸£à¸›à¸£à¸°à¸ªà¸²à¸™à¸‡à¸²à¸™ à¸šà¸­à¸à¹„à¸”à¹‰à¹€à¸¥à¸¢à¸™à¸°à¸„à¸£à¸±à¸š      `,      relatedToOKR: true,      suggestedActions: {        actions: [          'Schedule bi-weekly stakeholder meetings',          'Prepare beta version for user testing',          'Assign someone to work on documentation',        ],      },      isAnonymous: false,      isPrivate: true,      status: 'SENT',      sentimentScore: 0.6,    },  })  console.log('âœ… Created feedback')  // =========================================================================  // 11. Create Recognition  // =========================================================================  await prisma.oKRRecognition.create({    data: {      okrId: teamOKR.id,      recognitionType: 'ACHIEVEMENT',      recognitionTitle: 'ğŸ‰ Milestone Achievement: AI Accuracy > 90%',      recognitionMessage: `à¸‚à¸­à¹à¸ªà¸”à¸‡à¸„à¸§à¸²à¸¡à¸¢à¸´à¸™à¸”à¸µà¸à¸±à¸šà¸—à¸µà¸¡ AI Development! à¸—à¸µà¸¡à¸ªà¸²à¸¡à¸²à¸£à¸–à¸à¸±à¸’à¸™à¸² AI Dispatch Algorithm à¹ƒà¸«à¹‰à¸¡à¸µà¸„à¸§à¸²à¸¡à¹à¸¡à¹ˆà¸™à¸¢à¸³ 90.2% à¹„à¸”à¹‰à¸ªà¸³à¹€à¸£à¹‡à¸ˆà¸‹à¸¶à¹ˆà¸‡à¹€à¸à¸´à¸™à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢à¸—à¸µà¹ˆà¸•à¸±à¹‰à¸‡à¹„à¸§à¹‰!à¸™à¸µà¹ˆà¸„à¸·à¸­à¸„à¸§à¸²à¸¡à¸ªà¸³à¹€à¸£à¹‡à¸ˆà¸—à¸µà¹ˆà¸ªà¸³à¸„à¸±à¸ à¹à¸¥à¸°à¸ˆà¸°à¸Šà¹ˆà¸§à¸¢à¹ƒà¸«à¹‰à¹€à¸£à¸²à¸ªà¸²à¸¡à¸²à¸£à¸– deploy à¸£à¸°à¸šà¸šà¹„à¸”à¹‰à¹€à¸£à¹‡à¸§à¸‚à¸¶à¹‰à¸™Kudos to the entire team! ğŸš€ğŸ‘      `,      fromUserId: admin!.id,      toUserIds: [planner!.id, manager!.id],      toTeamId: team?.id,      isPublic: true,      badgeAwarded: 'Innovator',      pointsAwarded: 100,      reactions: {        'ğŸ‰': [admin!.id, manager!.id],        'ğŸ‘': [admin!.id],        'ğŸš€': [manager!.id],      },      viewCount: 25,      isFeatured: true,      featuredUntil: new Date('2024-05-31'),    },  })  await prisma.oKRRecognition.create({    data: {      recognitionType: 'TEAMWORK',      recognitionTitle: 'ğŸ¤ Outstanding Collaboration',      recognitionMessage: `Shout-out to @planner and @manager for excellent collaboration!à¸à¸²à¸£à¸—à¸³à¸‡à¸²à¸™à¸£à¹ˆà¸§à¸¡à¸à¸±à¸™à¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡ Tech Team à¹à¸¥à¸° Operations Team à¸¥à¸‡à¸•à¸±à¸§à¸¡à¸²à¸à¸¡à¸µà¸à¸²à¸£à¸ªà¸·à¹ˆà¸­à¸ªà¸²à¸£à¸—à¸µà¹ˆà¸Šà¸±à¸”à¹€à¸ˆà¸™ à¹à¸Šà¸£à¹Œà¸‚à¹‰à¸­à¸¡à¸¹à¸¥ à¹à¸¥à¸°à¸Šà¹ˆà¸§à¸¢à¹€à¸«à¸¥à¸·à¸­à¸à¸±à¸™à¸•à¸¥à¸­à¸”This is what great teamwork looks like! ğŸ’ª      `,      fromUserId: admin!.id,      toUserIds: [planner!.id, manager!.id],      isPublic: true,      pointsAwarded: 50,      reactions: {        'â¤ï¸': [admin!.id],        'ğŸ’ª': [planner!.id, manager!.id],      },      viewCount: 18,    },  })  console.log('âœ… Created recognitions')  // =========================================================================  // 12. Create Review Meeting  // =========================================================================  await prisma.oKRReviewMeeting.create({    data: {      cycleId: cycle.id,      meetingType: 'MID_CYCLE',      meetingTitle: 'Q2 2024 Mid-Cycle OKR Review',      meetingDescription: 'à¸—à¸šà¸—à¸§à¸™ OKRs à¸—à¸µà¹ˆà¸„à¸£à¸¶à¹ˆà¸‡à¹„à¸•à¸£à¸¡à¸²à¸ª à¸›à¸£à¸°à¹€à¸¡à¸´à¸™à¸„à¸§à¸²à¸¡à¸„à¸·à¸šà¸«à¸™à¹‰à¸² à¹à¸¥à¸°à¸›à¸£à¸±à¸šà¹à¸œà¸™',      scheduledDate: new Date('2024-05-15T14:00:00'),      duration: 120,      location: 'Conference Room A',      meetingUrl: 'https://meet.google.com/abc-defg-hij',      organizerId: admin!.id,      participantIds: [admin!.id, manager!.id, planner!.id],      okrIds: [companyOKR.id, deptOKR.id, teamOKR.id],      agendaItems: {        items: [          { id: 1, topic: 'Company OKR Review', duration: 30, presenter: 'CEO' },          { id: 2, topic: 'Department OKR Review', duration: 30, presenter: 'Department Head' },          { id: 3, topic: 'Team OKR Review', duration: 30, presenter: 'Team Lead' },          { id: 4, topic: 'Challenges & Support Needed', duration: 20, presenter: 'All' },          { id: 5, topic: 'Action Items', duration: 10, presenter: 'CEO' },        ],      },      meetingNotes: `**Key Takeaways:**- Overall progress: 55% (on track)- Company OKR: 45% progress, need to focus on response time- Department OKR: 55% progress, IoT installation behind schedule- Team OKR: 60% progress, AI development going well**Decisions:**1. Allocate additional budget for IoT sensors2. Prioritize Traffic API integration3. Schedule demo for stakeholders in June**Action Items:**- @admin: Approve additional budget request- @manager: Find alternative IoT sensor vendors- @planner: Prepare stakeholder demo      `,      actionItems: {        items: [          {            action: 'Approve additional budget for IoT sensors',            assignee: 'admin@niems.go.th',            deadline: '2024-05-20',            status: 'OPEN',          },          {            action: 'Research alternative IoT vendors',            assignee: 'manager@niems.go.th',            deadline: '2024-05-25',            status: 'OPEN',          },          {            action: 'Prepare stakeholder demo presentation',            assignee: 'planner@niems.go.th',            deadline: '2024-06-10',            status: 'OPEN',          },        ],      },      decisions: {        decisions: [          'Increase IoT sensor budget by 20%',          'Extend Traffic API integration deadline by 2 weeks',          'Add weekly stakeholder updates',        ],      },      status: 'COMPLETED',      completedAt: new Date('2024-05-15T16:00:00'),    },  })  console.log('âœ… Created review meeting')  // =========================================================================  // 13. Create OKR Templates  // =========================================================================  await prisma.oKRTemplate.create({    data: {      templateName: 'Improve Customer Satisfaction',      templateDescription: 'Template for improving customer/user satisfaction metrics',      category: 'CUSTOMER',      objectiveTemplate: 'Improve [customer/user] satisfaction and experience',      keyResultTemplates: {        keyResults: [          {            template: 'Increase customer satisfaction score from [X] to [Y]',            type: 'METRIC',            unit: 'score',          },          {            template: 'Reduce customer complaints by [X]%',            type: 'METRIC',            unit: '%',          },          {            template: 'Achieve Net Promoter Score (NPS) of [X]',            type: 'METRIC',            unit: 'score',          },        ],      },      bestPractices: `- Survey customers regularly- Track complaints and response times- Focus on root causes, not symptoms- Involve frontline staff in solutions      `,      examples: 'E.g., "Improve patient satisfaction from 4.2 to 4.5"',      suitableFor: [OKRType.COMPANY, OKRType.DEPARTMENT, OKRType.TEAM],      timesUsed: 0,      isPublic: true,    },  })  await prisma.oKRTemplate.create({    data: {      templateName: 'Launch New Product/Service',      templateDescription: 'Template for launching new products or services',      category: 'INNOVATION',      objectiveTemplate: 'Successfully launch [product/service name]',      keyResultTemplates: {        keyResults: [          {            template: 'Complete development and testing by [date]',            type: 'MILESTONE',          },          {            template: 'Achieve [X] users/customers in first [timeframe]',            type: 'METRIC',            unit: 'users',          },          {            template: 'Receive satisfaction rating of [X]/5 from early adopters',            type: 'METRIC',            unit: 'rating',          },        ],      },      bestPractices: `- Start with MVP (Minimum Viable Product)- Get early user feedback- Measure adoption and satisfaction- Iterate based on feedback      `,      suitableFor: [OKRType.COMPANY, OKRType.DEPARTMENT, OKRType.TEAM],      timesUsed: 0,      isPublic: true,    },  })  console.log('âœ… Created OKR templates')  // =========================================================================  // 14. Create OKR Analytics  // =========================================================================  await prisma.oKRAnalytics.create({    data: {      cycleId: cycle.id,      totalOKRs: 4,      activeOKRs: 4,      completedOKRs: 0,      cancelledOKRs: 0,      companyOKRs: 1,      departmentOKRs: 1,      teamOKRs: 1,      individualOKRs: 1,      averageProgress: 52.5, // (45+55+60+50)/4      medianProgress: 52.5,      exceedsCount: 0,      achievesCount: 0,      partiallyCount: 0,      notAchievedCount: 0,      onTrackCount: 3,      atRiskCount: 1,      behindCount: 0,      checkInRate: 87.5, // High check-in compliance      commentCount: 3,      feedbackCount: 2,      recognitionCount: 2,      alignmentScore: 92,      cascadingDepth: 4, // Company â†’ Dept â†’ Team â†’ Individual      calculatedAt: new Date(),    },  })  console.log('âœ… Created analytics')  // =========================================================================  // 15. Create OKR Notifications  // =========================================================================  await prisma.oKRNotification.create({    data: {      userId: planner!.id,      notificationType: 'CHECK_IN_DUE',      title: 'OKR Check-in Due',      message: 'Your weekly check-in for "à¸ªà¹ˆà¸‡à¸¡à¸­à¸š AI Dispatch System à¸—à¸µà¹ˆà¸à¸£à¹‰à¸­à¸¡à¹ƒà¸Šà¹‰à¸‡à¸²à¸™" is due today',      okrId: teamOKR.id,      actionUrl: `/okrs/${teamOKR.id}/check-in`,      priority: 'HIGH',      sentVia: ['email', 'in-app'],      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),    },  })  await prisma.oKRNotification.create({    data: {      userId: planner!.id,      notificationType: 'FEEDBACK_RECEIVED',      title: 'New Feedback Received',      message: 'You received positive feedback on your workshop from your manager',      okrId: individualOKR.id,      actionUrl: `/okrs/${individualOKR.id}/feedback`,      priority: 'MEDIUM',      sentVia: ['in-app', 'push'],    },  })  await prisma.oKRNotification.create({    data: {      userId: planner!.id,      notificationType: 'RECOGNITION_RECEIVED',      title: 'ğŸ‰ You were recognized!',      message: 'CEO recognized your team for achieving AI accuracy milestone',      okrId: teamOKR.id,      actionUrl: `/recognitions/${teamOKR.id}`,      priority: 'MEDIUM',      sentVia: ['in-app'],    },  })  console.log('âœ… Created notifications')  console.log('\nğŸ‰ OKR System seed completed!')}seedOKR()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })```---ğŸ“¦ Step 3: Update package.json```json{  "scripts": {    "db:seed-okr": "tsx prisma/seed-okr.ts",    "db:seed-all": "pnpm db:seed && pnpm db:seed-rbac && pnpm db:seed-tows-bsc && pnpm db:seed-projects && pnpm db:seed-kpi && pnpm db:seed-okr"  }}```---ğŸ” Step 4: Advanced OKR Queries```typescript// lib/queries/okr-queries.ts// 1. Get OKR Cascade Tree with full hierarchyexport async function getOKRCascadeTree(cycleId: string, rootOKRId?: string) {  const where = rootOKRId    ? { id: rootOKRId }    : { cycleId, parentOKRId: null } // Top-level OKRs  const okrs = await prisma.oKR.findMany({    where,    include: {      ownerUser: {        select: { id: true, fullName: true, avatar: true },      },      keyResults: {        include: {          ownerUser: {            select: { id: true, fullName: true },          },        },        orderBy: { displayOrder: 'asc' },      },      childOKRs: {        include: {          ownerUser: {            select: { id: true, fullName: true, avatar: true },          },          keyResults: true,          childOKRs: {            include: {              ownerUser: {                select: { id: true, fullName: true, avatar: true },              },              keyResults: true,              childOKRs: {                include: {                  ownerUser: {                    select: { id: true, fullName: true },                  },                  keyResults: true,                },              },            },          },        },      },    },  })  function buildTree(okr: any): any {    return {      id: okr.id,      title: okr.objectiveTitle,      type: okr.okrType,      owner: okr.ownerUser,      progress: okr.progressPercentage,      status: okr.status,      confidence: okr.confidence,      keyResults: okr.keyResults.map((kr: any) => ({        id: kr.id,        title: kr.keyResultTitle,        type: kr.keyResultType,        current: kr.currentValue,        target: kr.targetValue,        progress: kr.progressPercentage,        status: kr.status,      })),      children: okr.childOKRs.map(buildTree),    }  }  return okrs.map(buildTree)}// 2. Calculate OKR Progress (rollup from Key Results)export async function calculateOKRProgress(okrId: string) {  const okr = await prisma.oKR.findUnique({    where: { id: okrId },    include: {      keyResults: {        where: { status: { not: 'CANCELLED' } },      },    },  })  if (!okr || okr.keyResults.length === 0) return 0  // Weighted average  const totalWeight = okr.keyResults.reduce((sum, kr) => sum + kr.weight, 0)  const weightedProgress = okr.keyResults.reduce(    (sum, kr) => sum + kr.progressPercentage * kr.weight,    0  )  const progress = weightedProgress / totalWeight  // Update OKR  await prisma.oKR.update({    where: { id: okrId },    data: {      progressPercentage: progress,      updatedAt: new Date(),    },  })  // Recursively update parent  if (okr.parentOKRId) {    await calculateOKRProgress(okr.parentOKRId)  }  return progress}// 3. Get OKR Dashboard for Userexport async function getUserOKRDashboard(userId: string, cycleId: string) {  // OKRs owned by user  const ownedOKRs = await prisma.oKR.findMany({    where: {      cycleId,      ownerUserId: userId,      status: { in: ['ACTIVE', 'AT_RISK', 'ON_TRACK'] },    },    include: {      keyResults: {        include: {          updates: {            orderBy: { updateDate: 'desc' },            take: 1,          },        },      },      checkIns: {        orderBy: { checkInDate: 'desc' },        take: 1,      },    },  })  // OKRs where user is contributor  const contributedOKRs = await prisma.oKR.findMany({    where: {      cycleId,      contributorIds: { has: userId },      status: { in: ['ACTIVE', 'AT_RISK', 'ON_TRACK'] },    },    include: {      ownerUser: {        select: { id: true, fullName: true },      },      keyResults: true,    },  })  // Recent check-ins  const recentCheckIns = await prisma.oKRCheckIn.findMany({    where: {      submittedBy: userId,      okr: { cycleId },    },    include: {      okr: {        select: { id: true, objectiveTitle: true },      },    },    orderBy: { checkInDate: 'desc' },    take: 5,  })  // Pending feedback  const pendingFeedback = await prisma.oKRFeedback.findMany({    where: {      toUserId: userId,      status: 'SENT',    },    include: {      fromUser: {        select: { id: true, fullName: true, avatar: true },      },    },    orderBy: { createdAt: 'desc' },  })  // Recent recognitions  const recognitions = await prisma.oKRRecognition.findMany({    where: {      toUserIds: { has: userId },    },    include: {      fromUser: {        select: { id: true, fullName: true, avatar: true },      },    },    orderBy: { createdAt: 'desc' },    take: 5,  })  return {    ownedOKRs,    contributedOKRs,    recentCheckIns,    pendingFeedback,    recognitions,    stats: {      totalOKRs: ownedOKRs.length,      onTrack: ownedOKRs.filter((o) => o.status === 'ON_TRACK').length,      atRisk: ownedOKRs.filter((o) => o.status === 'AT_RISK').length,      averageProgress:        ownedOKRs.reduce((sum, o) => sum + o.progressPercentage, 0) / ownedOKRs.length,    },  }}// 4. Check-in compliance trackingexport async function getCheckInCompliance(cycleId: string) {  const cycle = await prisma.oKRCycle.findUnique({    where: { id: cycleId },    include: {      okrs: {        where: { status: 'ACTIVE' },        include: {          checkIns: true,          ownerUser: {            select: { id: true, fullName: true },          },        },      },    },  })  if (!cycle) return null  // Calculate expected check-ins  const startDate = cycle.startDate  const now = new Date()  const daysElapsed = Math.floor(    (now.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)  )  let expectedCheckIns = 0  switch (cycle.checkInFrequency) {    case 'WEEKLY':      expectedCheckIns = Math.floor(daysElapsed / 7)      break    case 'BIWEEKLY':      expectedCheckIns = Math.floor(daysElapsed / 14)      break    case 'MONTHLY':      expectedCheckIns = Math.floor(daysElapsed / 30)      break  }  const compliance = cycle.okrs.map((okr) => {    const actualCheckIns = okr.checkIns.length    const complianceRate =      expectedCheckIns > 0 ? (actualCheckIns / expectedCheckIns) * 100 : 100    return {      okrId: okr.id,      objective: okr.objectiveTitle,      owner: okr.ownerUser,      expectedCheckIns,      actualCheckIns,      complianceRate,      lastCheckIn: okr.checkIns[okr.checkIns.length - 1]?.checkInDate,      isOverdue:        okr.checkIns.length === 0 ||        (okr.checkIns[okr.checkIns.length - 1]?.checkInDate &&          new Date().getTime() -            okr.checkIns[okr.checkIns.length - 1].checkInDate.getTime() >            7 * 24 * 60 * 60 * 1000), // 7 days    }  })  return {    cycle: {      id: cycle.id,      name: cycle.cycleName,      checkInFrequency: cycle.checkInFrequency,    },    compliance,    overall: {      totalOKRs: cycle.okrs.length,      averageCompliance:        compliance.reduce((sum, c) => sum + c.complianceRate, 0) / compliance.length,      overdueCount: compliance.filter((c) => c.isOverdue).length,    },  }}// 5. OKR Alignment Mapexport async function getOKRAlignmentMap(cycleId: string) {  const alignments = await prisma.oKRAlignment.findMany({    where: {      sourceOKR: { cycleId },    },    include: {      sourceOKR: {        select: {          id: true,          objectiveTitle: true,          okrType: true,          ownerUser: { select: { fullName: true } },          progressPercentage: true,        },      },      targetOKR: {        select: {          id: true,          objectiveTitle: true,          okrType: true,          ownerUser: { select: { fullName: true } },          progressPercentage: true,        },      },    },  })  // Format for visualization (D3.js force-directed graph)  const nodes = new Map()  const links: any[] = []  alignments.forEach((alignment) => {    // Add nodes    if (!nodes.has(alignment.sourceOKRId)) {      nodes.set(alignment.sourceOKRId, {        id: alignment.sourceOKRId,        title: alignment.sourceOKR.objectiveTitle,        type: alignment.sourceOKR.okrType,        owner: alignment.sourceOKR.ownerUser.fullName,        progress: alignment.sourceOKR.progressPercentage,      })    }    if (!nodes.has(alignment.targetOKRId)) {      nodes.set(alignment.targetOKRId, {        id: alignment.targetOKRId,        title: alignment.targetOKR.objectiveTitle,        type: alignment.targetOKR.okrType,        owner: alignment.targetOKR.ownerUser.fullName,        progress: alignment.targetOKR.progressPercentage,      })    }    // Add link    links.push({      source: alignment.sourceOKRId,      target: alignment.targetOKRId,      type: alignment.alignmentType,      strength: alignment.alignmentStrength,      verified: alignment.isVerified,    })  })  return {    nodes: Array.from(nodes.values()),    links,  }}```---âœ… Complete System - Final SummaryğŸ¯ Full Database Schema (All 6 Phases) âœ…Phase 1: Foundation (Users, Orgs, SWOT, Delphi) âœ…Phase 2: RBAC & Audit Trail (7 Roles, Permissions) âœ…Phase 3: TOWS, BSC, Strategy Map, Hoshin Kanri âœ…Phase 4: Projects, Gantt, WBS, Risks âœ…Phase 5: Complete KPI System (Cascading, Benchmarking) âœ…Phase 6: Complete OKR System âœ…OKR Cycles & ObjectivesKey Results (3 types)4-Level CascadingWeekly Check-insOKR AlignmentCFR (Conversations, Feedback, Recognition)Review MeetingsTemplatesAnalyticsNotifications---ğŸš€ Final Steps```bash# Run complete seedpnpm db:seed-all# Or step by steppnpm db:seed           # Foundationpnpm db:seed-rbac      # RBACpnpm db:seed-tows-bsc  # Strategypnpm db:seed-projects  # Projectspnpm db:seed-kpi       # KPIpnpm db:seed-okr       # OKR# Open Prisma Studiopnpm db:studio```---ğŸ‰ What's Next?à¹€à¸£à¸²à¸¡à¸µ Complete Schema à¹à¸¥à¹‰à¸§! à¸—à¸³à¸­à¸°à¹„à¸£à¸•à¹ˆà¸­à¸”à¸µ:Generate tRPC API â†’ Complete CRUD + business logicBuild React UI â†’ Components, pages, dashboardsCreate ER Diagram â†’ Visual documentationAPI Documentation â†’ OpenAPI/SwaggerPerformance Optimization â†’ Indexes, cachingTesting Strategy â†’ Unit, integration testsà¸à¸£à¹‰à¸­à¸¡à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸ªà¹ˆà¸§à¸™à¹„à¸«à¸™à¸„à¸£à¸±à¸š? ğŸš€---ğŸ“ Database Schema - Part 7: Logical Framework Analysis (LFA/Logframe)à¸•à¹ˆà¸­à¸ˆà¸²à¸ Phase 6 à¹€à¸£à¸²à¸ˆà¸°à¹€à¸à¸´à¹ˆà¸¡ Logical Framework Analysis (LFA) à¹€à¸à¸·à¹ˆà¸­à¸à¸²à¸£à¸›à¸£à¸°à¹€à¸¡à¸´à¸™à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¹à¸¥à¸°à¹‚à¸›à¸£à¹à¸à¸£à¸¡à¸­à¸¢à¹ˆà¸²à¸‡à¹€à¸›à¹‡à¸™à¸£à¸°à¸šà¸š à¸•à¸²à¸¡à¸«à¸¥à¸±à¸à¸à¸²à¸£ Results-Based Management (RBM)---ğŸ“‹ Step 1: Logframe Schema```prisma// prisma/schema.prisma (continued from Part 6)// ============================================================================// SECTION 52: LOGICAL FRAMEWORK ANALYSIS (LFA/LOGFRAME)// ============================================================================enum LogframeLevel {  GOAL              // à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢à¸£à¸°à¸”à¸±à¸šà¸ªà¸¹à¸‡ (Impact)  PURPOSE           // à¸§à¸±à¸•à¸–à¸¸à¸›à¸£à¸°à¸ªà¸‡à¸„à¹Œ (Outcome)  OUTPUT            // à¸œà¸¥à¸œà¸¥à¸´à¸•  ACTIVITY          // à¸à¸´à¸ˆà¸à¸£à¸£à¸¡ (Input)}enum VerificationMethod {  SURVEY            // à¹à¸šà¸šà¸ªà¸­à¸šà¸–à¸²à¸¡  INTERVIEW         // à¸ªà¸±à¸¡à¸ à¸²à¸©à¸“à¹Œ  OBSERVATION       // à¸ªà¸±à¸‡à¹€à¸à¸•à¸à¸²à¸£à¸“à¹Œ  DOCUMENT_REVIEW   // à¸—à¸šà¸—à¸§à¸™à¹€à¸­à¸à¸ªà¸²à¸£  STATISTICAL_DATA  // à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸ªà¸–à¸´à¸•à¸´  MONITORING_REPORT // à¸£à¸²à¸¢à¸‡à¸²à¸™à¸•à¸´à¸”à¸•à¸²à¸¡  EVALUATION_REPORT // à¸£à¸²à¸¢à¸‡à¸²à¸™à¸›à¸£à¸°à¹€à¸¡à¸´à¸™à¸œà¸¥  FINANCIAL_REPORT  // à¸£à¸²à¸¢à¸‡à¸²à¸™à¸à¸²à¸£à¹€à¸‡à¸´à¸™  INSPECTION        // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š  DATABASE_QUERY    // Query à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥}enum AssumptionLevel {  CRITICAL          // à¸ªà¸³à¸„à¸±à¸à¸¡à¸²à¸  IMPORTANT         // à¸ªà¸³à¸„à¸±à¸  MODERATE          // à¸›à¸²à¸™à¸à¸¥à¸²à¸‡  MINOR             // à¹€à¸¥à¹‡à¸à¸™à¹‰à¸­à¸¢}model LogicalFramework {  id                String            @id @default(cuid())    // Associated with Project or Program  projectId         String?  project           Project?          @relation(fields: [projectId], references: [id], onDelete: Cascade)    organizationId    String  organization      Organization      @relation(fields: [organizationId], references: [id], onDelete: Cascade)    // Logframe details  logframeName      String  logframeDescription String?         @db.Text    // Program/Project info  programName       String  programDuration   String?           // "3 years", "2024-2027"  targetBeneficiaries String?         @db.Text    // Budget  totalBudget       Float?  fundingSource     String?    // Timeline  startDate         DateTime  endDate           DateTime    // Status  status            LogframeStatus    @default(DRAFT)    // Version control  version           String            @default("1.0")  previousVersionId String?    // Approval  approvedBy        String?  approvedAt        DateTime?    // Metadata  tags              String[]    createdAt         DateTime          @default(now())  updatedAt         DateTime          @updatedAt  createdById       String?    // Relations  elements          LogframeElement[]  reviews           LogframeReview[]    @@index([projectId])  @@index([organizationId])  @@index([status])  @@map("logical_frameworks")}// Add to Organization model:// logicalFrameworks LogicalFramework[]// Add to Project model:// logframe LogframeElement[] â†’ Already exists, update to:// logicalFramework LogicalFramework[]enum LogframeStatus {  DRAFT  UNDER_REVIEW  APPROVED  ACTIVE  COMPLETED  ARCHIVED}// ============================================================================// SECTION 53: LOGFRAME ELEMENTS (Hierarchy)// ============================================================================model LogframeElement {  id                String              @id @default(cuid())    logframeId        String  logframe          LogicalFramework    @relation(fields: [logframeId], references: [id], onDelete: Cascade)    // Hierarchy  level             LogframeLevel  parentElementId   String?  parentElement     LogframeElement?    @relation("LogframeHierarchy", fields: [parentElementId], references: [id], onDelete: SetNull)  childElements     LogframeElement[]   @relation("LogframeHierarchy")    // Narrative Summary (à¸„à¸­à¸¥à¸±à¸¡à¸™à¹Œà¸—à¸µà¹ˆ 1)  elementCode       String              // "G1", "P1", "O1.1", "A1.1.1"  narrativeSummary  String              @db.Text    // Objectively Verifiable Indicators (OVI) (à¸„à¸­à¸¥à¸±à¸¡à¸™à¹Œà¸—à¸µà¹ˆ 2)  indicators        LogframeIndicator[]    // Means of Verification (MOV) (à¸„à¸­à¸¥à¸±à¸¡à¸™à¹Œà¸—à¸µà¹ˆ 3)  meansOfVerification VerificationMethod[]  verificationDetails String?           @db.Text  verificationFrequency String?         // "Monthly", "Quarterly", "Annually"  responsibleForVerification String?    // Who collects/verifies data    // Assumptions & Risks (à¸„à¸­à¸¥à¸±à¸¡à¸™à¹Œà¸—à¸µà¹ˆ 4)  assumptions       LogframeAssumption[]    // Additional context  targetGroup       String?             @db.Text  geographicScope   String?    // Resources (for Activities)  budgetAllocated   Float?  humanResources    String?             @db.Text    // Timeline  startDate         DateTime?  endDate           DateTime?    // Progress tracking  progressStatus    ProgressStatus?  completionPercent Float?              @default(0)    // Metadata  displayOrder      Int                 @default(0)  notes             String?             @db.Text    createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt    @@unique([logframeId, elementCode])  @@index([logframeId, level])  @@index([parentElementId])  @@map("logframe_elements")}enum ProgressStatus {  NOT_STARTED  ON_TRACK  DELAYED  AT_RISK  COMPLETED  CANCELLED}// ============================================================================// SECTION 54: LOGFRAME INDICATORS (OVI)// ============================================================================enum IndicatorType {  QUANTITATIVE      // à¹€à¸Šà¸´à¸‡à¸›à¸£à¸´à¸¡à¸²à¸“  QUALITATIVE       // à¹€à¸Šà¸´à¸‡à¸„à¸¸à¸“à¸ à¸²à¸  COMPOSITE         // à¸£à¸§à¸¡}enum IndicatorCategory {  INPUT             // à¸›à¸±à¸ˆà¸ˆà¸±à¸¢à¸™à¸³à¹€à¸‚à¹‰à¸²  OUTPUT            // à¸œà¸¥à¸œà¸¥à¸´à¸•  OUTCOME           // à¸œà¸¥à¸¥à¸±à¸à¸˜à¹Œ  IMPACT            // à¸œà¸¥à¸à¸£à¸°à¸—à¸š  EFFICIENCY        // à¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸ à¸²à¸  EFFECTIVENESS     // à¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸œà¸¥  RELEVANCE         // à¸„à¸§à¸²à¸¡à¹€à¸à¸µà¹ˆà¸¢à¸§à¸‚à¹‰à¸­à¸‡  SUSTAINABILITY    // à¸„à¸§à¸²à¸¡à¸¢à¸±à¹ˆà¸‡à¸¢à¸·à¸™}model LogframeIndicator {  id                String              @id @default(cuid())    elementId         String  element           LogframeElement     @relation(fields: [elementId], references: [id], onDelete: Cascade)    // Indicator details  indicatorCode     String              // "G1.1", "P1.2"  indicatorName     String  indicatorDescription String?          @db.Text    // Type & Category  indicatorType     IndicatorType  indicatorCategory IndicatorCategory    // SMART criteria compliance  isSpecific        Boolean             @default(true)  isMeasurable      Boolean             @default(true)  isAchievable      Boolean             @default(true)  isRelevant        Boolean             @default(true)  isTimebound       Boolean             @default(true)    // Measurement  measurementUnit   String              // "%", "people", "units"  dataSource        String?             @db.Text  collectionMethod  VerificationMethod?    // Baseline (à¹€à¸ªà¹‰à¸™à¸à¸²à¸™)  baselineValue     Float?  baselineYear      Int?  baselineSource    String?             @db.Text    // Target (à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢)  targetValue       Float  targetYear        Int  targetJustification String?           @db.Text    // Milestones (à¸ˆà¸¸à¸”à¸à¹ˆà¸³à¸à¸¥à¸²à¸‡)  milestones        Json?               // [{year: 2024, target: 50}, {year: 2025, target: 75}]    // Current value  currentValue      Float?              @default(0)  lastMeasured      DateTime?    // Achievement  achievementRate   Float?              @default(0)    // Disaggregation (à¹à¸¢à¸à¸¢à¹ˆà¸­à¸¢)  disaggregation    Json?               // {gender: ["Male", "Female"], age: ["0-18", "19-60", "60+"]}    // Frequency  reportingFrequency ReportingFrequency @default(QUARTERLY)    // Responsible  responsibleUserId String?  responsibleUser   User?               @relation(fields: [responsibleUserId], references: [id], onDelete: SetNull)    // Status  isActive          Boolean             @default(true)    // Metadata  displayOrder      Int                 @default(0)    createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt    // Relations  measurements      IndicatorMeasurement[]    @@unique([elementId, indicatorCode])  @@index([elementId])  @@index([responsibleUserId])  @@map("logframe_indicators")}// Add to User model:// logframeIndicators LogframeIndicator[]// ============================================================================// SECTION 55: INDICATOR MEASUREMENTS// ============================================================================model IndicatorMeasurement {  id                String              @id @default(cuid())    indicatorId       String  indicator         LogframeIndicator   @relation(fields: [indicatorId], references: [id], onDelete: Cascade)    // Measurement details  measurementDate   DateTime  measurementPeriod String?             // "Q1 2024", "Jan-Mar 2024"    // Value  measuredValue     Float    // Disaggregated data (JSON)  disaggregatedData Json?               // {gender: {male: 45, female: 55}, age: {"0-18": 20, ...}}    // Variance analysis  variance          Float?              // Actual vs Target  variancePercent   Float?    // Qualitative assessment  qualitativeNotes  String?             @db.Text    // Data quality  dataQuality       DataQuality         @default(GOOD)  confidenceLevel   Int?                @default(5) // 1-5 scale    // Source & Method  dataSource        String?  collectionMethod  VerificationMethod?    // Verification  verifiedBy        String?  verifiedAt        DateTime?  isVerified        Boolean             @default(false)    // Supporting documents  attachments       String[]            // URLs to supporting docs    // Analysis  analysis          String?             @db.Text  challenges        String?             @db.Text  recommendations   String?             @db.Text    // Collected by  collectedBy       String  collectedByUser   User                @relation(fields: [collectedBy], references: [id], onDelete: Cascade)    createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt    @@index([indicatorId, measurementDate])  @@index([collectedBy])  @@map("indicator_measurements")}// Add to User model:// indicatorMeasurements IndicatorMeasurement[]// ============================================================================// SECTION 56: ASSUMPTIONS & RISKS// ============================================================================enum AssumptionStatus {  VALID             // à¸¢à¸±à¸‡à¹€à¸›à¹‡à¸™à¸ˆà¸£à¸´à¸‡  INVALID           // à¹„à¸¡à¹ˆà¹€à¸›à¹‡à¸™à¸ˆà¸£à¸´à¸‡à¹à¸¥à¹‰à¸§  UNCERTAIN         // à¹„à¸¡à¹ˆà¹à¸™à¹ˆà¹ƒà¸ˆ  MONITORING        // à¸à¸³à¸¥à¸±à¸‡à¸•à¸´à¸”à¸•à¸²à¸¡}model LogframeAssumption {  id                String              @id @default(cuid())    elementId         String  element           LogframeElement     @relation(fields: [elementId], references: [id], onDelete: Cascade)    // Assumption details  assumptionCode    String              // "A1", "A2"  assumptionText    String              @db.Text    // Classification  assumptionLevel   AssumptionLevel  category          AssumptionCategory    // If assumption fails  consequenceIfFalse String            @db.Text  likelihood        Float?              @default(0.5) // 0-1  impact            Float?              @default(0.5) // 0-1  riskScore         Float?              // likelihood Ã— impact    // Mitigation  mitigationStrategy String?           @db.Text  contingencyPlan   String?             @db.Text    // Monitoring  howToVerify       String?             @db.Text  verificationFrequency String?         // "Monthly", "Quarterly"    // Status  status            AssumptionStatus    @default(VALID)  lastChecked       DateTime?    // Responsible for monitoring  responsibleUserId String?  responsibleUser   User?               @relation(fields: [responsibleUserId], references: [id], onDelete: SetNull)    // History  statusHistory     Json?               // [{date, status, notes}]    createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt    @@unique([elementId, assumptionCode])  @@index([elementId])  @@index([status])  @@index([responsibleUserId])  @@map("logframe_assumptions")}// Add to User model:// logframeAssumptions LogframeAssumption[]enum AssumptionCategory {  POLITICAL         // à¸à¸²à¸£à¹€à¸¡à¸·à¸­à¸‡  ECONOMIC          // à¹€à¸¨à¸£à¸©à¸à¸à¸´à¸ˆ  SOCIAL            // à¸ªà¸±à¸‡à¸„à¸¡  TECHNICAL         // à¹€à¸—à¸„à¸™à¸´à¸„  ENVIRONMENTAL     // à¸ªà¸´à¹ˆà¸‡à¹à¸§à¸”à¸¥à¹‰à¸­à¸¡  LEGAL             // à¸à¸à¸«à¸¡à¸²à¸¢  INSTITUTIONAL     // à¸ªà¸–à¸²à¸šà¸±à¸™  STAKEHOLDER       // à¸œà¸¹à¹‰à¸¡à¸µà¸ªà¹ˆà¸§à¸™à¹„à¸”à¹‰à¸ªà¹ˆà¸§à¸™à¹€à¸ªà¸µà¸¢  RESOURCE          // à¸—à¸£à¸±à¸à¸¢à¸²à¸à¸£}// ============================================================================// SECTION 57: LOGFRAME REVIEWS & EVALUATIONS// ============================================================================enum ReviewType {  INCEPTION         // à¸•à¸­à¸™à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™  MID_TERM          // à¸à¸¶à¹ˆà¸‡à¸à¸¥à¸²à¸‡  FINAL             // à¸ªà¸´à¹‰à¸™à¸ªà¸¸à¸”  EX_POST           // à¸«à¸¥à¸±à¸‡à¸ªà¸´à¹‰à¸™à¸ªà¸¸à¸”  ANNUAL            // à¸›à¸£à¸°à¸ˆà¸³à¸›à¸µ  AD_HOC            // à¹€à¸‰à¸à¸²à¸°à¸à¸´à¸ˆ}enum EvaluationCriteria {  RELEVANCE         // à¸„à¸§à¸²à¸¡à¹€à¸à¸µà¹ˆà¸¢à¸§à¸‚à¹‰à¸­à¸‡  EFFECTIVENESS     // à¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸œà¸¥  EFFICIENCY        // à¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸ à¸²à¸  IMPACT            // à¸œà¸¥à¸à¸£à¸°à¸—à¸š  SUSTAINABILITY    // à¸„à¸§à¸²à¸¡à¸¢à¸±à¹ˆà¸‡à¸¢à¸·à¸™  COHERENCE         // à¸„à¸§à¸²à¸¡à¸ªà¸­à¸”à¸„à¸¥à¹‰à¸­à¸‡}model LogframeReview {  id                String              @id @default(cuid())    logframeId        String  logframe          LogicalFramework    @relation(fields: [logframeId], references: [id], onDelete: Cascade)    // Review details  reviewType        ReviewType  reviewTitle       String  reviewDescription String?             @db.Text    // Period covered  periodStart       DateTime  periodEnd         DateTime    // Review date  reviewDate        DateTime            @default(now())    // Evaluators  leadEvaluatorId   String  leadEvaluator     User                @relation("LeadEvaluator", fields: [leadEvaluatorId], references: [id], onDelete: Cascade)    teamMembers       String[]            // Array of user IDs    // External evaluators  externalEvaluators String?            @db.Text    // Evaluation criteria scores (1-5 scale)  relevanceScore    Float?  effectivenessScore Float?  efficiencyScore   Float?  impactScore       Float?  sustainabilityScore Float?  coherenceScore    Float?    overallScore      Float?              // Average    // Findings  executiveSummary  String?             @db.Text  keyFindings       Json?               // Array of findings    // Achievements  majorAchievements Json?               // Array of achievements    // Challenges  challenges        Json?               // Array of challenges    // Lessons learned  lessonsLearned    Json?               // Array of lessons    // Recommendations  recommendations   Json?               // Array of recommendations with priority    // Performance by level  goalAchievement   Float?              // % achievement at Goal level  purposeAchievement Float?             // % achievement at Purpose level  outputAchievement Float?              // % achievement at Output level  activityCompletion Float?             // % completion of Activities    // Budget performance  budgetUtilization Float?              // % of budget used  costEfficiency    String?             @db.Text    // Documents  fullReportUrl     String?  attachments       String[]            // Supporting documents    // Status  status            ReviewStatus        @default(DRAFT)    // Publication  isPublic          Boolean             @default(false)  publishedAt       DateTime?    createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt    @@index([logframeId])  @@index([reviewType])  @@index([reviewDate])  @@map("logframe_reviews")}// Add to User model:// leadEvaluations LogframeReview[] @relation("LeadEvaluator")enum ReviewStatus {  DRAFT  UNDER_REVIEW  FINAL  PUBLISHED}// ============================================================================// SECTION 58: THEORY OF CHANGE (TOC)// ============================================================================model TheoryOfChange {  id                String              @id @default(cuid())    logframeId        String              @unique  logframe          LogicalFramework    @relation(fields: [logframeId], references: [id], onDelete: Cascade)    // TOC narrative  problemStatement  String              @db.Text  desiredChange     String              @db.Text    // Causal pathway (JSON structure)  causalPathway     Json                // Nodes and links    // Key assumptions in TOC  keyAssumptions    String[]            @db.Text    // Context analysis  contextAnalysis   String?             @db.Text  stakeholderAnalysis String?           @db.Text    // Visual diagram URL  diagramUrl        String?    // Version  version           String              @default("1.0")    createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt    @@map("theory_of_changes")}// Add relation to LogicalFramework:// theoryOfChange TheoryOfChange?// ============================================================================// SECTION 59: RESULTS FRAMEWORK// ============================================================================model ResultsFramework {  id                String              @id @default(cuid())    organizationId    String    // Framework details  frameworkName     String  frameworkDescription String?          @db.Text    // Strategic alignment  linkedStrategyIds String[]            // TOWS strategies  linkedObjectiveIds String[]           // BSC objectives    // Timeline  startDate         DateTime  endDate           DateTime    // Results hierarchy (JSON)  resultsHierarchy  Json                // Tree structure of results    // Performance data  overallPerformance Float?             // 0-100    // Status  status            String              @default("ACTIVE")    createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt    // Relations  logframes         String[]            // Array of logframe IDs    @@index([organizationId])  @@map("results_frameworks")}// ============================================================================// SECTION 60: M&E (Monitoring & Evaluation) PLAN// ============================================================================model MEPlan {  id                String              @id @default(cuid())    logframeId        String              @unique  logframe          LogicalFramework    @relation(fields: [logframeId], references: [id], onDelete: Cascade)    // M&E approach  monitoringApproach String            @db.Text  evaluationApproach String            @db.Text    // Data collection  dataCollectionPlan Json?              // Methods, frequency, responsible    // Evaluation schedule (JSON)  evaluationSchedule Json?              // [{type, date, responsible}]    // Roles & Responsibilities  meTeamStructure   Json?               // Team members and roles    // Budget  meBudget          Float?    // Quality assurance  qualityAssurancePlan String?         @db.Text    // Data management  dataManagementPlan String?           @db.Text  dataProtectionPlan String?           @db.Text    // Reporting  reportingSchedule Json?               // [{type, frequency, audience}]  reportingTemplates String[]           // URLs to templates    // Capacity building  capacityBuildingPlan String?         @db.Text    // Learning & adaptation  learningPlan      String?             @db.Text  adaptationMechanism String?          @db.Text    createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt    @@map("me_plans")}// Add relation to LogicalFramework:// mePlan MEPlan?// ============================================================================// SECTION 61: IMPACT PATHWAYS// ============================================================================model ImpactPathway {  id                String              @id @default(cuid())    logframeId        String    // Pathway details  pathwayName       String  pathwayDescription String?           @db.Text    // Pathway structure (JSON)  pathwayStructure  Json                // Sequence: Input â†’ Activity â†’ Output â†’ Outcome â†’ Impact    // Critical success factors  successFactors    String[]            @db.Text    // Evidence sources  evidenceSources   Json?               // Links to supporting evidence    // Contribution analysis  contributionScore Float?              // How much this pathway contributes to impact    // Visualization  diagramUrl        String?    createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt    @@index([logframeId])  @@map("impact_pathways")}// ============================================================================// SECTION 62: BENEFICIARY TRACKING// ============================================================================enum BeneficiaryCategory {  DIRECT            // à¸œà¸¹à¹‰à¸£à¸±à¸šà¸›à¸£à¸°à¹‚à¸¢à¸Šà¸™à¹Œà¹‚à¸”à¸¢à¸•à¸£à¸‡  INDIRECT          // à¸œà¸¹à¹‰à¸£à¸±à¸šà¸›à¸£à¸°à¹‚à¸¢à¸Šà¸™à¹Œà¹‚à¸”à¸¢à¸­à¹‰à¸­à¸¡  TARGET            // à¸à¸¥à¸¸à¹ˆà¸¡à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢  VULNERABLE        // à¸à¸¥à¸¸à¹ˆà¸¡à¹€à¸›à¸£à¸²à¸°à¸šà¸²à¸‡}model Beneficiary {  id                String              @id @default(cuid())    logframeId        String    // Beneficiary details  beneficiaryType   String              // "Individual", "Household", "Community", "Organization"  category          BeneficiaryCategory    // Demographics (for individuals)  name              String?  gender            String?  ageGroup          String?  location          String?    // For groups/organizations  groupName         String?  groupSize         Int?    // Registration  registrationId    String?             @unique  registrationDate  DateTime            @default(now())    // Services received (JSON)  servicesReceived  Json?               // [{service, date, value}]    // Satisfaction  satisfactionScore Float?              // 1-5  feedback          String?             @db.Text    // Outcomes  outcomesAchieved  Json?               // Measurable outcomes    // Status  isActive          Boolean             @default(true)  exitDate          DateTime?  exitReason        String?    // Consent & Privacy  consentGiven      Boolean             @default(false)  consentDate       DateTime?    createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt    @@index([logframeId])  @@index([category])  @@index([registrationId])  @@map("beneficiaries")}// ============================================================================// SECTION 63: LOGFRAME TEMPLATES// ============================================================================model LogframeTemplate {  id                String              @id @default(cuid())    // Template details  templateName      String  templateDescription String?          @db.Text    // Sector/Domain  sector            String              // "Health", "Education", "Infrastructure"  programType       String?             // "Emergency Response", "Development", "Service Delivery"    // Template structure (JSON)  templateStructure Json                // Pre-defined hierarchy with placeholders    // Sample indicators  sampleIndicators  Json?               // Common indicators for this sector    // Typical assumptions  typicalAssumptions Json?              // Common assumptions    // Best practices  bestPractices     String?             @db.Text  guidelines        String?             @db.Text    // Usage  timesUsed         Int                 @default(0)    // Visibility  isPublic          Boolean             @default(true)    // Creator  createdBy         String?    createdAt         DateTime            @default(now())  updatedAt         DateTime            @updatedAt    @@index([sector])  @@map("logframe_templates")}```---ğŸŒ± Step 2: Seed Data for Logframe```typescript// prisma/seed-logframe.tsimport { PrismaClient, LogframeLevel, IndicatorType, IndicatorCategory, VerificationMethod, AssumptionLevel, AssumptionCategory } from '@prisma/client'const prisma = new PrismaClient()async function seedLogframe() {  console.log('ğŸ“ Seeding Logical Framework Analysis...')  const niems = await prisma.organization.findUnique({ where: { code: 'NIEMS' } })  if (!niems) throw new Error('NIEMS not found')  const admin = await prisma.user.findUnique({ where: { email: 'admin@niems.go.th' } })  const planner = await prisma.user.findUnique({ where: { email: 'planner@niems.go.th' } })  const project = await prisma.project.findFirst({    where: { projectCode: 'PRJ-2024-001' },  })  // =========================================================================  // 1. Create Logical Framework  // =========================================================================  const logframe = await prisma.logicalFramework.create({    data: {      projectId: project?.id,      organizationId: niems.id,      logframeName: 'à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¸à¸±à¸’à¸™à¸²à¸£à¸°à¸šà¸š EMS à¸”à¹‰à¸§à¸¢ AI à¹à¸¥à¸° IoT - Logical Framework',      logframeDescription: `Logframe à¸ªà¸³à¸«à¸£à¸±à¸šà¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¸à¸±à¸’à¸™à¸²à¸£à¸°à¸šà¸šà¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œà¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸”à¹‰à¸§à¸¢à¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µ AI à¹à¸¥à¸° IoTà¹€à¸à¸·à¹ˆà¸­à¸¢à¸à¸£à¸°à¸”à¸±à¸šà¸à¸²à¸£à¹ƒà¸«à¹‰à¸šà¸£à¸´à¸à¸²à¸£à¹à¸¥à¸°à¸¥à¸”à¸­à¸±à¸•à¸£à¸²à¸à¸²à¸£à¹€à¸ªà¸µà¸¢à¸Šà¸µà¸§à¸´à¸•à¸ˆà¸²à¸à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™      `,      programName: 'à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¸à¸±à¸’à¸™à¸²à¸£à¸°à¸šà¸š EMS à¸”à¹‰à¸§à¸¢ AI à¹à¸¥à¸° IoT',      programDuration: '12 à¹€à¸”à¸·à¸­à¸™ (2024)',      targetBeneficiaries: `- à¸œà¸¹à¹‰à¸›à¹ˆà¸§à¸¢à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸—à¸±à¹ˆà¸§à¸›à¸£à¸°à¹€à¸—à¸¨ (à¸›à¸£à¸°à¸¡à¸²à¸“ 2 à¸¥à¹‰à¸²à¸™à¸£à¸²à¸¢à¸•à¹ˆà¸­à¸›à¸µ)- à¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œà¸‰à¸¸à¸à¹€à¸‰à¸´à¸™ (15,000 à¸„à¸™)- à¹‚à¸£à¸‡à¸à¸¢à¸²à¸šà¸²à¸¥à¹ƒà¸™à¹€à¸„à¸£à¸·à¸­à¸‚à¹ˆà¸²à¸¢ (500 à¹à¸«à¹ˆà¸‡)      `,      totalBudget: 50000000,      fundingSource: 'à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“à¹à¸œà¹ˆà¸™à¸”à¸´à¸™',      startDate: new Date('2024-01-01'),      endDate: new Date('2024-12-31'),      status: 'ACTIVE',      version: '1.0',      approvedBy: admin!.id,      approvedAt: new Date('2023-12-15'),      createdById: planner!.id,    },  })  console.log('âœ… Created Logical Framework')  // =========================================================================  // 2. Create Logframe Elements - GOAL Level  // =========================================================================  const goal = await prisma.logframeElement.create({    data: {      logframeId: logframe.id,      level: LogframeLevel.GOAL,      elementCode: 'G1',      narrativeSummary: `**à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢à¸£à¸°à¸”à¸±à¸šà¸ªà¸¹à¸‡ (Goal/Impact):**à¸¥à¸”à¸­à¸±à¸•à¸£à¸²à¸à¸²à¸£à¹€à¸ªà¸µà¸¢à¸Šà¸µà¸§à¸´à¸•à¸ˆà¸²à¸à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¹à¸¥à¸°à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡à¸„à¸¸à¸“à¸ à¸²à¸à¸Šà¸µà¸§à¸´à¸•à¸‚à¸­à¸‡à¸›à¸£à¸°à¸Šà¸²à¸Šà¸™à¸—à¸±à¹ˆà¸§à¸›à¸£à¸°à¹€à¸—à¸¨      `,      meansOfVerification: [        VerificationMethod.STATISTICAL_DATA,        VerificationMethod.MONITORING_REPORT,      ],      verificationDetails: `- à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸ªà¸–à¸´à¸•à¸´à¸ªà¸²à¸˜à¸²à¸£à¸“à¸ªà¸¸à¸‚à¸ˆà¸²à¸ à¸ªà¸˜.- à¸£à¸²à¸¢à¸‡à¸²à¸™à¸à¸²à¸£à¹€à¸à¹‰à¸²à¸£à¸°à¸§à¸±à¸‡à¹‚à¸£à¸„à¹à¸¥à¸°à¸ à¸±à¸¢à¸ªà¸¸à¸‚à¸ à¸²à¸- à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸ˆà¸²à¸à¸—à¸°à¹€à¸šà¸µà¸¢à¸™à¸£à¸²à¸©à¸à¸£à¹Œ      `,      verificationFrequency: 'Annually',      responsibleForVerification: 'à¸à¸£à¸°à¸—à¸£à¸§à¸‡à¸ªà¸²à¸˜à¸²à¸£à¸“à¸ªà¸¸à¸‚',      targetGroup: 'à¸›à¸£à¸°à¸Šà¸²à¸Šà¸™à¸—à¸±à¹ˆà¸§à¸›à¸£à¸°à¹€à¸—à¸¨',      geographicScope: 'à¸—à¸±à¹ˆà¸§à¸›à¸£à¸°à¹€à¸—à¸¨ 77 à¸ˆà¸±à¸‡à¸«à¸§à¸±à¸”',      progressStatus: 'ON_TRACK',      completionPercent: 40,      displayOrder: 1,    },  })  // Goal Indicators  await prisma.logframeIndicator.create({    data: {      elementId: goal.id,      indicatorCode: 'G1.1',      indicatorName: 'à¸­à¸±à¸•à¸£à¸²à¸à¸²à¸£à¹€à¸ªà¸µà¸¢à¸Šà¸µà¸§à¸´à¸•à¸ˆà¸²à¸à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸•à¹ˆà¸­à¸›à¸£à¸°à¸Šà¸²à¸à¸£ 100,000 à¸„à¸™',      indicatorDescription: 'à¸§à¸±à¸”à¸­à¸±à¸•à¸£à¸²à¸à¸²à¸£à¹€à¸ªà¸µà¸¢à¸Šà¸µà¸§à¸´à¸•à¸ˆà¸²à¸à¹€à¸«à¸•à¸¸à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸—à¸¸à¸à¸›à¸£à¸°à¹€à¸ à¸—',      indicatorType: IndicatorType.QUANTITATIVE,      indicatorCategory: IndicatorCategory.IMPACT,      measurementUnit: 'à¸•à¹ˆà¸­ 100,000 à¸„à¸™',      dataSource: 'à¸—à¸°à¹€à¸šà¸µà¸¢à¸™à¸£à¸²à¸©à¸à¸£à¹Œ + à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ EMS',      collectionMethod: VerificationMethod.STATISTICAL_DATA,      baselineValue: 45,      baselineYear: 2023,      baselineSource: 'à¸à¸£à¸°à¸—à¸£à¸§à¸‡à¸ªà¸²à¸˜à¸²à¸£à¸“à¸ªà¸¸à¸‚ à¸£à¸²à¸¢à¸‡à¸²à¸™à¸›à¸£à¸°à¸ˆà¸³à¸›à¸µ 2023',      targetValue: 38,      targetYear: 2027,      targetJustification: 'à¸¥à¸”à¸¥à¸‡ 15% à¹ƒà¸™à¸£à¸°à¸¢à¸° 3 à¸›à¸µ à¸•à¸²à¸¡à¹à¸œà¸™à¸¢à¸¸à¸—à¸˜à¸¨à¸²à¸ªà¸•à¸£à¹Œ',      milestones: {        milestones: [          { year: 2024, target: 43, description: 'à¸›à¸µà¹à¸£à¸: à¸¥à¸” 5%' },          { year: 2025, target: 41, description: 'à¸›à¸µà¸—à¸µà¹ˆ 2: à¸¥à¸”à¹€à¸à¸´à¹ˆà¸¡ 5%' },          { year: 2026, target: 39, description: 'à¸›à¸µà¸—à¸µà¹ˆ 3: à¸¥à¸”à¹€à¸à¸´à¹ˆà¸¡ 5%' },          { year: 2027, target: 38, description: 'à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢à¸ªà¸¸à¸”à¸—à¹‰à¸²à¸¢' },        ],      },      currentValue: 43.5,      lastMeasured: new Date('2024-06-30'),      achievementRate: 25, // (45-43.5)/(45-38) = 21.4%      disaggregation: {        dimensions: {          gender: ['à¸Šà¸²à¸¢', 'à¸«à¸à¸´à¸‡'],          age: ['0-14', '15-59', '60+'],          region: ['à¸à¸£à¸¸à¸‡à¹€à¸—à¸à¸¯', 'à¸ à¸²à¸„à¹€à¸«à¸™à¸·à¸­', 'à¸ à¸²à¸„à¸•à¸°à¸§à¸±à¸™à¸­à¸­à¸à¹€à¸‰à¸µà¸¢à¸‡à¹€à¸«à¸™à¸·à¸­', 'à¸ à¸²à¸„à¸à¸¥à¸²à¸‡', 'à¸ à¸²à¸„à¹ƒà¸•à¹‰'],          cause: ['à¸­à¸¸à¸šà¸±à¸•à¸´à¹€à¸«à¸•à¸¸', 'à¹‚à¸£à¸„à¸«à¸±à¸§à¹ƒà¸ˆ', 'à¹‚à¸£à¸„à¸«à¸¥à¸­à¸”à¹€à¸¥à¸·à¸­à¸”à¸ªà¸¡à¸­à¸‡', 'à¸­à¸·à¹ˆà¸™à¹†'],        },      },      reportingFrequency: 'ANNUAL',      responsibleUserId: admin!.id,      isActive: true,      displayOrder: 1,    },  })  await prisma.logframeIndicator.create({    data: {      elementId: goal.id,      indicatorCode: 'G1.2',      indicatorName: 'à¸”à¸±à¸Šà¸™à¸µà¸„à¸¸à¸“à¸ à¸²à¸à¸Šà¸µà¸§à¸´à¸•à¸”à¹‰à¸²à¸™à¸ªà¸¸à¸‚à¸ à¸²à¸à¸‚à¸­à¸‡à¸›à¸£à¸°à¸Šà¸²à¸Šà¸™ (Health-Related Quality of Life Index)',      indicatorDescription: 'à¸§à¸±à¸”à¸„à¸¸à¸“à¸ à¸²à¸à¸Šà¸µà¸§à¸´à¸•à¸”à¹‰à¸²à¸™à¸ªà¸¸à¸‚à¸ à¸²à¸à¸£à¸§à¸¡',      indicatorType: IndicatorType.COMPOSITE,      indicatorCategory: IndicatorCategory.IMPACT,      measurementUnit: 'à¸„à¸°à¹à¸™à¸™ (0-100)',      dataSource: 'à¸à¸²à¸£à¸ªà¸³à¸£à¸§à¸ˆà¸ªà¸¸à¸‚à¸ à¸²à¸à¸›à¸£à¸°à¸Šà¸²à¸Šà¸™',      collectionMethod: VerificationMethod.SURVEY,      baselineValue: 72,      baselineYear: 2023,      targetValue: 75,      targetYear: 2027,      currentValue: 72.5,      achievementRate: 16.67,      reportingFrequency: 'ANNUAL',      responsibleUserId: admin!.id,      isActive: true,      displayOrder: 2,    },  })  // Goal Assumptions  await prisma.logframeAssumption.create({    data: {      elementId: goal.id,      assumptionCode: 'GA1',      assumptionText: 'à¸™à¹‚à¸¢à¸šà¸²à¸¢à¸ªà¸²à¸˜à¸²à¸£à¸“à¸ªà¸¸à¸‚à¹à¸«à¹ˆà¸‡à¸Šà¸²à¸•à¸´à¸¢à¸±à¸‡à¸„à¸‡à¹ƒà¸«à¹‰à¸„à¸§à¸²à¸¡à¸ªà¸³à¸„à¸±à¸à¸à¸±à¸šà¸£à¸°à¸šà¸šà¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œà¸‰à¸¸à¸à¹€à¸‰à¸´à¸™',      assumptionLevel: AssumptionLevel.CRITICAL,      category: AssumptionCategory.POLITICAL,      consequenceIfFalse: 'à¸­à¸²à¸ˆà¸¥à¸”à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“à¹à¸¥à¸°à¸à¸²à¸£à¸ªà¸™à¸±à¸šà¸ªà¸™à¸¸à¸™à¸ˆà¸²à¸à¸£à¸±à¸à¸šà¸²à¸¥',      likelihood: 0.9,      impact: 0.8,      riskScore: 0.72,      mitigationStrategy: 'à¸ªà¸£à¹‰à¸²à¸‡ advocate network à¹à¸¥à¸°à¸™à¸³à¹€à¸ªà¸™à¸­à¸«à¸¥à¸±à¸à¸à¸²à¸™à¸œà¸¥à¸ªà¸³à¹€à¸£à¹‡à¸ˆà¸•à¹ˆà¸­à¹€à¸™à¸·à¹ˆà¸­à¸‡',      howToVerify: 'à¸•à¸´à¸”à¸•à¸²à¸¡à¹à¸œà¸™à¸à¸±à¸’à¸™à¸²à¹€à¸¨à¸£à¸©à¸à¸à¸´à¸ˆà¹à¸¥à¸°à¸ªà¸±à¸‡à¸„à¸¡à¹à¸«à¹ˆà¸‡à¸Šà¸²à¸•à¸´',      verificationFrequency: 'Annually',      status: 'VALID',      lastChecked: new Date(),      responsibleUserId: admin!.id,    },  })  console.log('âœ… Created Goal level')  // =========================================================================  // 3. Create Logframe Elements - PURPOSE Level  // =========================================================================  const purpose = await prisma.logframeElement.create({    data: {      logframeId: logframe.id,      level: LogframeLevel.PURPOSE,      parentElementId: goal.id,      elementCode: 'P1',      narrativeSummary: `**à¸§à¸±à¸•à¸–à¸¸à¸›à¸£à¸°à¸ªà¸‡à¸„à¹Œ/à¸œà¸¥à¸¥à¸±à¸à¸˜à¹Œ (Purpose/Outcome):**à¸£à¸°à¸šà¸šà¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œà¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸¡à¸µà¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸ à¸²à¸à¸ªà¸¹à¸‡à¸‚à¸¶à¹‰à¸™ à¸ªà¸²à¸¡à¸²à¸£à¸–à¹ƒà¸«à¹‰à¸šà¸£à¸´à¸à¸²à¸£à¹„à¸”à¹‰à¸£à¸§à¸”à¹€à¸£à¹‡à¸§à¹à¸¥à¸°à¸¡à¸µà¸„à¸¸à¸“à¸ à¸²à¸      `,      meansOfVerification: [        VerificationMethod.DATABASE_QUERY,        VerificationMethod.MONITORING_REPORT,        VerificationMethod.SURVEY,      ],      verificationDetails: `- à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ EMS- à¸£à¸²à¸¢à¸‡à¸²à¸™à¸›à¸£à¸°à¸ˆà¸³à¹€à¸”à¸·à¸­à¸™à¸ˆà¸²à¸à¸¨à¸¹à¸™à¸¢à¹Œ EMS- à¹à¸šà¸šà¸ªà¸­à¸šà¸–à¸²à¸¡à¸„à¸§à¸²à¸¡à¸à¸¶à¸‡à¸à¸­à¹ƒà¸ˆà¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸šà¸£à¸´à¸à¸²à¸£      `,      verificationFrequency: 'Monthly',      responsibleForVerification: 'à¸ªà¸à¸‰.',      targetGroup: 'à¸œà¸¹à¹‰à¸›à¹ˆà¸§à¸¢à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¹à¸¥à¸°à¸šà¸¸à¸„à¸¥à¸²à¸à¸£ EMS',      progressStatus: 'ON_TRACK',      completionPercent: 45,      displayOrder: 1,    },  })  // Purpose Indicators  await prisma.logframeIndicator.create({    data: {      elementId: purpose.id,      indicatorCode: 'P1.1',      indicatorName: 'à¹€à¸§à¸¥à¸²à¹€à¸‰à¸¥à¸µà¹ˆà¸¢à¹ƒà¸™à¸à¸²à¸£à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™ (Response Time)',      indicatorDescription: 'à¹€à¸§à¸¥à¸²à¸ˆà¸²à¸à¸£à¸±à¸šà¹à¸ˆà¹‰à¸‡à¸ˆà¸™à¸–à¸¶à¸‡à¸›à¸à¸¡à¸à¸¢à¸²à¸šà¸²à¸¥',      indicatorType: IndicatorType.QUANTITATIVE,      indicatorCategory: IndicatorCategory.OUTCOME,      measurementUnit: 'à¸™à¸²à¸—à¸µ',      dataSource: 'à¸£à¸°à¸šà¸š EMS',      collectionMethod: VerificationMethod.DATABASE_QUERY,      baselineValue: 15,      baselineYear: 2023,      targetValue: 12,      targetYear: 2024,      currentValue: 13.5,      achievementRate: 50,      disaggregation: {        dimensions: {          region: ['à¸à¸£à¸¸à¸‡à¹€à¸—à¸à¸¯', 'à¸ à¸¹à¸¡à¸´à¸ à¸²à¸„'],          severity: ['à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸¡à¸²à¸', 'à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸›à¸²à¸™à¸à¸¥à¸²à¸‡', 'à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸™à¹‰à¸­à¸¢'],          timeOfDay: ['à¹€à¸Šà¹‰à¸²', 'à¸šà¹ˆà¸²à¸¢', 'à¹€à¸¢à¹‡à¸™', 'à¸”à¸¶à¸'],        },      },      reportingFrequency: 'MONTHLY',      responsibleUserId: planner!.id,      isActive: true,      displayOrder: 1,    },  })  await prisma.logframeIndicator.create({    data: {      elementId: purpose.id,      indicatorCode: 'P1.2',      indicatorName: 'à¸­à¸±à¸•à¸£à¸²à¸à¸²à¸£à¸£à¸­à¸”à¸Šà¸µà¸§à¸´à¸•à¸‚à¸­à¸‡à¸œà¸¹à¹‰à¸›à¹ˆà¸§à¸¢à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™ (Survival Rate)',      indicatorDescription: 'à¸£à¹‰à¸­à¸¢à¸¥à¸°à¸‚à¸­à¸‡à¸œà¸¹à¹‰à¸›à¹ˆà¸§à¸¢à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸—à¸µà¹ˆà¸£à¸­à¸”à¸Šà¸µà¸§à¸´à¸•',      indicatorType: IndicatorType.QUANTITATIVE,      indicatorCategory: IndicatorCategory.OUTCOME,      measurementUnit: '%',      dataSource: 'à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ EMS + à¹‚à¸£à¸‡à¸à¸¢à¸²à¸šà¸²à¸¥',      collectionMethod: VerificationMethod.DATABASE_QUERY,      baselineValue: 92,      baselineYear: 2023,      targetValue: 95,      targetYear: 2024,      currentValue: 93.5,      achievementRate: 50,      reportingFrequency: 'MONTHLY',      responsibleUserId: planner!.id,      isActive: true,      displayOrder: 2,    },  })  await prisma.logframeIndicator.create({    data: {      elementId: purpose.id,      indicatorCode: 'P1.3',      indicatorName: 'à¸„à¸§à¸²à¸¡à¸à¸¶à¸‡à¸à¸­à¹ƒà¸ˆà¸‚à¸­à¸‡à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸šà¸£à¸´à¸à¸²à¸£ (Patient Satisfaction)',      indicatorDescription: 'à¸„à¸°à¹à¸™à¸™à¸„à¸§à¸²à¸¡à¸à¸¶à¸‡à¸à¸­à¹ƒà¸ˆà¹€à¸‰à¸¥à¸µà¹ˆà¸¢à¸ˆà¸²à¸à¸œà¸¹à¹‰à¸›à¹ˆà¸§à¸¢à¹à¸¥à¸°à¸à¸²à¸•à¸´',      indicatorType: IndicatorType.QUANTITATIVE,      indicatorCategory: IndicatorCategory.EFFECTIVENESS,      measurementUnit: 'à¸„à¸°à¹à¸™à¸™ (1-5)',      dataSource: 'à¹à¸šà¸šà¸ªà¸­à¸šà¸–à¸²à¸¡',      collectionMethod: VerificationMethod.SURVEY,      baselineValue: 4.2,      baselineYear: 2023,      targetValue: 4.5,      targetYear: 2024,      currentValue: 4.3,      achievementRate: 33.33,      reportingFrequency: 'QUARTERLY',      responsibleUserId: planner!.id,      isActive: true,      displayOrder: 3,    },  })  // Purpose Assumptions  await prisma.logframeAssumption.create({    data: {      elementId: purpose.id,      assumptionCode: 'PA1',      assumptionText: 'à¸šà¸¸à¸„à¸¥à¸²à¸à¸£ EMS à¸¢à¸­à¸¡à¸£à¸±à¸šà¹à¸¥à¸°à¹ƒà¸Šà¹‰à¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µà¹ƒà¸«à¸¡à¹ˆ',      assumptionLevel: AssumptionLevel.IMPORTANT,      category: AssumptionCategory.SOCIAL,      consequenceIfFalse: 'à¸£à¸°à¸šà¸šà¸­à¸²à¸ˆà¹„à¸¡à¹ˆà¸–à¸¹à¸à¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¸­à¸¢à¹ˆà¸²à¸‡à¹€à¸•à¹‡à¸¡à¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸ à¸²à¸',      likelihood: 0.8,      impact: 0.7,      riskScore: 0.56,      mitigationStrategy: 'à¸ˆà¸±à¸”à¸à¸²à¸£à¸à¸¶à¸à¸­à¸šà¸£à¸¡à¸­à¸¢à¹ˆà¸²à¸‡à¹€à¸‚à¹‰à¸¡à¸‚à¹‰à¸™ à¹à¸¥à¸°à¸¡à¸µ change management',      howToVerify: 'à¸ªà¸³à¸£à¸§à¸ˆà¸„à¸§à¸²à¸¡à¸à¸£à¹‰à¸­à¸¡à¹à¸¥à¸° feedback à¸ˆà¸²à¸à¸šà¸¸à¸„à¸¥à¸²à¸à¸£',      verificationFrequency: 'Quarterly',      status: 'VALID',      responsibleUserId: planner!.id,    },  })  await prisma.logframeAssumption.create({    data: {      elementId: purpose.id,      assumptionCode: 'PA2',      assumptionText: 'à¹‚à¸„à¸£à¸‡à¸ªà¸£à¹‰à¸²à¸‡à¸à¸·à¹‰à¸™à¸à¸²à¸™à¸”à¹‰à¸²à¸™ IT à¸¡à¸µà¹€à¸ªà¸–à¸µà¸¢à¸£à¸ à¸²à¸à¹à¸¥à¸°à¸£à¸­à¸‡à¸£à¸±à¸šà¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸²à¸™',      assumptionLevel: AssumptionLevel.CRITICAL,      category: AssumptionCategory.TECHNICAL,      consequenceIfFalse: 'à¸£à¸°à¸šà¸šà¸­à¸²à¸ˆà¸¥à¹ˆà¸¡ à¸«à¸£à¸·à¸­à¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¹„à¸¡à¹ˆà¹„à¸”à¹‰',      likelihood: 0.85,      impact: 0.9,      riskScore: 0.765,      mitigationStrategy: 'à¸¡à¸µ backup systems à¹à¸¥à¸° disaster recovery plan',      howToVerify: 'à¸—à¸”à¸ªà¸­à¸šà¸£à¸°à¸šà¸šà¸ªà¸¡à¹ˆà¸³à¹€à¸ªà¸¡à¸­ à¹à¸¥à¸°à¸•à¸´à¸”à¸•à¸²à¸¡ uptime',      verificationFrequency: 'Weekly',      status: 'VALID',      responsibleUserId: planner!.id,    },  })  console.log('âœ… Created Purpose level')  // =========================================================================  // 4. Create Logframe Elements - OUTPUT Level  // =========================================================================  const output1 = await prisma.logframeElement.create({    data: {      logframeId: logframe.id,      level: LogframeLevel.OUTPUT,      parentElementId: purpose.id,      elementCode: 'O1',      narrativeSummary: `**à¸œà¸¥à¸œà¸¥à¸´à¸•à¸—à¸µà¹ˆ 1 (Output 1):**à¸£à¸°à¸šà¸š AI Dispatch à¸—à¸µà¹ˆà¸¡à¸µà¸„à¸§à¸²à¸¡à¹à¸¡à¹ˆà¸™à¸¢à¸³à¸ªà¸¹à¸‡à¹à¸¥à¸°à¸à¸£à¹‰à¸­à¸¡à¹ƒà¸Šà¹‰à¸‡à¸²à¸™      `,      meansOfVerification: [        VerificationMethod.DATABASE_QUERY,        VerificationMethod.INSPECTION,      ],      verificationDetails: 'à¸—à¸”à¸ªà¸­à¸šà¸£à¸°à¸šà¸šà¹à¸¥à¸°à¸£à¸²à¸¢à¸‡à¸²à¸™à¸œà¸¥à¸à¸²à¸£à¸—à¸”à¸ªà¸­à¸š',      verificationFrequency: 'Weekly',      budgetAllocated: 20000000,      startDate: new Date('2024-03-01'),      endDate: new Date('2024-09-30'),      progressStatus: 'ON_TRACK',      completionPercent: 60,      displayOrder: 1,    },  })  await prisma.logframeIndicator.create({    data: {      elementId: output1.id,      indicatorCode: 'O1.1',      indicatorName: 'à¸„à¸§à¸²à¸¡à¹à¸¡à¹ˆà¸™à¸¢à¸³à¸‚à¸­à¸‡ AI Algorithm (Accuracy)',      indicatorType: IndicatorType.QUANTITATIVE,      indicatorCategory: IndicatorCategory.OUTPUT,      measurementUnit: '%',      dataSource: 'à¸œà¸¥à¸à¸²à¸£à¸—à¸”à¸ªà¸­à¸šà¸£à¸°à¸šà¸š',      collectionMethod: VerificationMethod.DATABASE_QUERY,      baselineValue: 0,      baselineYear: 2024,      targetValue: 90,      targetYear: 2024,      currentValue: 90.2,      achievementRate: 100,      reportingFrequency: 'WEEKLY',      responsibleUserId: planner!.id,      isActive: true,    },  })  const output2 = await prisma.logframeElement.create({    data: {      logframeId: logframe.id,      level: LogframeLevel.OUTPUT,      parentElementId: purpose.id,      elementCode: 'O2',      narrativeSummary: `**à¸œà¸¥à¸œà¸¥à¸´à¸•à¸—à¸µà¹ˆ 2 (Output 2):**à¸šà¸¸à¸„à¸¥à¸²à¸à¸£ EMS à¹„à¸”à¹‰à¸£à¸±à¸šà¸à¸²à¸£à¸à¸¶à¸à¸­à¸šà¸£à¸¡à¹à¸¥à¸°à¸à¸£à¹‰à¸­à¸¡à¹ƒà¸Šà¹‰à¸£à¸°à¸šà¸šà¹ƒà¸«à¸¡à¹ˆ      `,      meansOfVerification: [        VerificationMethod.DOCUMENT_REVIEW,        VerificationMethod.SURVEY,      ],      verificationDetails: 'à¸£à¸²à¸¢à¸‡à¸²à¸™à¸à¸²à¸£à¸à¸¶à¸à¸­à¸šà¸£à¸¡ + à¹à¸šà¸šà¸›à¸£à¸°à¹€à¸¡à¸´à¸™à¸„à¸§à¸²à¸¡à¸à¸£à¹‰à¸­à¸¡',      verificationFrequency: 'After each training',      budgetAllocated: 5000000,      startDate: new Date('2024-08-01'),      endDate: new Date('2024-11-30'),      progressStatus: 'NOT_STARTED',      completionPercent: 0,      displayOrder: 2,    },  })  await prisma.logframeIndicator.create({    data: {      elementId: output2.id,      indicatorCode: 'O2.1',      indicatorName: 'à¸ˆà¸³à¸™à¸§à¸™à¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¸—à¸µà¹ˆà¸œà¹ˆà¸²à¸™à¸à¸²à¸£à¸à¸¶à¸à¸­à¸šà¸£à¸¡',      indicatorType: IndicatorType.QUANTITATIVE,      indicatorCategory: IndicatorCategory.OUTPUT,      measurementUnit: 'à¸„à¸™',      dataSource: 'à¸šà¸±à¸à¸Šà¸µà¸£à¸²à¸¢à¸Šà¸·à¹ˆà¸­à¸œà¸¹à¹‰à¹€à¸‚à¹‰à¸²à¸­à¸šà¸£à¸¡',      baselineValue: 0,      targetValue: 500,      targetYear: 2024,      currentValue: 0,      reportingFrequency: 'MONTHLY',      responsibleUserId: planner!.id,      isActive: true,    },  })  console.log('âœ… Created Output level')  // =========================================================================  // 5. Create Logframe Elements - ACTIVITY Level  // =========================================================================  await prisma.logframeElement.create({    data: {      logframeId: logframe.id,      level: LogframeLevel.ACTIVITY,      parentElementId: output1.id,      elementCode: 'A1.1',      narrativeSummary: 'à¸à¸±à¸’à¸™à¸² AI Algorithm à¸ªà¸³à¸«à¸£à¸±à¸š Dispatch',      meansOfVerification: [VerificationMethod.DOCUMENT_REVIEW],      verificationDetails: 'Code repository + Documentation',      budgetAllocated: 10000000,      humanResources: '5 Data Scientists + 3 Developers',      startDate: new Date('2024-03-01'),      endDate: new Date('2024-07-31'),      progressStatus: 'COMPLETED',      completionPercent: 100,      displayOrder: 1,    },  })  await prisma.logframeElement.create({    data: {      logframeId: logframe.id,      level: LogframeLevel.ACTIVITY,      parentElementId: output1.id,      elementCode: 'A1.2',      narrativeSummary: 'à¸—à¸”à¸ªà¸­à¸šà¸£à¸°à¸šà¸šà¸à¸±à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸ˆà¸£à¸´à¸‡ 10,000 cases',      meansOfVerification: [VerificationMethod.DATABASE_QUERY],      verificationDetails: 'Test results + Performance metrics',      budgetAllocated: 3000000,      startDate: new Date('2024-08-01'),      endDate: new Date('2024-09-30'),      progressStatus: 'ON_TRACK',      completionPercent: 65,      displayOrder: 2,    },  })  await prisma.logframeElement.create({    data: {      logframeId: logframe.id,      level: LogframeLevel.ACTIVITY,      parentElementId: output2.id,      elementCode: 'A2.1',      narrativeSummary: 'à¸ˆà¸±à¸”à¸—à¸³à¸«à¸¥à¸±à¸à¸ªà¸¹à¸•à¸£à¸à¸²à¸£à¸à¸¶à¸à¸­à¸šà¸£à¸¡',      meansOfVerification: [VerificationMethod.DOCUMENT_REVIEW],      verificationDetails: 'Training curriculum + Materials',      budgetAllocated: 1000000,      startDate: new Date('2024-08-01'),      endDate: new Date('2024-08-31'),      progressStatus: 'NOT_STARTED',      completionPercent: 0,      displayOrder: 1,    },  })  await prisma.logframeElement.create({    data: {      logframeId: logframe.id,      level: LogframeLevel.ACTIVITY,      parentElementId: output2.id,      elementCode: 'A2.2',      narrativeSummary: 'à¸”à¸³à¹€à¸™à¸´à¸™à¸à¸²à¸£à¸à¸¶à¸à¸­à¸šà¸£à¸¡ 10 à¸£à¸¸à¹ˆà¸™',      meansOfVerification: [VerificationMethod.DOCUMENT_REVIEW],      verificationDetails: 'Training attendance + Evaluation forms',      budgetAllocated: 4000000,      startDate: new Date('2024-09-01'),      endDate: new Date('2024-11-30'),      progressStatus: 'NOT_STARTED',      completionPercent: 0,      displayOrder: 2,    },  })  console.log('âœ… Created Activity level')  // =========================================================================  // 6. Create Indicator Measurements  // =========================================================================  const indicator = await prisma.logframeIndicator.findFirst({    where: { indicatorCode: 'P1.1' },  })  if (indicator) {    const measurements = [      { date: '2024-01-31', value: 14.8, period: 'Jan 2024' },      { date: '2024-02-29', value: 14.5, period: 'Feb 2024' },      { date: '2024-03-31', value: 14.2, period: 'Mar 2024' },      { date: '2024-04-30', value: 14.0, period: 'Apr 2024' },      { date: '2024-05-31', value: 13.5, period: 'May 2024' },    ]    for (const m of measurements) {      await prisma.indicatorMeasurement.create({        data: {          indicatorId: indicator.id,          measurementDate: new Date(m.date),          measurementPeriod: m.period,          measuredValue: m.value,          variance: m.value - 12, // vs target          variancePercent: ((m.value - 12) / 12) * 100,          disaggregatedData: {            byRegion: {              bangkok: m.value - 2,              central: m.value,              north: m.value + 1,              northeast: m.value + 1.5,              south: m.value + 0.5,            },          },          dataQuality: 'GOOD',          confidenceLevel: 4,          dataSource: 'EMS Database',          collectionMethod: 'DATABASE_QUERY',          analysis: `à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡à¸•à¹ˆà¸­à¹€à¸™à¸·à¹ˆà¸­à¸‡ à¸”à¸µà¸‚à¸¶à¹‰à¸™ ${((14.8 - m.value) / 14.8 * 100).toFixed(1)}% à¸ˆà¸²à¸à¹€à¸”à¸·à¸­à¸™à¹à¸£à¸`,          collectedBy: planner!.id,          isVerified: true,          verifiedBy: admin!.id,          verifiedAt: new Date(m.date),        },      })    }    console.log('âœ… Created indicator measurements')  }  // =========================================================================  // 7. Create Theory of Change  // =========================================================================  await prisma.theoryOfChange.create({    data: {      logframeId: logframe.id,      problemStatement: `**à¸›à¸±à¸à¸«à¸²:**- à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸Šà¹‰à¸² (15 à¸™à¸²à¸—à¸µ)- à¸­à¸±à¸•à¸£à¸²à¸à¸²à¸£à¹€à¸ªà¸µà¸¢à¸Šà¸µà¸§à¸´à¸•à¸ˆà¸²à¸à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸ªà¸¹à¸‡ (45 à¸•à¹ˆà¸­ 100,000)- à¸à¸²à¸£à¸ˆà¸±à¸”à¸ªà¸£à¸£à¸—à¸£à¸±à¸à¸¢à¸²à¸à¸£à¹„à¸¡à¹ˆà¸¡à¸µà¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸ à¸²à¸- à¸‚à¸²à¸”à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹€à¸Šà¸´à¸‡ real-time à¸ªà¸³à¸«à¸£à¸±à¸šà¸à¸²à¸£à¸•à¸±à¸”à¸ªà¸´à¸™à¹ƒà¸ˆ      `,      desiredChange: `**à¸à¸²à¸£à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¹à¸›à¸¥à¸‡à¸—à¸µà¹ˆà¸•à¹‰à¸­à¸‡à¸à¸²à¸£:**- à¸£à¸°à¸šà¸š EMS à¸—à¸µà¹ˆà¸¡à¸µà¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸ à¸²à¸à¸ªà¸¹à¸‡ à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¹€à¸£à¹‡à¸§- à¸¥à¸”à¸­à¸±à¸•à¸£à¸²à¸à¸²à¸£à¹€à¸ªà¸µà¸¢à¸Šà¸µà¸§à¸´à¸•- à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸—à¸£à¸±à¸à¸¢à¸²à¸à¸£à¸­à¸¢à¹ˆà¸²à¸‡à¸„à¸¸à¹‰à¸¡à¸„à¹ˆà¸²- à¸à¸²à¸£à¸•à¸±à¸”à¸ªà¸´à¸™à¹ƒà¸ˆà¸—à¸µà¹ˆà¸‚à¸±à¸šà¹€à¸„à¸¥à¸·à¹ˆà¸­à¸™à¸”à¹‰à¸§à¸¢à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ (Data-driven)      `,      causalPathway: {        nodes: [          { id: 'input1', label: 'à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“ 50 à¸¥à¹‰à¸²à¸™', type: 'input' },          { id: 'input2', label: 'à¸—à¸µà¸¡à¸œà¸¹à¹‰à¹€à¸Šà¸µà¹ˆà¸¢à¸§à¸Šà¸²à¸', type: 'input' },          { id: 'activity1', label: 'à¸à¸±à¸’à¸™à¸² AI System', type: 'activity' },          { id: 'activity2', label: 'à¸à¸¶à¸à¸­à¸šà¸£à¸¡à¸šà¸¸à¸„à¸¥à¸²à¸à¸£', type: 'activity' },          { id: 'output1', label: 'AI Dispatch System', type: 'output' },          { id: 'output2', label: 'à¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¸à¸£à¹‰à¸­à¸¡à¹ƒà¸Šà¹‰', type: 'output' },          { id: 'outcome1', label: 'à¸¥à¸”à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡', type: 'outcome' },          { id: 'outcome2', label: 'à¹€à¸à¸´à¹ˆà¸¡à¸­à¸±à¸•à¸£à¸²à¸£à¸­à¸”à¸Šà¸µà¸§à¸´à¸•', type: 'outcome' },          { id: 'impact', label: 'à¸¥à¸”à¸­à¸±à¸•à¸£à¸²à¸à¸²à¸£à¹€à¸ªà¸µà¸¢à¸Šà¸µà¸§à¸´à¸•', type: 'impact' },        ],        links: [          { source: 'input1', target: 'activity1' },          { source: 'input2', target: 'activity1' },          { source: 'activity1', target: 'output1' },          { source: 'activity2', target: 'output2' },          { source: 'output1', target: 'outcome1' },          { source: 'output2', target: 'outcome1' },          { source: 'outcome1', target: 'outcome2' },          { source: 'outcome2', target: 'impact' },        ],      },      keyAssumptions: [        'à¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¸¢à¸­à¸¡à¸£à¸±à¸šà¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µà¹ƒà¸«à¸¡à¹ˆ',        'à¹‚à¸„à¸£à¸‡à¸ªà¸£à¹‰à¸²à¸‡à¸à¸·à¹‰à¸™à¸à¸²à¸™ IT à¸à¸£à¹‰à¸­à¸¡',        'à¸™à¹‚à¸¢à¸šà¸²à¸¢à¸ªà¸™à¸±à¸šà¸ªà¸™à¸¸à¸™à¸•à¹ˆà¸­à¹€à¸™à¸·à¹ˆà¸­à¸‡',        'à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸¡à¸µà¸„à¸¸à¸“à¸ à¸²à¸à¹à¸¥à¸°à¹€à¸à¸µà¸¢à¸‡à¸à¸­',      ],      contextAnalysis: 'à¸›à¸£à¸°à¹€à¸—à¸¨à¹„à¸—à¸¢à¸¡à¸µ EMS network à¸—à¸µà¹ˆà¹à¸‚à¹‡à¸‡à¹à¸£à¸‡ à¹à¸•à¹ˆà¸¢à¸±à¸‡à¸‚à¸²à¸”à¸à¸²à¸£à¹ƒà¸Šà¹‰à¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µà¸ªà¸¡à¸±à¸¢à¹ƒà¸«à¸¡à¹ˆ',      stakeholderAnalysis: 'à¸¡à¸µà¸œà¸¹à¹‰à¸¡à¸µà¸ªà¹ˆà¸§à¸™à¹„à¸”à¹‰à¸ªà¹ˆà¸§à¸™à¹€à¸ªà¸µà¸¢à¸«à¸¥à¸±à¸ 5 à¸à¸¥à¸¸à¹ˆà¸¡: à¸œà¸¹à¹‰à¸›à¹ˆà¸§à¸¢, à¸šà¸¸à¸„à¸¥à¸²à¸à¸£, à¹‚à¸£à¸‡à¸à¸¢à¸²à¸šà¸²à¸¥, à¸£à¸±à¸à¸šà¸²à¸¥, à¸œà¸¹à¹‰à¸à¸±à¸’à¸™à¸²à¹€à¸—à¸„à¹‚à¸™à¹‚à¸¥à¸¢à¸µ',      version: '1.0',    },  })  console.log('âœ… Created Theory of Change')  // =========================================================================  // 8. Create M&E Plan  // =========================================================================  await prisma.mEPlan.create({    data: {      logframeId: logframe.id,      monitoringApproach: `**à¹à¸™à¸§à¸—à¸²à¸‡à¸à¸²à¸£à¸•à¸´à¸”à¸•à¸²à¸¡ (Monitoring):**- à¸•à¸´à¸”à¸•à¸²à¸¡à¸œà¸¥à¸à¸²à¸£à¸”à¸³à¹€à¸™à¸´à¸™à¸‡à¸²à¸™à¸£à¸²à¸¢à¹€à¸”à¸·à¸­à¸™- à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸„à¸§à¸²à¸¡à¸„à¸·à¸šà¸«à¸™à¹‰à¸²à¸•à¸²à¸¡ milestones- à¸§à¸±à¸”à¸•à¸±à¸§à¸Šà¸µà¹‰à¸§à¸±à¸”à¸•à¸²à¸¡à¸„à¸§à¸²à¸¡à¸–à¸µà¹ˆà¸—à¸µà¹ˆà¸à¸³à¸«à¸™à¸”- à¸¡à¸µà¸£à¸°à¸šà¸š dashboard à¹à¸ªà¸”à¸‡à¸œà¸¥à¹à¸šà¸š real-time      `,      evaluationApproach: `**à¹à¸™à¸§à¸—à¸²à¸‡à¸à¸²à¸£à¸›à¸£à¸°à¹€à¸¡à¸´à¸™à¸œà¸¥ (Evaluation):**- Mid-term Evaluation (6 à¹€à¸”à¸·à¸­à¸™)- Final Evaluation (12 à¹€à¸”à¸·à¸­à¸™)- Ex-post Evaluation (6 à¹€à¸”à¸·à¸­à¸™à¸«à¸¥à¸±à¸‡à¸ªà¸´à¹‰à¸™à¸ªà¸¸à¸”à¹‚à¸„à¸£à¸‡à¸à¸²à¸£)- à¹ƒà¸Šà¹‰ mixed methods (quantitative + qualitative)      `,      dataCollectionPlan: {        methods: [          {            indicator: 'à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡',            method: 'Database Query',            frequency: 'Daily',            responsible: 'Data Team',          },          {            indicator: 'à¸„à¸§à¸²à¸¡à¸à¸¶à¸‡à¸à¸­à¹ƒà¸ˆ',            method: 'Survey',            frequency: 'Quarterly',            responsible: 'Quality Team',          },        ],      },      evaluationSchedule: {        schedule: [          { type: 'Inception', date: '2024-01-15', responsible: 'External Evaluator' },          { type: 'Mid-term', date: '2024-06-30', responsible: 'M&E Team' },          { type: 'Final', date: '2024-12-31', responsible: 'External Evaluator' },        ],      },      meTeamStructure: {        team: [          { role: 'M&E Lead', name: 'à¸„à¸¸à¸“ A', responsibilities: 'Overall coordination' },          { role: 'Data Analyst', name: 'à¸„à¸¸à¸“ B', responsibilities: 'Data analysis' },          { role: 'Field Monitor', name: 'à¸„à¸¸à¸“ C', responsibilities: 'Field visits' },        ],      },      meBudget: 3000000,      qualityAssurancePlan: 'à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸„à¸¸à¸“à¸ à¸²à¸à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸¸à¸à¹€à¸”à¸·à¸­à¸™ + à¸¡à¸µ data validation rules',      dataManagementPlan: 'à¹ƒà¸Šà¹‰à¸£à¸°à¸šà¸š database à¸—à¸µà¹ˆà¸¡à¸µà¸à¸²à¸£ backup à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´',      dataProtectionPlan: 'à¸›à¸à¸´à¸šà¸±à¸•à¸´à¸•à¸²à¸¡ PDPA à¹à¸¥à¸° ISO 27001',      reportingSchedule: {        reports: [          { type: 'Monthly Progress', frequency: 'Monthly', audience: 'Project Team' },          { type: 'Quarterly Report', frequency: 'Quarterly', audience: 'Management' },          { type: 'Annual Report', frequency: 'Annual', audience: 'Stakeholders' },        ],      },      learningPlan: 'à¸ˆà¸±à¸” lessons learned workshop à¸—à¸¸à¸à¹„à¸•à¸£à¸¡à¸²à¸ª',      adaptationMechanism: 'à¸¡à¸µà¸à¸£à¸°à¸šà¸§à¸™à¸à¸²à¸£à¸—à¸šà¸—à¸§à¸™à¹à¸¥à¸°à¸›à¸£à¸±à¸šà¹à¸œà¸™à¸—à¸¸à¸ 3 à¹€à¸”à¸·à¸­à¸™',    },  })  console.log('âœ… Created M&E Plan')  // =========================================================================  // 9. Create Logframe Review  // =========================================================================  await prisma.logframeReview.create({    data: {      logframeId: logframe.id,      reviewType: 'MID_TERM',      reviewTitle: 'Mid-term Review - à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¸à¸±à¸’à¸™à¸²à¸£à¸°à¸šà¸š EMS (6 à¹€à¸”à¸·à¸­à¸™)',      reviewDescription: 'à¸à¸²à¸£à¸›à¸£à¸°à¹€à¸¡à¸´à¸™à¸à¸¶à¹ˆà¸‡à¸à¸¥à¸²à¸‡à¹‚à¸„à¸£à¸‡à¸à¸²à¸£',      periodStart: new Date('2024-01-01'),      periodEnd: new Date('2024-06-30'),      reviewDate: new Date('2024-07-15'),      leadEvaluatorId: admin!.id,      teamMembers: [planner!.id],      externalEvaluators: 'Prof. Dr. Somchai (Mahidol University)',      relevanceScore: 5,      effectivenessScore: 4,      efficiencyScore: 4,      impactScore: 3,      sustainabilityScore: 4,      coherenceScore: 4.5,      overallScore: 4.08,      executiveSummary: `à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¸¡à¸µà¸„à¸§à¸²à¸¡à¸„à¸·à¸šà¸«à¸™à¹‰à¸²à¹„à¸›à¸•à¸²à¸¡à¹à¸œà¸™ 60% à¸¡à¸µà¸à¸²à¸£à¸à¸±à¸’à¸™à¸² AI System à¸ªà¸³à¹€à¸£à¹‡à¸ˆà¹à¸¥à¸°à¹€à¸£à¸´à¹ˆà¸¡à¹€à¸«à¹‡à¸™à¸œà¸¥à¹ƒà¸™à¸à¸²à¸£à¸¥à¸”à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡ à¸ˆà¸²à¸ 15 à¸™à¸²à¸—à¸µ à¹€à¸«à¸¥à¸·à¸­ 13.5 à¸™à¸²à¸—à¸µ      `,      keyFindings: {        findings: [          'AI Algorithm à¸¡à¸µà¸„à¸§à¸²à¸¡à¹à¸¡à¹ˆà¸™à¸¢à¸³ 90.2% à¹€à¸à¸´à¸™à¹€à¸›à¹‰à¸²',          'à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸¥à¸”à¸¥à¸‡ 10% à¹à¸¥à¹‰à¸§',          'à¸­à¸±à¸•à¸£à¸²à¸£à¸­à¸”à¸Šà¸µà¸§à¸´à¸•à¹€à¸à¸´à¹ˆà¸¡à¸‚à¸¶à¹‰à¸™à¹€à¸›à¹‡à¸™ 93.5%',          'à¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¸¢à¸±à¸‡à¸£à¸­à¸à¸²à¸£à¸à¸¶à¸à¸­à¸šà¸£à¸¡',        ],      },      majorAchievements: {        achievements: [          'à¸à¸±à¸’à¸™à¸² AI Dispatch System à¸ªà¸³à¹€à¸£à¹‡à¸ˆ',          'Integrate à¸à¸±à¸š 2 external systems (GPS, Hospital)',          'à¸—à¸”à¸ªà¸­à¸šà¸£à¸°à¸šà¸šà¸à¸±à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸ˆà¸£à¸´à¸‡ 6,500 cases',        ],      },      challenges: {        challenges: [          'Traffic API integration à¸¥à¹ˆà¸²à¸Šà¹‰à¸²',          'IoT sensor delivery à¸¥à¹ˆà¸²à¸Šà¹‰à¸² 2 à¸ªà¸±à¸›à¸”à¸²à¸«à¹Œ',          'à¸à¸²à¸£à¸à¸¶à¸à¸­à¸šà¸£à¸¡à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹€à¸£à¸´à¹ˆà¸¡',        ],      },      lessonsLearned: {        lessons: [          'à¸„à¸§à¸£à¸¡à¸µ backup vendor à¸ªà¸³à¸«à¸£à¸±à¸š critical components',          'à¹€à¸£à¸´à¹ˆà¸¡à¸§à¸²à¸‡à¹à¸œà¸™à¸à¸²à¸£à¸à¸¶à¸à¸­à¸šà¸£à¸¡à¸•à¸±à¹‰à¸‡à¹à¸•à¹ˆà¹€à¸™à¸´à¹ˆà¸™à¹†',          'à¸à¸²à¸£à¸ªà¸·à¹ˆà¸­à¸ªà¸²à¸£à¸à¸±à¸š stakeholders à¸ªà¸³à¸„à¸±à¸à¸¡à¸²à¸',        ],      },      recommendations: {        recommendations: [          {            recommendation: 'à¹€à¸£à¹ˆà¸‡à¸à¸²à¸£ integrate Traffic API',            priority: 'High',            responsible: 'Tech Team',          },          {            recommendation: 'à¹€à¸£à¸´à¹ˆà¸¡à¸à¸²à¸£à¸à¸¶à¸à¸­à¸šà¸£à¸¡à¹ƒà¸™à¹€à¸”à¸·à¸­à¸™à¸ªà¸´à¸‡à¸«à¸²à¸„à¸¡',            priority: 'High',            responsible: 'Training Team',          },          {            recommendation: 'à¹€à¸•à¸£à¸µà¸¢à¸¡ stakeholder demo',            priority: 'Medium',            responsible: 'Project Manager',          },        ],      },      goalAchievement: 25,      purposeAchievement: 45,      outputAchievement: 60,      activityCompletion: 70,      budgetUtilization: 50,      costEfficiency: 'à¹ƒà¸Šà¹‰à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“à¸•à¸²à¸¡à¹à¸œà¸™ à¸¡à¸µà¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸ à¸²à¸à¸”à¸µ',      status: 'FINAL',      isPublic: true,      publishedAt: new Date('2024-07-20'),    },  })  console.log('âœ… Created logframe review')  // =========================================================================  // 10. Create Logframe Template  // =========================================================================  await prisma.logframeTemplate.create({    data: {      templateName: 'Emergency Response Project Template',      templateDescription: 'Template à¸ªà¸³à¸«à¸£à¸±à¸šà¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¸”à¹‰à¸²à¸™à¸à¸²à¸£à¹à¸à¸—à¸¢à¹Œà¸‰à¸¸à¸à¹€à¸‰à¸´à¸™',      sector: 'Health',      programType: 'Emergency Response',      templateStructure: {        levels: [          {            level: 'GOAL',            template: 'à¸¥à¸”à¸­à¸±à¸•à¸£à¸²à¸à¸²à¸£à¹€à¸ªà¸µà¸¢à¸Šà¸µà¸§à¸´à¸•/à¸à¸²à¸£à¸šà¸²à¸”à¹€à¸ˆà¹‡à¸šà¸ˆà¸²à¸ [à¸ªà¸²à¹€à¸«à¸•à¸¸] à¹ƒà¸™ [à¸à¸·à¹‰à¸™à¸—à¸µà¹ˆ]',            indicators: [              'à¸­à¸±à¸•à¸£à¸²à¸à¸²à¸£à¹€à¸ªà¸µà¸¢à¸Šà¸µà¸§à¸´à¸•à¸•à¹ˆà¸­à¸›à¸£à¸°à¸Šà¸²à¸à¸£ 100,000 à¸„à¸™',              'à¸”à¸±à¸Šà¸™à¸µà¸„à¸¸à¸“à¸ à¸²à¸à¸Šà¸µà¸§à¸´à¸•à¸”à¹‰à¸²à¸™à¸ªà¸¸à¸‚à¸ à¸²à¸',            ],          },          {            level: 'PURPOSE',            template: 'à¸£à¸°à¸šà¸šà¸à¸²à¸£à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™à¸¡à¸µà¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸ à¸²à¸à¹à¸¥à¸°à¹€à¸‚à¹‰à¸²à¸–à¸¶à¸‡à¹„à¸”à¹‰',            indicators: [              'à¹€à¸§à¸¥à¸²à¹€à¸‰à¸¥à¸µà¹ˆà¸¢à¹ƒà¸™à¸à¸²à¸£à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡à¸‰à¸¸à¸à¹€à¸‰à¸´à¸™',              'à¸­à¸±à¸•à¸£à¸²à¸à¸²à¸£à¸£à¸­à¸”à¸Šà¸µà¸§à¸´à¸•',              'à¸„à¸§à¸²à¸¡à¸à¸¶à¸‡à¸à¸­à¹ƒà¸ˆà¸‚à¸­à¸‡à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸šà¸£à¸´à¸à¸²à¸£',            ],          },        ],      },      sampleIndicators: {        common: [          'Response time',          'Survival rate',          'Coverage rate',          'Patient satisfaction',          'Cost per case',        ],      },      typicalAssumptions: {        assumptions: [          'à¸™à¹‚à¸¢à¸šà¸²à¸¢à¸ªà¸™à¸±à¸šà¸ªà¸™à¸¸à¸™à¸•à¹ˆà¸­à¹€à¸™à¸·à¹ˆà¸­à¸‡',          'à¸šà¸¸à¸„à¸¥à¸²à¸à¸£à¸¡à¸µà¸„à¸§à¸²à¸¡à¸à¸£à¹‰à¸­à¸¡',          'à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“à¹€à¸à¸µà¸¢à¸‡à¸à¸­',          'à¸Šà¸¸à¸¡à¸Šà¸™à¹ƒà¸«à¹‰à¸„à¸§à¸²à¸¡à¸£à¹ˆà¸§à¸¡à¸¡à¸·à¸­',        ],      },      bestPractices: `- à¹€à¸£à¸´à¹ˆà¸¡à¸ˆà¸²à¸ baseline data à¸—à¸µà¹ˆà¸Šà¸±à¸”à¹€à¸ˆà¸™- à¸•à¸±à¸§à¸Šà¸µà¹‰à¸§à¸±à¸”à¸•à¹‰à¸­à¸‡ SMART- à¸¡à¸µà¹à¸œà¸™ M&E à¸—à¸µà¹ˆà¸Šà¸±à¸”à¹€à¸ˆà¸™- à¸—à¸šà¸—à¸§à¸™à¹à¸¥à¸°à¸›à¸£à¸±à¸š logframe à¹€à¸›à¹‡à¸™à¸£à¸°à¸¢à¸°      `,      guidelines: 'à¸›à¸à¸´à¸šà¸±à¸•à¸´à¸•à¸²à¸¡à¸¡à¸²à¸•à¸£à¸à¸²à¸™ WHO à¹à¸¥à¸° International Federation',      timesUsed: 0,      isPublic: true,      createdBy: admin!.id,    },  })  console.log('âœ… Created logframe template')  console.log('\nğŸ‰ Logical Framework Analysis seed completed!')}seedLogframe()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })```---ğŸ“¦ Step 3: Update package.json```json{  "scripts": {    "db:seed-logframe": "tsx prisma/seed-logframe.ts",    "db:seed-all": "pnpm db:seed && pnpm db:seed-rbac && pnpm db:seed-tows-bsc && pnpm db:seed-projects && pnpm db:seed-kpi && pnpm db:seed-okr && pnpm db:seed-logframe"  }}```---ğŸ” Step 4: Advanced Logframe Queries```typescript// lib/queries/logframe-queries.ts// 1. Get complete logframe with hierarchyexport async function getLogframeWithHierarchy(logframeId: string) {  const logframe = await prisma.logicalFramework.findUnique({    where: { id: logframeId },    include: {      elements: {        where: { level: LogframeLevel.GOAL },        include: {          indicators: {            include: {              measurements: {                orderBy: { measurementDate: 'desc' },                take: 5,              },            },          },          assumptions: true,          childElements: {            include: {              indicators: {                include: {                  measurements: {                    orderBy: { measurementDate: 'desc' },                    take: 5,                  },                },              },              assumptions: true,              childElements: {                include: {                  indicators: true,                  assumptions: true,                  childElements: {                    include: {                      indicators: true,                    },                  },                },              },            },          },        },        orderBy: { displayOrder: 'asc' },      },      theoryOfChange: true,      mePlan: true,      reviews: {        orderBy: { reviewDate: 'desc' },      },    },  })  return logframe}// 2. Calculate indicator achievement ratesexport async function calculateIndicatorAchievement(indicatorId: string) {  const indicator = await prisma.logframeIndicator.findUnique({    where: { id: indicatorId },    include: {      measurements: {        orderBy: { measurementDate: 'desc' },        take: 1,      },    },  })  if (!indicator || !indicator.measurements[0]) return null  const current = indicator.measurements[0].measuredValue  const baseline = indicator.baselineValue || 0  const target = indicator.targetValue  let achievementRate = 0  // Different calculation based on polarity  if (indicator.indicatorCategory === 'OUTPUT' || indicator.indicatorCategory === 'OUTCOME') {    achievementRate = ((current - baseline) / (target - baseline)) * 100  }  // Update indicator  await prisma.logframeIndicator.update({    where: { id: indicatorId },    data: {      currentValue: current,      achievementRate: Math.min(100, Math.max(0, achievementRate)),      lastMeasured: indicator.measurements[0].measurementDate,    },  })  return achievementRate}// 3. Generate logframe matrix viewexport async function generateLogframeMatrix(logframeId: string) {  const elements = await prisma.logframeElement.findMany({    where: { logframeId },    include: {      indicators: true,      assumptions: true,    },    orderBy: [{ level: 'asc' }, { displayOrder: 'asc' }],  })  // Group by level  const matrix = {    goal: elements.filter((e) => e.level === 'GOAL'),    purpose: elements.filter((e) => e.level === 'PURPOSE'),    outputs: elements.filter((e) => e.level === 'OUTPUT'),    activities: elements.filter((e) => e.level === 'ACTIVITY'),  }  return matrix}// 4. Track assumption validityexport async function trackAssumptionValidity(logframeId: string) {  const assumptions = await prisma.logframeAssumption.findMany({    where: {      element: { logframeId },    },    include: {      element: {        select: {          level: true,          elementCode: true,        },      },      responsibleUser: {        select: {          fullName: true,        },      },    },    orderBy: [{ riskScore: 'desc' }],  })  // Categorize by status  const summary = {    total: assumptions.length,    valid: assumptions.filter((a) => a.status === 'VALID').length,    invalid: assumptions.filter((a) => a.status === 'INVALID').length,    uncertain: assumptions.filter((a) => a.status === 'UNCERTAIN').length,    highRisk: assumptions.filter((a) => a.riskScore && a.riskScore > 0.7).length,  }  return { assumptions, summary }}// 5. Generate evaluation report dataexport async function generateEvaluationReportData(logframeId: string) {  const logframe = await prisma.logicalFramework.findUnique({    where: { id: logframeId },    include: {      elements: {        include: {          indicators: {            include: {              measurements: {                orderBy: { measurementDate: 'desc' },                take: 1,              },            },          },        },      },      reviews: {        orderBy: { reviewDate: 'desc' },        take: 1,      },    },  })  if (!logframe) return null  // Calculate achievement by level  const achievements = {    goal: calculateLevelAchievement(      logframe.elements.filter((e) => e.level === 'GOAL')    ),    purpose: calculateLevelAchievement(      logframe.elements.filter((e) => e.level === 'PURPOSE')    ),    outputs: calculateLevelAchievement(      logframe.elements.filter((e) => e.level === 'OUTPUT')    ),    activities: calculateLevelCompletion(      logframe.elements.filter((e) => e.level === 'ACTIVITY')    ),  }  return {    logframe,    achievements,    latestReview: logframe.reviews[0],  }}function calculateLevelAchievement(elements: any[]): number {  if (elements.length === 0) return 0  const indicators = elements.flatMap((e) => e.indicators)  if (indicators.length === 0) return 0  const totalAchievement = indicators.reduce(    (sum, ind) => sum + (ind.achievementRate || 0),    0  )  return totalAchievement / indicators.length}function calculateLevelCompletion(elements: any[]): number {  if (elements.length === 0) return 0  const totalCompletion = elements.reduce(    (sum, el) => sum + (el.completionPercent || 0),    0  )  return totalCompletion / elements.length}```---âœ… COMPLETE DATABASE SCHEMA - All 7 Phases! ğŸ‰ğŸ¯ Full System CoveragePhase 1: Foundation âœ…Phase 2: RBAC & Audit âœ…Phase 3: TOWS & BSC âœ…Phase 4: Projects & Gantt âœ…Phase 5: Complete KPI System âœ…Phase 6: Complete OKR System âœ…Phase 7: Logical Framework Analysis âœ…Logframe (4 levels: Goal â†’ Purpose â†’ Output â†’ Activity)OVI (Objectively Verifiable Indicators)MOV (Means of Verification)Assumptions & RisksTheory of ChangeM&E PlanImpact PathwaysBeneficiary TrackingReviews & EvaluationsTemplates---ğŸš€ Final Run```bash# Run complete seed (all phases)pnpm db:seed-all# Open Prisma Studiopnpm db:studio```---ğŸŠ What's Next?à¹€à¸£à¸²à¸¡à¸µ Complete Schema à¸„à¸£à¸šà¸—à¸¸à¸ Phase à¹à¸¥à¹‰à¸§!à¸•à¸­à¸™à¸™à¸µà¹‰à¸à¸£à¹‰à¸­à¸¡:Generate tRPC API â†’ Complete CRUD endpointsBuild React UI â†’ Dashboard, forms, visualizationsCreate Documentation â†’ ER Diagrams, API docsPerformance Optimization â†’ Indexes, cachingTesting â†’ Unit tests, integration testsà¸­à¸¢à¸²à¸à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸ªà¹ˆà¸§à¸™à¹„à¸«à¸™à¸„à¸£à¸±à¸š? ğŸš€âœ¨---ğŸ”Œ tRPC API - Complete CRUD + Business Logicà¹€à¸£à¸²à¸ˆà¸°à¸ªà¸£à¹‰à¸²à¸‡ Complete tRPC API à¸ªà¸³à¸«à¸£à¸±à¸šà¸—à¸¸à¸ modules à¸à¸£à¹‰à¸­à¸¡ business logic, validation, authorization, à¹à¸¥à¸° caching---ğŸ“‹ Step 1: Setup tRPC Infrastructure```bash# Install dependenciespnpm add @trpc/server@next @trpc/client@next @trpc/react-query@next @trpc/next@nextpnpm add @tanstack/react-query zod superjsonpnpm add -D @types/node```---ğŸ“¦ Step 2: tRPC Context & Configuration```typescript// server/trpc/context.tsimport { PrismaClient } from '@prisma/client'import { inferAsyncReturnType } from '@trpc/server'import { CreateNextContextOptions } from '@trpc/server/adapters/next'import { getServerSession } from 'next-auth'import { authOptions } from '@/lib/auth'const prisma = new PrismaClient()export async function createContext(opts: CreateNextContextOptions) {  const session = await getServerSession(opts.req, opts.res, authOptions)  return {    prisma,    session,    user: session?.user,  }}export type Context = inferAsyncReturnType<typeof createContext>``````typescript// server/trpc/trpc.tsimport { initTRPC, TRPCError } from '@trpc/server'import { Context } from './context'import superjson from 'superjson'import { ZodError } from 'zod'const t = initTRPC.context<Context>().create({  transformer: superjson,  errorFormatter({ shape, error }) {    return {      ...shape,      data: {        ...shape.data,        zodError:          error.cause instanceof ZodError ? error.cause.flatten() : null,      },    }  },})// Base router and procedure helpersexport const router = t.routerexport const publicProcedure = t.procedure// ============================================================================// MIDDLEWARE: Authentication// ============================================================================const isAuthenticated = t.middleware(({ ctx, next }) => {  if (!ctx.session || !ctx.user) {    throw new TRPCError({ code: 'UNAUTHORIZED' })  }  return next({    ctx: {      session: { ...ctx.session, user: ctx.user },    },  })})export const protectedProcedure = t.procedure.use(isAuthenticated)// ============================================================================// MIDDLEWARE: Role-Based Access Control// ============================================================================export const createRoleProcedure = (requiredRoles: string[]) => {  return protectedProcedure.use(async ({ ctx, next }) => {    const userRoles = await ctx.prisma.userRole.findMany({      where: { userId: ctx.user.id },      include: { role: true },    })    const hasRole = userRoles.some((ur) =>      requiredRoles.includes(ur.role.roleCode)    )    if (!hasRole) {      throw new TRPCError({        code: 'FORBIDDEN',        message: `Required roles: ${requiredRoles.join(', ')}`,      })    }    return next()  })}// ============================================================================// MIDDLEWARE: Permission Check// ============================================================================export const createPermissionProcedure = (requiredPermissions: string[]) => {  return protectedProcedure.use(async ({ ctx, next }) => {    const userRoles = await ctx.prisma.userRole.findMany({      where: { userId: ctx.user.id },      include: {        role: {          include: {            rolePermissions: {              include: { permission: true },            },          },        },      },    })    const userPermissions = userRoles.flatMap((ur) =>      ur.role.rolePermissions.map((rp) => rp.permission.permissionCode)    )    const hasAllPermissions = requiredPermissions.every((perm) =>      userPermissions.includes(perm)    )    if (!hasAllPermissions) {      throw new TRPCError({        code: 'FORBIDDEN',        message: `Required permissions: ${requiredPermissions.join(', ')}`,      })    }    return next()  })}// ============================================================================// MIDDLEWARE: Audit Trail// ============================================================================const auditLog = t.middleware(async ({ ctx, next, path, type, input }) => {  const start = Date.now()  const result = await next()  const duration = Date.now() - start  // Log to audit trail (async, don't block response)  if (ctx.user && ['mutation'].includes(type)) {    ctx.prisma.auditLog      .create({        data: {          userId: ctx.user.id,          action: path,          entityType: path.split('.')[0],          ipAddress: ctx.req?.headers['x-forwarded-for'] as string,          userAgent: ctx.req?.headers['user-agent'],          requestData: input ? JSON.stringify(input) : null,          responseTime: duration,          status: result.ok ? 'SUCCESS' : 'FAILURE',        },      })      .catch((err) => console.error('Audit log failed:', err))  }  return result})export const auditedProcedure = protectedProcedure.use(auditLog)// ============================================================================// MIDDLEWARE: Rate Limiting// ============================================================================const rateLimitMap = new Map<string, { count: number; resetAt: number }>()const rateLimit = (maxRequests: number, windowMs: number) => {  return t.middleware(async ({ ctx, next }) => {    const userId = ctx.user?.id || 'anonymous'    const now = Date.now()    const userLimit = rateLimitMap.get(userId)    if (userLimit) {      if (now < userLimit.resetAt) {        if (userLimit.count >= maxRequests) {          throw new TRPCError({            code: 'TOO_MANY_REQUESTS',            message: 'Rate limit exceeded',          })        }        userLimit.count++      } else {        rateLimitMap.set(userId, { count: 1, resetAt: now + windowMs })      }    } else {      rateLimitMap.set(userId, { count: 1, resetAt: now + windowMs })    }    return next()  })}export const rateLimitedProcedure = publicProcedure.use(  rateLimit(100, 60000)) // 100 requests per minute```---ğŸ“‹ Step 3: Schema Validators (Zod)```typescript// server/trpc/schemas/index.tsimport { z } from 'zod'// ============================================================================// COMMON SCHEMAS// ============================================================================export const paginationSchema = z.object({  page: z.number().min(1).default(1),  perPage: z.number().min(1).max(100).default(20),  sortBy: z.string().optional(),  sortOrder: z.enum(['asc', 'desc']).default('desc'),})export const idSchema = z.object({  id: z.string().cuid(),})export const searchSchema = z.object({  query: z.string().optional(),  filters: z.record(z.any()).optional(),  ...paginationSchema.shape,})// ============================================================================// USER SCHEMAS// ============================================================================export const createUserSchema = z.object({  email: z.string().email(),  username: z.string().min(3).max(50),  fullName: z.string().min(1),  password: z.string().min(8).max(100),  phone: z.string().optional(),  organizationId: z.string().cuid(),  departmentId: z.string().cuid().optional(),  roleIds: z.array(z.string().cuid()).optional(),})export const updateUserSchema = z.object({  id: z.string().cuid(),  email: z.string().email().optional(),  username: z.string().min(3).max(50).optional(),  fullName: z.string().min(1).optional(),  phone: z.string().optional(),  departmentId: z.string().cuid().optional(),  isActive: z.boolean().optional(),  avatar: z.string().url().optional(),})export const assignRoleSchema = z.object({  userId: z.string().cuid(),  roleId: z.string().cuid(),})// ============================================================================// ORGANIZATION SCHEMAS// ============================================================================export const createOrganizationSchema = z.object({  code: z.string().min(2).max(20),  name: z.string().min(1),  nameEn: z.string().optional(),  description: z.string().optional(),  organizationType: z.enum(['GOVERNMENT', 'PRIVATE', 'NGO', 'EDUCATION', 'HEALTHCARE']),  industry: z.string().optional(),  website: z.string().url().optional(),  email: z.string().email().optional(),  phone: z.string().optional(),})// ============================================================================// TOWS SCHEMAS// ============================================================================export const createSWOTElementSchema = z.object({  organizationId: z.string().cuid(),  swotType: z.enum(['STRENGTH', 'WEAKNESS', 'OPPORTUNITY', 'THREAT']),  title: z.string().min(1),  description: z.string().optional(),  evidence: z.string().optional(),  impactLevel: z.enum(['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']).default('MEDIUM'),  timeframe: z.enum(['IMMEDIATE', 'SHORT_TERM', 'MEDIUM_TERM', 'LONG_TERM']).optional(),  category: z.string().optional(),})export const createTOWSStrategySchema = z.object({  organizationId: z.string().cuid(),  strategyType: z.enum(['SO', 'WO', 'ST', 'WT']),  strategyCode: z.string().optional(),  strategyName: z.string().min(1),  strategyDescription: z.string().optional(),  linkedSWOTIds: z.array(z.string().cuid()),  priority: z.enum(['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']).default('MEDIUM'),  timeframe: z.string().optional(),  responsiblePersonId: z.string().cuid().optional(),})// ============================================================================// BSC SCHEMAS// ============================================================================export const createBSCObjectiveSchema = z.object({  organizationId: z.string().cuid(),  perspective: z.enum(['FINANCIAL', 'CUSTOMER', 'INTERNAL_PROCESS', 'LEARNING_GROWTH']),  objectiveCode: z.string().optional(),  objectiveName: z.string().min(1),  objectiveDescription: z.string().optional(),  linkedStrategyIds: z.array(z.string().cuid()).optional(),  targetDate: z.date().optional(),  weight: z.number().min(0).max(100).default(25),  ownerId: z.string().cuid().optional(),})// ============================================================================// PROJECT SCHEMAS// ============================================================================export const createProjectSchema = z.object({  organizationId: z.string().cuid(),  projectCode: z.string().min(1),  projectName: z.string().min(1),  projectDescription: z.string().optional(),  projectType: z.enum(['STRATEGIC', 'OPERATIONAL', 'RESEARCH', 'DEVELOPMENT', 'INFRASTRUCTURE']),  projectCategory: z.string().optional(),  startDate: z.date(),  endDate: z.date(),  budget: z.number().min(0).optional(),  projectManagerId: z.string().cuid(),  sponsorId: z.string().cuid().optional(),  departmentId: z.string().cuid().optional(),  priority: z.enum(['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']).default('MEDIUM'),})export const updateProjectStatusSchema = z.object({  id: z.string().cuid(),  status: z.enum([    'PLANNING',    'APPROVED',    'IN_PROGRESS',    'ON_HOLD',    'AT_RISK',    'COMPLETED',    'CANCELLED',  ]),  statusNotes: z.string().optional(),})export const createTaskSchema = z.object({  projectId: z.string().cuid(),  taskName: z.string().min(1),  taskDescription: z.string().optional(),  taskType: z.enum(['TASK', 'MILESTONE', 'DELIVERABLE']),  parentTaskId: z.string().cuid().optional(),  assignedToId: z.string().cuid().optional(),  startDate: z.date(),  dueDate: z.date(),  estimatedHours: z.number().optional(),  priority: z.enum(['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']).default('MEDIUM'),})// ============================================================================// KPI SCHEMAS// ============================================================================export const createKPISchema = z.object({  organizationId: z.string().cuid(),  bscObjectiveId: z.string().cuid().optional(),  kpiCode: z.string().optional(),  kpiName: z.string().min(1),  kpiDescription: z.string().optional(),  kpiType: z.enum(['LAGGING', 'LEADING', 'BALANCED']),  measurementUnit: z.string(),  dataSource: z.string().optional(),  dataCollectionMethod: z.enum([    'MANUAL',    'IMPORT',    'API',    'DATABASE_QUERY',    'IOT_SENSOR',    'WEB_SCRAPING',    'CALCULATION',  ]),  calculationType: z.enum([    'SIMPLE',    'SUM',    'AVERAGE',    'PERCENTAGE',    'RATIO',    'WEIGHTED_AVERAGE',    'COMPOSITE',    'CUSTOM_FORMULA',  ]),  baselineValue: z.number().optional(),  targetValue: z.number(),  polarity: z.enum(['POSITIVE', 'NEGATIVE', 'NEUTRAL']),  ownerId: z.string().cuid().optional(),})export const recordKPIValueSchema = z.object({  kpiId: z.string().cuid(),  periodDate: z.date(),  actualValue: z.number(),  targetValue: z.number().optional(),  status: z.enum(['EXCELLENT', 'GOOD', 'ACCEPTABLE', 'POOR', 'CRITICAL']).optional(),  notes: z.string().optional(),})// ============================================================================// OKR SCHEMAS// ============================================================================export const createOKRSchema = z.object({  cycleId: z.string().cuid(),  organizationId: z.string().cuid(),  objectiveCode: z.string().optional(),  objectiveTitle: z.string().min(1),  objectiveDescription: z.string().optional(),  okrType: z.enum(['COMPANY', 'DEPARTMENT', 'TEAM', 'INDIVIDUAL']),  parentOKRId: z.string().cuid().optional(),  ownerUserId: z.string().cuid(),  ownerTeamId: z.string().cuid().optional(),  ownerDepartmentId: z.string().cuid().optional(),  contributorIds: z.array(z.string().cuid()).optional(),  priority: z.enum(['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']).default('MEDIUM'),  isPublic: z.boolean().default(true),})export const createKeyResultSchema = z.object({  okrId: z.string().cuid(),  keyResultCode: z.string().optional(),  keyResultTitle: z.string().min(1),  keyResultDescription: z.string().optional(),  keyResultType: z.enum(['METRIC', 'MILESTONE', 'BASELINE']),  measurementUnit: z.string().optional(),  startValue: z.number().optional(),  targetValue: z.number().optional(),  weight: z.number().min(0).max(10).default(1),  ownerUserId: z.string().cuid().optional(),  dueDate: z.date().optional(),})export const createCheckInSchema = z.object({  okrId: z.string().cuid(),  overallProgress: z.number().min(0).max(100),  healthStatus: z.enum(['HEALTHY', 'AT_RISK', 'CRITICAL']),  confidence: z.enum(['VERY_LOW', 'LOW', 'MEDIUM', 'HIGH', 'VERY_HIGH']),  accomplishments: z.string().optional(),  challenges: z.string().optional(),  nextSteps: z.string().optional(),  helpNeeded: z.string().optional(),  mood: z.enum(['GREAT', 'GOOD', 'OKAY', 'CONCERNED', 'STRESSED']).optional(),})// ============================================================================// LOGFRAME SCHEMAS// ============================================================================export const createLogframeSchema = z.object({  projectId: z.string().cuid().optional(),  organizationId: z.string().cuid(),  logframeName: z.string().min(1),  logframeDescription: z.string().optional(),  programName: z.string().min(1),  programDuration: z.string().optional(),  targetBeneficiaries: z.string().optional(),  totalBudget: z.number().min(0).optional(),  fundingSource: z.string().optional(),  startDate: z.date(),  endDate: z.date(),})export const createLogframeElementSchema = z.object({  logframeId: z.string().cuid(),  level: z.enum(['GOAL', 'PURPOSE', 'OUTPUT', 'ACTIVITY']),  parentElementId: z.string().cuid().optional(),  elementCode: z.string(),  narrativeSummary: z.string().min(1),  meansOfVerification: z.array(z.enum([    'SURVEY',    'INTERVIEW',    'OBSERVATION',    'DOCUMENT_REVIEW',    'STATISTICAL_DATA',    'MONITORING_REPORT',    'EVALUATION_REPORT',    'FINANCIAL_REPORT',    'INSPECTION',    'DATABASE_QUERY',  ])),  verificationDetails: z.string().optional(),  verificationFrequency: z.string().optional(),  budgetAllocated: z.number().optional(),  startDate: z.date().optional(),  endDate: z.date().optional(),})export const createLogframeIndicatorSchema = z.object({  elementId: z.string().cuid(),  indicatorCode: z.string(),  indicatorName: z.string().min(1),  indicatorDescription: z.string().optional(),  indicatorType: z.enum(['QUANTITATIVE', 'QUALITATIVE', 'COMPOSITE']),  indicatorCategory: z.enum([    'INPUT',    'OUTPUT',    'OUTCOME',    'IMPACT',    'EFFICIENCY',    'EFFECTIVENESS',    'RELEVANCE',    'SUSTAINABILITY',  ]),  measurementUnit: z.string(),  dataSource: z.string().optional(),  baselineValue: z.number().optional(),  baselineYear: z.number().optional(),  targetValue: z.number(),  targetYear: z.number(),  reportingFrequency: z.enum(['WEEKLY', 'MONTHLY', 'QUARTERLY', 'SEMI_ANNUAL', 'ANNUAL']),})```---ğŸ“‹ Step 4: User Router```typescript// server/trpc/routers/user.router.tsimport { router, protectedProcedure, createPermissionProcedure } from '../trpc'import {  createUserSchema,  updateUserSchema,  assignRoleSchema,  idSchema,  searchSchema,} from '../schemas'import { TRPCError } from '@trpc/server'import bcrypt from 'bcryptjs'export const userRouter = router({  // ============================================================================  // QUERY: Get Current User  // ============================================================================  me: protectedProcedure.query(async ({ ctx }) => {    const user = await ctx.prisma.user.findUnique({      where: { id: ctx.user.id },      include: {        organization: true,        department: true,        userRoles: {          include: {            role: {              include: {                rolePermissions: {                  include: { permission: true },                },              },            },          },        },      },    })    if (!user) {      throw new TRPCError({ code: 'NOT_FOUND', message: 'User not found' })    }    // Extract permissions    const permissions = user.userRoles.flatMap((ur) =>      ur.role.rolePermissions.map((rp) => rp.permission.permissionCode)    )    return {      ...user,      permissions,    }  }),  // ============================================================================  // QUERY: Get User by ID  // ============================================================================  getById: protectedProcedure.input(idSchema).query(async ({ ctx, input }) => {    const user = await ctx.prisma.user.findUnique({      where: { id: input.id },      include: {        organization: true,        department: true,        userRoles: {          include: {            role: true,          },        },      },    })    if (!user) {      throw new TRPCError({ code: 'NOT_FOUND', message: 'User not found' })    }    return user  }),  // ============================================================================  // QUERY: List Users with Pagination & Filters  // ============================================================================  list: protectedProcedure.input(searchSchema).query(async ({ ctx, input }) => {    const { page, perPage, sortBy, sortOrder, query, filters } = input    const where: any = {}    // Search in multiple fields    if (query) {      where.OR = [        { fullName: { contains: query, mode: 'insensitive' } },        { email: { contains: query, mode: 'insensitive' } },        { username: { contains: query, mode: 'insensitive' } },      ]    }    // Apply filters    if (filters?.organizationId) {      where.organizationId = filters.organizationId    }    if (filters?.departmentId) {      where.departmentId = filters.departmentId    }    if (filters?.isActive !== undefined) {      where.isActive = filters.isActive    }    const [total, users] = await Promise.all([      ctx.prisma.user.count({ where }),      ctx.prisma.user.findMany({        where,        include: {          organization: { select: { name: true } },          department: { select: { departmentName: true } },          userRoles: {            include: {              role: { select: { roleName: true, roleCode: true } },            },          },        },        orderBy: sortBy ? { [sortBy]: sortOrder } : { createdAt: 'desc' },        skip: (page - 1) * perPage,        take: perPage,      }),    ])    return {      data: users,      pagination: {        total,        page,        perPage,        totalPages: Math.ceil(total / perPage),      },    }  }),  // ============================================================================  // MUTATION: Create User  // ============================================================================  create: createPermissionProcedure(['USER_CREATE']).input(createUserSchema).mutation(    async ({ ctx, input }) => {      // Check if email/username exists      const existing = await ctx.prisma.user.findFirst({        where: {          OR: [{ email: input.email }, { username: input.username }],        },      })      if (existing) {        throw new TRPCError({          code: 'CONFLICT',          message: 'Email or username already exists',        })      }      // Hash password      const hashedPassword = await bcrypt.hash(input.password, 10)      // Create user      const user = await ctx.prisma.user.create({        data: {          email: input.email,          username: input.username,          fullName: input.fullName,          passwordHash: hashedPassword,          phone: input.phone,          organizationId: input.organizationId,          departmentId: input.departmentId,        },        include: {          organization: true,          department: true,        },      })      // Assign roles      if (input.roleIds && input.roleIds.length > 0) {        await ctx.prisma.userRole.createMany({          data: input.roleIds.map((roleId) => ({            userId: user.id,            roleId,            assignedBy: ctx.user.id,          })),        })      }      return user    }  ),  // ============================================================================  // MUTATION: Update User  // ============================================================================  update: createPermissionProcedure(['USER_UPDATE']).input(updateUserSchema).mutation(    async ({ ctx, input }) => {      const { id, ...data } = input      // Check if user exists      const existing = await ctx.prisma.user.findUnique({        where: { id },      })      if (!existing) {        throw new TRPCError({ code: 'NOT_FOUND', message: 'User not found' })      }      // Update user      const user = await ctx.prisma.user.update({        where: { id },        data,        include: {          organization: true,          department: true,        },      })      return user    }  ),  // ============================================================================  // MUTATION: Delete User (Soft Delete)  // ============================================================================  delete: createPermissionProcedure(['USER_DELETE']).input(idSchema).mutation(    async ({ ctx, input }) => {      const user = await ctx.prisma.user.update({        where: { id: input.id },        data: {          isActive: false,          deletedAt: new Date(),        },      })      return user    }  ),  // ============================================================================  // MUTATION: Assign Role to User  // ============================================================================  assignRole: createPermissionProcedure(['ROLE_ASSIGN']).input(assignRoleSchema).mutation(    async ({ ctx, input }) => {      // Check if already assigned      const existing = await ctx.prisma.userRole.findFirst({        where: {          userId: input.userId,          roleId: input.roleId,        },      })      if (existing) {        throw new TRPCError({          code: 'CONFLICT',          message: 'Role already assigned',        })      }      const userRole = await ctx.prisma.userRole.create({        data: {          userId: input.userId,          roleId: input.roleId,          assignedBy: ctx.user.id,        },        include: {          role: true,          user: { select: { fullName: true, email: true } },        },      })      return userRole    }  ),  // ============================================================================  // MUTATION: Remove Role from User  // ============================================================================  removeRole: createPermissionProcedure(['ROLE_ASSIGN'])    .input(assignRoleSchema)    .mutation(async ({ ctx, input }) => {      const userRole = await ctx.prisma.userRole.findFirst({        where: {          userId: input.userId,          roleId: input.roleId,        },      })      if (!userRole) {        throw new TRPCError({ code: 'NOT_FOUND', message: 'Role assignment not found' })      }      await ctx.prisma.userRole.delete({        where: { id: userRole.id },      })      return { success: true }    }),  // ============================================================================  // QUERY: Get User Statistics  // ============================================================================  statistics: protectedProcedure.query(async ({ ctx }) => {    const [totalUsers, activeUsers, inactiveUsers, byOrganization, byRole] =      await Promise.all([        ctx.prisma.user.count(),        ctx.prisma.user.count({ where: { isActive: true } }),        ctx.prisma.user.count({ where: { isActive: false } }),        ctx.prisma.user.groupBy({          by: ['organizationId'],          _count: true,        }),        ctx.prisma.userRole.groupBy({          by: ['roleId'],          _count: true,        }),      ])    return {      totalUsers,      activeUsers,      inactiveUsers,      byOrganization,      byRole,    }  }),})```---ğŸ“‹ Step 5: OKR Router (Complete)```typescript// server/trpc/routers/okr.router.tsimport { router, protectedProcedure, createPermissionProcedure } from '../trpc'import {  createOKRSchema,  createKeyResultSchema,  createCheckInSchema,  idSchema,  searchSchema,} from '../schemas'import { TRPCError } from '@trpc/server'import { z } from 'zod'export const okrRouter = router({  // ============================================================================  // QUERY: Get OKR by ID with full details  // ============================================================================  getById: protectedProcedure.input(idSchema).query(async ({ ctx, input }) => {    const okr = await ctx.prisma.oKR.findUnique({      where: { id: input.id },      include: {        cycle: true,        ownerUser: {          select: {            id: true,            fullName: true,            email: true,            avatar: true,          },        },        ownerTeam: true,        ownerDepartment: true,        parentOKR: {          select: {            id: true,            objectiveTitle: true,            okrType: true,          },        },        childOKRs: {          select: {            id: true,            objectiveTitle: true,            okrType: true,            progressPercentage: true,            status: true,          },        },        keyResults: {          include: {            ownerUser: {              select: { id: true, fullName: true },            },            updates: {              orderBy: { updateDate: 'desc' },              take: 5,              include: {                updatedByUser: {                  select: { fullName: true, avatar: true },                },              },            },          },          orderBy: { displayOrder: 'asc' },        },        checkIns: {          orderBy: { checkInDate: 'desc' },          take: 10,          include: {            submittedByUser: {              select: { fullName: true, avatar: true },            },          },        },        comments: {          where: { deletedAt: null },          orderBy: { createdAt: 'desc' },          include: {            author: {              select: { fullName: true, avatar: true },            },            replies: {              include: {                author: {                  select: { fullName: true, avatar: true },                },              },            },          },        },        alignments: {          include: {            targetOKR: {              select: {                id: true,                objectiveTitle: true,                okrType: true,              },            },          },        },      },    })    if (!okr) {      throw new TRPCError({ code: 'NOT_FOUND', message: 'OKR not found' })    }    return okr  }),  // ============================================================================  // QUERY: List OKRs with filtering  // ============================================================================  list: protectedProcedure    .input(      searchSchema.extend({        cycleId: z.string().cuid().optional(),        okrType: z.enum(['COMPANY', 'DEPARTMENT', 'TEAM', 'INDIVIDUAL']).optional(),        status: z.string().optional(),        ownerId: z.string().cuid().optional(),      })    )    .query(async ({ ctx, input }) => {      const { page, perPage, sortBy, sortOrder, query, filters, cycleId, okrType, status, ownerId } = input      const where: any = {}      if (cycleId) where.cycleId = cycleId      if (okrType) where.okrType = okrType      if (status) where.status = status      if (ownerId) where.ownerUserId = ownerId      if (query) {        where.OR = [          { objectiveTitle: { contains: query, mode: 'insensitive' } },          { objectiveDescription: { contains: query, mode: 'insensitive' } },        ]      }      const [total, okrs] = await Promise.all([        ctx.prisma.oKR.count({ where }),        ctx.prisma.oKR.findMany({          where,          include: {            ownerUser: {              select: { id: true, fullName: true, avatar: true },            },            ownerTeam: { select: { teamName: true } },            keyResults: {              select: {                id: true,                keyResultTitle: true,                progressPercentage: true,                status: true,              },            },          },          orderBy: sortBy ? { [sortBy]: sortOrder } : { createdAt: 'desc' },          skip: (page - 1) * perPage,          take: perPage,        }),      ])      return {        data: okrs,        pagination: {          total,          page,          perPage,          totalPages: Math.ceil(total / perPage),        },      }    }),  // ============================================================================  // QUERY: Get OKR Cascade Tree  // ============================================================================  getCascadeTree: protectedProcedure    .input(      z.object({        cycleId: z.string().cuid(),        rootOKRId: z.string().cuid().optional(),      })    )    .query(async ({ ctx, input }) => {      const where = input.rootOKRId        ? { id: input.rootOKRId }        : { cycleId: input.cycleId, parentOKRId: null }      const okrs = await ctx.prisma.oKR.findMany({        where,        include: {          ownerUser: {            select: { id: true, fullName: true, avatar: true },          },          keyResults: {            orderBy: { displayOrder: 'asc' },          },          childOKRs: {            include: {              ownerUser: {                select: { id: true, fullName: true, avatar: true },              },              keyResults: true,              childOKRs: {                include: {                  ownerUser: {                    select: { id: true, fullName: true, avatar: true },                  },                  keyResults: true,                  childOKRs: {                    include: {                      ownerUser: {                        select: { id: true, fullName: true },                      },                      keyResults: true,                    },                  },                },              },            },          },        },      })      function buildTree(okr: any): any {        return {          id: okr.id,          title: okr.objectiveTitle,          type: okr.okrType,          owner: okr.ownerUser,          progress: okr.progressPercentage,          status: okr.status,          confidence: okr.confidence,          keyResults: okr.keyResults.map((kr: any) => ({            id: kr.id,            title: kr.keyResultTitle,            type: kr.keyResultType,            current: kr.currentValue,            target: kr.targetValue,            progress: kr.progressPercentage,            status: kr.status,          })),          children: okr.childOKRs.map(buildTree),        }      }      return okrs.map(buildTree)    }),  // ============================================================================  // MUTATION: Create OKR  // ============================================================================  create: protectedProcedure.input(createOKRSchema).mutation(async ({ ctx, input }) => {    // Verify cycle exists and is active    const cycle = await ctx.prisma.oKRCycle.findUnique({      where: { id: input.cycleId },    })    if (!cycle || cycle.status !== 'ACTIVE') {      throw new TRPCError({        code: 'BAD_REQUEST',        message: 'Cycle is not active',      })    }    // Create OKR    const okr = await ctx.prisma.oKR.create({      data: {        ...input,        status: 'DRAFT',        progressPercentage: 0,        confidence: 'MEDIUM',        submittedBy: ctx.user.id,      },      include: {        ownerUser: {          select: { fullName: true, email: true },        },      },    })    return okr  }),  // ============================================================================  // MUTATION: Update OKR  // ============================================================================  update: protectedProcedure    .input(      z.object({        id: z.string().cuid(),        objectiveTitle: z.string().min(1).optional(),        objectiveDescription: z.string().optional(),        priority: z.enum(['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']).optional(),        confidence: z.enum(['VERY_LOW', 'LOW', 'MEDIUM', 'HIGH', 'VERY_HIGH']).optional(),      })    )    .mutation(async ({ ctx, input }) => {      const { id, ...data } = input      // Check ownership or permission      const existing = await ctx.prisma.oKR.findUnique({        where: { id },      })      if (!existing) {        throw new TRPCError({ code: 'NOT_FOUND', message: 'OKR not found' })      }      if (        existing.ownerUserId !== ctx.user.id &&        !existing.contributorIds.includes(ctx.user.id)      ) {        throw new TRPCError({          code: 'FORBIDDEN',          message: 'Not authorized to update this OKR',        })      }      const okr = await ctx.prisma.oKR.update({        where: { id },        data,      })      return okr    }),  // ============================================================================  // MUTATION: Submit OKR for Approval  // ============================================================================  submitForApproval: protectedProcedure.input(idSchema).mutation(async ({ ctx, input }) => {    const okr = await ctx.prisma.oKR.findUnique({      where: { id: input.id },      include: { keyResults: true },    })    if (!okr) {      throw new TRPCError({ code: 'NOT_FOUND', message: 'OKR not found' })    }    if (okr.keyResults.length === 0) {      throw new TRPCError({        code: 'BAD_REQUEST',        message: 'OKR must have at least one Key Result',      })    }    const updated = await ctx.prisma.oKR.update({      where: { id: input.id },      data: {        status: 'SUBMITTED',        submittedAt: new Date(),        submittedBy: ctx.user.id,      },    })    // TODO: Send notification to approver    return updated  }),  // ============================================================================  // MUTATION: Approve/Reject OKR  // ============================================================================  approve: createPermissionProcedure(['OKR_APPROVE'])    .input(      z.object({        id: z.string().cuid(),        approved: z.boolean(),        notes: z.string().optional(),      })    )    .mutation(async ({ ctx, input }) => {      const okr = await ctx.prisma.oKR.update({        where: { id: input.id },        data: {          status: input.approved ? 'APPROVED' : 'DRAFT',          approvedAt: input.approved ? new Date() : null,          approvedBy: input.approved ? ctx.user.id : null,          approvalNotes: input.notes,        },      })      return okr    }),  // ============================================================================  // MUTATION: Create Key Result  // ============================================================================  createKeyResult: protectedProcedure.input(createKeyResultSchema).mutation(    async ({ ctx, input }) => {      // Verify OKR exists and user has access      const okr = await ctx.prisma.oKR.findUnique({        where: { id: input.okrId },      })      if (!okr) {        throw new TRPCError({ code: 'NOT_FOUND', message: 'OKR not found' })      }      // Create key result      const keyResult = await ctx.prisma.keyResult.create({        data: {          ...input,          status: 'NOT_STARTED',          progressPercentage: 0,        },      })      return keyResult    }  ),  // ============================================================================  // MUTATION: Update Key Result Progress  // ============================================================================  updateKeyResultProgress: protectedProcedure    .input(      z.object({        keyResultId: z.string().cuid(),        newValue: z.number(),        updateNote: z.string().optional(),        challenges: z.string().optional(),        nextActions: z.string().optional(),      })    )    .mutation(async ({ ctx, input }) => {      const kr = await ctx.prisma.keyResult.findUnique({        where: { id: input.keyResultId },      })      if (!kr) {        throw new TRPCError({ code: 'NOT_FOUND', message: 'Key Result not found' })      }      // Calculate progress      let progress = 0      if (kr.keyResultType === 'METRIC' || kr.keyResultType === 'BASELINE') {        const baseline = kr.startValue || 0        const target = kr.targetValue || 0        progress = ((input.newValue - baseline) / (target - baseline)) * 100        progress = Math.min(100, Math.max(0, progress))      }      // Update key result      const updated = await ctx.prisma.keyResult.update({        where: { id: input.keyResultId },        data: {          currentValue: input.newValue,          progressPercentage: progress,          status: progress >= 100 ? 'COMPLETED' : progress >= 70 ? 'ON_TRACK' : 'BEHIND',        },      })      // Create update record      await ctx.prisma.keyResultUpdate.create({        data: {          keyResultId: input.keyResultId,          previousValue: kr.currentValue,          newValue: input.newValue,          progressChange: progress - kr.progressPercentage,          updateNote: input.updateNote,          challenges: input.challenges,          nextActions: input.nextActions,          updatedBy: ctx.user.id,        },      })      // Recalculate OKR progress      await recalculateOKRProgress(ctx, kr.okrId)      return updated    }),  // ============================================================================  // MUTATION: Create Check-in  // ============================================================================  createCheckIn: protectedProcedure.input(createCheckInSchema).mutation(    async ({ ctx, input }) => {      const okr = await ctx.prisma.oKR.findUnique({        where: { id: input.okrId },        include: { keyResults: true },      })      if (!okr) {        throw new TRPCError({ code: 'NOT_FOUND', message: 'OKR not found' })      }      // Check if already checked in this week      const weekStart = new Date()      weekStart.setDate(weekStart.getDate() - weekStart.getDay())      weekStart.setHours(0, 0, 0, 0)      const existingCheckIn = await ctx.prisma.oKRCheckIn.findFirst({        where: {          okrId: input.okrId,          checkInDate: { gte: weekStart },        },      })      if (existingCheckIn) {        throw new TRPCError({          code: 'CONFLICT',          message: 'Already checked in this week',        })      }      // Create check-in      const checkIn = await ctx.prisma.oKRCheckIn.create({        data: {          ...input,          submittedBy: ctx.user.id,          submittedAt: new Date(),          status: 'SUBMITTED',          keyResultsSnapshot: {            keyResults: okr.keyResults.map((kr) => ({              id: kr.id,              title: kr.keyResultTitle,              current: kr.currentValue,              target: kr.targetValue,              progress: kr.progressPercentage,            })),          },        },      })      // Update OKR progress      await ctx.prisma.oKR.update({        where: { id: input.okrId },        data: {          progressPercentage: input.overallProgress,        },      })      return checkIn    }  ),  // ============================================================================  // QUERY: Get User Dashboard  // ============================================================================  getUserDashboard: protectedProcedure    .input(z.object({ cycleId: z.string().cuid() }))    .query(async ({ ctx, input }) => {      const userId = ctx.user.id      // OKRs owned by user      const ownedOKRs = await ctx.prisma.oKR.findMany({        where: {          cycleId: input.cycleId,          ownerUserId: userId,          status: { in: ['ACTIVE', 'AT_RISK', 'ON_TRACK'] },        },        include: {          keyResults: {            include: {              updates: {                orderBy: { updateDate: 'desc' },                take: 1,              },            },          },          checkIns: {            orderBy: { checkInDate: 'desc' },            take: 1,          },        },      })      // OKRs where user is contributor      const contributedOKRs = await ctx.prisma.oKR.findMany({        where: {          cycleId: input.cycleId,          contributorIds: { has: userId },          status: { in: ['ACTIVE', 'AT_RISK', 'ON_TRACK'] },        },        include: {          ownerUser: {            select: { id: true, fullName: true },          },          keyResults: true,        },      })      // Statistics      const stats = {        totalOKRs: ownedOKRs.length,        onTrack: ownedOKRs.filter((o) => o.status === 'ON_TRACK').length,        atRisk: ownedOKRs.filter((o) => o.status === 'AT_RISK').length,        averageProgress:          ownedOKRs.reduce((sum, o) => sum + o.progressPercentage, 0) /            ownedOKRs.length || 0,      }      return {        ownedOKRs,        contributedOKRs,        stats,      }    }),})// ============================================================================// HELPER: Recalculate OKR Progress from Key Results// ============================================================================async function recalculateOKRProgress(ctx: any, okrId: string) {  const okr = await ctx.prisma.oKR.findUnique({    where: { id: okrId },    include: {      keyResults: {        where: { status: { not: 'CANCELLED' } },      },    },  })  if (!okr || okr.keyResults.length === 0) return  // Weighted average  const totalWeight = okr.keyResults.reduce((sum, kr) => sum + kr.weight, 0)  const weightedProgress = okr.keyResults.reduce(    (sum, kr) => sum + kr.progressPercentage * kr.weight,    0  )  const progress = weightedProgress / totalWeight  // Update OKR  await ctx.prisma.oKR.update({    where: { id: okrId },    data: {      progressPercentage: progress,      updatedAt: new Date(),    },  })  // Recursively update parent  if (okr.parentOKRId) {    await recalculateOKRProgress(ctx, okr.parentOKRId)  }}```---ğŸ“‹ Continue with remaining routers?à¹€à¸£à¸²à¸¡à¸µ:âœ… Core infrastructure (context, middleware, schemas)âœ… User router (complete with RBAC)âœ… OKR router (complete with cascading, check-ins)à¸•à¹ˆà¸­à¹„à¸›à¸ˆà¸°à¸ªà¸£à¹‰à¸²à¸‡:Project RouterKPI RouterLogframe RouterTOWS/BSC RouterDashboard/Analytics RouterRoot Router (combine all)à¸à¸£à¹‰à¸­à¸¡à¹ƒà¸«à¹‰à¸—à¸³à¸•à¹ˆà¸­à¹„à¸«à¸¡à¸„à¸£à¸±à¸š? ğŸš€---ğŸ”Œ tRPC API - Complete All Routersà¸ªà¸£à¹‰à¸²à¸‡ Complete Router System à¸„à¸£à¸šà¸—à¸¸à¸ modules!---ğŸ“‹ Step 1: Project Router```typescript// server/trpc/routers/project.router.tsimport { router, protectedProcedure, createPermissionProcedure } from '../trpc'import {  createProjectSchema,  updateProjectStatusSchema,  createTaskSchema,  idSchema,  searchSchema,} from '../schemas'import { TRPCError } from '@trpc/server'import { z } from 'zod'export const projectRouter = router({  // ============================================================================  // QUERY: Get Project by ID with full details  // ============================================================================  getById: protectedProcedure.input(idSchema).query(async ({ ctx, input }) => {    const project = await ctx.prisma.project.findUnique({      where: { id: input.id },      include: {        organization: true,        department: true,        projectManager: {          select: {            id: true,            fullName: true,            email: true,            avatar: true,          },        },        sponsor: {          select: { id: true, fullName: true },        },        teamMembers: {          include: {            user: {              select: {                id: true,                fullName: true,                email: true,                avatar: true,              },            },            role: true,          },        },        milestones: {          orderBy: { dueDate: 'asc' },          include: {            tasks: {              select: {                id: true,                taskName: true,                status: true,              },            },          },        },        tasks: {          where: { parentTaskId: null },          include: {            assignedTo: {              select: { id: true, fullName: true, avatar: true },            },            subtasks: {              include: {                assignedTo: {                  select: { id: true, fullName: true },                },              },            },            dependencies: {              include: {                dependsOnTask: {                  select: {                    id: true,                    taskName: true,                    status: true,                  },                },              },            },          },          orderBy: { startDate: 'asc' },        },        risks: {          orderBy: { riskScore: 'desc' },          include: {            identifiedBy: {              select: { fullName: true },            },          },        },        issues: {          where: { status: { not: 'CLOSED' } },          orderBy: { createdAt: 'desc' },        },        documents: {          orderBy: { uploadedAt: 'desc' },          include: {            uploadedBy: {              select: { fullName: true },            },          },        },        statusHistory: {          orderBy: { changedAt: 'desc' },          take: 10,        },        linkedStrategies: {          include: {            strategy: {              select: {                id: true,                strategyName: true,                strategyType: true,              },            },          },        },      },    })    if (!project) {      throw new TRPCError({ code: 'NOT_FOUND', message: 'Project not found' })    }    // Calculate project health    const health = await calculateProjectHealth(ctx, project.id)    return {      ...project,      health,    }  }),  // ============================================================================  // QUERY: List Projects  // ============================================================================  list: protectedProcedure    .input(      searchSchema.extend({        projectType: z.string().optional(),        status: z.string().optional(),        departmentId: z.string().cuid().optional(),        projectManagerId: z.string().cuid().optional(),      })    )    .query(async ({ ctx, input }) => {      const { page, perPage, sortBy, sortOrder, query, filters } = input      const where: any = {        organizationId: ctx.user.organizationId,      }      if (query) {        where.OR = [          { projectName: { contains: query, mode: 'insensitive' } },          { projectCode: { contains: query, mode: 'insensitive' } },          { projectDescription: { contains: query, mode: 'insensitive' } },        ]      }      if (input.projectType) where.projectType = input.projectType      if (input.status) where.status = input.status      if (input.departmentId) where.departmentId = input.departmentId      if (input.projectManagerId) where.projectManagerId = input.projectManagerId      const [total, projects] = await Promise.all([        ctx.prisma.project.count({ where }),        ctx.prisma.project.findMany({          where,          include: {            projectManager: {              select: { fullName: true, avatar: true },            },            department: {              select: { departmentName: true },            },            _count: {              select: {                tasks: true,                milestones: true,                teamMembers: true,              },            },          },          orderBy: sortBy ? { [sortBy]: sortOrder } : { createdAt: 'desc' },          skip: (page - 1) * perPage,          take: perPage,        }),      ])      return {        data: projects,        pagination: {          total,          page,          perPage,          totalPages: Math.ceil(total / perPage),        },      }    }),  // ============================================================================  // MUTATION: Create Project  // ============================================================================  create: createPermissionProcedure(['PROJECT_CREATE'])    .input(createProjectSchema)    .mutation(async ({ ctx, input }) => {      // Check if project code exists      const existing = await ctx.prisma.project.findFirst({        where: {          organizationId: input.organizationId,          projectCode: input.projectCode,        },      })      if (existing) {        throw new TRPCError({          code: 'CONFLICT',          message: 'Project code already exists',        })      }      // Validate dates      if (input.endDate <= input.startDate) {        throw new TRPCError({          code: 'BAD_REQUEST',          message: 'End date must be after start date',        })      }      const project = await ctx.prisma.project.create({        data: {          ...input,          status: 'PLANNING',          createdById: ctx.user.id,        },        include: {          projectManager: {            select: { fullName: true, email: true },          },        },      })      // Add project manager as team member      await ctx.prisma.projectTeamMember.create({        data: {          projectId: project.id,          userId: input.projectManagerId,          roleId: 'default-pm-role', // You should have a default PM role          joinedAt: new Date(),        },      })      return project    }),  // ============================================================================  // MUTATION: Update Project  // ============================================================================  update: createPermissionProcedure(['PROJECT_UPDATE'])    .input(      z.object({        id: z.string().cuid(),        projectName: z.string().optional(),        projectDescription: z.string().optional(),        startDate: z.date().optional(),        endDate: z.date().optional(),        budget: z.number().optional(),        projectManagerId: z.string().cuid().optional(),        priority: z.enum(['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']).optional(),      })    )    .mutation(async ({ ctx, input }) => {      const { id, ...data } = input      const project = await ctx.prisma.project.update({        where: { id },        data,      })      return project    }),  // ============================================================================  // MUTATION: Update Project Status  // ============================================================================  updateStatus: createPermissionProcedure(['PROJECT_UPDATE'])    .input(updateProjectStatusSchema)    .mutation(async ({ ctx, input }) => {      const project = await ctx.prisma.project.findUnique({        where: { id: input.id },      })      if (!project) {        throw new TRPCError({ code: 'NOT_FOUND', message: 'Project not found' })      }      // Update project status      const updated = await ctx.prisma.project.update({        where: { id: input.id },        data: {          status: input.status,          updatedAt: new Date(),        },      })      // Record status history      await ctx.prisma.projectStatusHistory.create({        data: {          projectId: input.id,          fromStatus: project.status,          toStatus: input.status,          changedBy: ctx.user.id,          notes: input.statusNotes,        },      })      return updated    }),  // ============================================================================  // MUTATION: Create Task  // ============================================================================  createTask: createPermissionProcedure(['TASK_CREATE'])    .input(createTaskSchema)    .mutation(async ({ ctx, input }) => {      // Verify project exists      const project = await ctx.prisma.project.findUnique({        where: { id: input.projectId },      })      if (!project) {        throw new TRPCError({ code: 'NOT_FOUND', message: 'Project not found' })      }      // Validate dates      if (input.dueDate < input.startDate) {        throw new TRPCError({          code: 'BAD_REQUEST',          message: 'Due date must be after start date',        })      }      // Create task      const task = await ctx.prisma.task.create({        data: {          ...input,          status: 'NOT_STARTED',          progressPercentage: 0,          createdById: ctx.user.id,        },        include: {          assignedTo: {            select: { fullName: true, email: true },          },        },      })      return task    }),  // ============================================================================  // MUTATION: Update Task Progress  // ============================================================================  updateTaskProgress: protectedProcedure    .input(      z.object({        taskId: z.string().cuid(),        progressPercentage: z.number().min(0).max(100),        status: z          .enum(['NOT_STARTED', 'IN_PROGRESS', 'ON_HOLD', 'COMPLETED', 'CANCELLED'])          .optional(),        notes: z.string().optional(),      })    )    .mutation(async ({ ctx, input }) => {      const task = await ctx.prisma.task.findUnique({        where: { id: input.taskId },      })      if (!task) {        throw new TRPCError({ code: 'NOT_FOUND', message: 'Task not found' })      }      // Determine status if not provided      let status = input.status      if (!status) {        if (input.progressPercentage === 0) status = 'NOT_STARTED'        else if (input.progressPercentage === 100) status = 'COMPLETED'        else status = 'IN_PROGRESS'      }      // Update task      const updated = await ctx.prisma.task.update({        where: { id: input.taskId },        data: {          progressPercentage: input.progressPercentage,          status,          actualEndDate: status === 'COMPLETED' ? new Date() : undefined,        },      })      // Create progress update record      await ctx.prisma.taskProgressUpdate.create({        data: {          taskId: input.taskId,          previousProgress: task.progressPercentage,          newProgress: input.progressPercentage,          notes: input.notes,          updatedBy: ctx.user.id,        },      })      // Update parent task progress if exists      if (task.parentTaskId) {        await updateParentTaskProgress(ctx, task.parentTaskId)      }      // Update project completion      await updateProjectCompletion(ctx, task.projectId)      return updated    }),  // ============================================================================  // MUTATION: Create Task Dependency  // ============================================================================  createTaskDependency: protectedProcedure    .input(      z.object({        taskId: z.string().cuid(),        dependsOnTaskId: z.string().cuid(),        dependencyType: z.enum(['FINISH_TO_START', 'START_TO_START', 'FINISH_TO_FINISH', 'START_TO_FINISH']),        lagDays: z.number().default(0),      })    )    .mutation(async ({ ctx, input }) => {      // Check for circular dependency      const hasCircular = await checkCircularDependency(        ctx,        input.taskId,        input.dependsOnTaskId      )      if (hasCircular) {        throw new TRPCError({          code: 'BAD_REQUEST',          message: 'Circular dependency detected',        })      }      const dependency = await ctx.prisma.taskDependency.create({        data: input,      })      return dependency    }),  // ============================================================================  // MUTATION: Add Risk  // ============================================================================  addRisk: protectedProcedure    .input(      z.object({        projectId: z.string().cuid(),        riskTitle: z.string().min(1),        riskDescription: z.string(),        riskCategory: z.string(),        likelihood: z.number().min(1).max(5),        impact: z.number().min(1).max(5),        mitigationStrategy: z.string().optional(),      })    )    .mutation(async ({ ctx, input }) => {      const riskScore = input.likelihood * input.impact      const risk = await ctx.prisma.projectRisk.create({        data: {          ...input,          riskScore,          status: 'IDENTIFIED',          identifiedBy: ctx.user.id,        },      })      return risk    }),  // ============================================================================  // QUERY: Get Project Gantt Chart Data  // ============================================================================  getGanttData: protectedProcedure.input(idSchema).query(async ({ ctx, input }) => {    const tasks = await ctx.prisma.task.findMany({      where: { projectId: input.id },      include: {        assignedTo: {          select: { id: true, fullName: true, avatar: true },        },        dependencies: {          include: {            dependsOnTask: {              select: { id: true, taskName: true },            },          },        },        subtasks: {          select: {            id: true,            taskName: true,            startDate: true,            dueDate: true,            progressPercentage: true,          },        },      },      orderBy: { startDate: 'asc' },    })    // Transform to Gantt format    const ganttData = tasks.map((task) => ({      id: task.id,      name: task.taskName,      start: task.startDate,      end: task.dueDate,      progress: task.progressPercentage,      type: task.taskType,      assignee: task.assignedTo,      dependencies: task.dependencies.map((d) => d.dependsOnTaskId),      subtasks: task.subtasks,      isMilestone: task.taskType === 'MILESTONE',      status: task.status,    }))    return ganttData  }),  // ============================================================================  // QUERY: Get Project Statistics  // ============================================================================  getStatistics: protectedProcedure.input(idSchema).query(async ({ ctx, input }) => {    const [      taskStats,      milestoneStats,      riskStats,      issueStats,      budgetSpent,      teamSize,    ] = await Promise.all([      ctx.prisma.task.groupBy({        by: ['status'],        where: { projectId: input.id },        _count: true,      }),      ctx.prisma.milestone.groupBy({        by: ['status'],        where: { projectId: input.id },        _count: true,      }),      ctx.prisma.projectRisk.groupBy({        by: ['status'],        where: { projectId: input.id },        _count: true,      }),      ctx.prisma.projectIssue.groupBy({        by: ['status'],        where: { projectId: input.id },        _count: true,      }),      ctx.prisma.projectExpense.aggregate({        where: { projectId: input.id, status: 'APPROVED' },        _sum: { amount: true },      }),      ctx.prisma.projectTeamMember.count({        where: { projectId: input.id },      }),    ])    return {      tasks: taskStats,      milestones: milestoneStats,      risks: riskStats,      issues: issueStats,      budgetSpent: budgetSpent._sum.amount || 0,      teamSize,    }  }),  // ============================================================================  // QUERY: Get Project Timeline  // ============================================================================  getTimeline: protectedProcedure.input(idSchema).query(async ({ ctx, input }) => {    const events = await ctx.prisma.projectEvent.findMany({      where: { projectId: input.id },      include: {        createdBy: {          select: { fullName: true, avatar: true },        },      },      orderBy: { eventDate: 'desc' },      take: 50,    })    return events  }),})// ============================================================================// HELPER FUNCTIONS// ============================================================================async function calculateProjectHealth(ctx: any, projectId: string) {  const project = await ctx.prisma.project.findUnique({    where: { id: projectId },    include: {      tasks: true,      risks: { where: { status: 'ACTIVE' } },      issues: { where: { status: { not: 'CLOSED' } } },    },  })  if (!project) return null  let healthScore = 100  // Schedule health (30%)  const now = new Date()  const totalDuration = project.endDate.getTime() - project.startDate.getTime()  const elapsed = now.getTime() - project.startDate.getTime()  const expectedProgress = (elapsed / totalDuration) * 100  const completedTasks = project.tasks.filter((t) => t.status === 'COMPLETED').length  const actualProgress = (completedTasks / project.tasks.length) * 100  const scheduleVariance = actualProgress - expectedProgress  if (scheduleVariance < -20) healthScore -= 30  else if (scheduleVariance < -10) healthScore -= 20  else if (scheduleVariance < 0) healthScore -= 10  // Risk health (30%)  const highRisks = project.risks.filter((r) => r.riskScore >= 15).length  if (highRisks > 5) healthScore -= 30  else if (highRisks > 3) healthScore -= 20  else if (highRisks > 0) healthScore -= 10  // Issue health (20%)  const criticalIssues = project.issues.filter((i) => i.severity === 'CRITICAL').length  if (criticalIssues > 3) healthScore -= 20  else if (criticalIssues > 1) healthScore -= 10  // Budget health (20%)  const budgetVariance = ((project.actualCost || 0) / (project.budget || 1)) * 100  if (budgetVariance > 120) healthScore -= 20  else if (budgetVariance > 110) healthScore -= 10  return {    score: Math.max(0, healthScore),    status:      healthScore >= 80 ? 'HEALTHY' : healthScore >= 60 ? 'AT_RISK' : 'CRITICAL',    scheduleVariance,    highRisks,    criticalIssues,    budgetVariance,  }}async function updateParentTaskProgress(ctx: any, parentTaskId: string) {  const parent = await ctx.prisma.task.findUnique({    where: { id: parentTaskId },    include: { subtasks: true },  })  if (!parent || parent.subtasks.length === 0) return  const avgProgress =    parent.subtasks.reduce((sum, t) => sum + t.progressPercentage, 0) /    parent.subtasks.length  await ctx.prisma.task.update({    where: { id: parentTaskId },    data: { progressPercentage: avgProgress },  })}async function updateProjectCompletion(ctx: any, projectId: string) {  const tasks = await ctx.prisma.task.findMany({    where: { projectId },  })  if (tasks.length === 0) return  const avgCompletion =    tasks.reduce((sum, t) => sum + t.progressPercentage, 0) / tasks.length  await ctx.prisma.project.update({    where: { id: projectId },    data: { completionPercentage: avgCompletion },  })}async function checkCircularDependency(  ctx: any,  taskId: string,  dependsOnTaskId: string): Promise<boolean> {  // BFS to detect circular dependency  const visited = new Set<string>()  const queue = [dependsOnTaskId]  while (queue.length > 0) {    const current = queue.shift()!    if (current === taskId) return true    if (visited.has(current)) continue    visited.add(current)    const dependencies = await ctx.prisma.taskDependency.findMany({      where: { taskId: current },      select: { dependsOnTaskId: true },    })    queue.push(...dependencies.map((d) => d.dependsOnTaskId))  }  return false}```---ğŸ“‹ Step 2: KPI Router```typescript// server/trpc/routers/kpi.router.tsimport { router, protectedProcedure, createPermissionProcedure } from '../trpc'import {  createKPISchema,  recordKPIValueSchema,  idSchema,  searchSchema,} from '../schemas'import { TRPCError } from '@trpc/server'import { z } from 'zod'export const kpiRouter = router({  // ============================================================================  // QUERY: Get KPI by ID  // ============================================================================  getById: protectedProcedure.input(idSchema).query(async ({ ctx, input }) => {    const kpi = await ctx.prisma.kPI.findUnique({      where: { id: input.id },      include: {        organization: true,        bscObjective: {          select: {            id: true,            objectiveName: true,            perspective: true,          },        },        owner: {          select: { id: true, fullName: true, avatar: true },        },        parentKPI: {          select: {            id: true,            kpiName: true,            kpiCode: true,          },        },        childKPIs: {          select: {            id: true,            kpiName: true,            kpiCode: true,            currentValue: true,            targetValue: true,            contributionToParent: true,          },        },        values: {          orderBy: { periodDate: 'desc' },          take: 12,          include: {            recordedBy: {              select: { fullName: true },            },          },        },        alerts: {          where: { isResolved: false },          orderBy: { triggeredAt: 'desc' },        },        benchmarks: {          include: {            benchmarkSource: true,          },        },        dataPoints: {          orderBy: { timestamp: 'desc' },          take: 100,        },      },    })    if (!kpi) {      throw new TRPCError({ code: 'NOT_FOUND', message: 'KPI not found' })    }    // Calculate statistics    const stats = calculateKPIStatistics(kpi.values)    return {      ...kpi,      stats,    }  }),  // ============================================================================  // QUERY: List KPIs  // ============================================================================  list: protectedProcedure    .input(      searchSchema.extend({        perspective: z.string().optional(),        kpiType: z.string().optional(),        ownerId: z.string().cuid().optional(),        objectiveId: z.string().cuid().optional(),      })    )    .query(async ({ ctx, input }) => {      const { page, perPage, sortBy, sortOrder, query, filters } = input      const where: any = {        organizationId: ctx.user.organizationId,      }      if (query) {        where.OR = [          { kpiName: { contains: query, mode: 'insensitive' } },          { kpiCode: { contains: query, mode: 'insensitive' } },          { kpiDescription: { contains: query, mode: 'insensitive' } },        ]      }      if (input.kpiType) where.kpiType = input.kpiType      if (input.ownerId) where.ownerId = input.ownerId      if (input.objectiveId) where.bscObjectiveId = input.objectiveId      const [total, kpis] = await Promise.all([        ctx.prisma.kPI.count({ where }),        ctx.prisma.kPI.findMany({          where,          include: {            owner: {              select: { fullName: true, avatar: true },            },            bscObjective: {              select: {                objectiveName: true,                perspective: true,              },            },            values: {              orderBy: { periodDate: 'desc' },              take: 1,            },          },          orderBy: sortBy ? { [sortBy]: sortOrder } : { createdAt: 'desc' },          skip: (page - 1) * perPage,          take: perPage,        }),      ])      return {        data: kpis,        pagination: {          total,          page,          perPage,          totalPages: Math.ceil(total / perPage),        },      }    }),  // ============================================================================  // QUERY: Get KPI Cascade Tree  // ============================================================================  getCascadeTree: protectedProcedure    .input(      z.object({        rootKPIId: z.string().cuid().optional(),        organizationId: z.string().cuid(),      })    )    .query(async ({ ctx, input }) => {      const where = input.rootKPIId        ? { id: input.rootKPIId }        : { organizationId: input.organizationId, parentKPIId: null }      const kpis = await ctx.prisma.kPI.findMany({        where,        include: {          owner: {            select: { fullName: true, avatar: true },          },          childKPIs: {            include: {              owner: {                select: { fullName: true },              },              childKPIs: {                include: {                  owner: {                    select: { fullName: true },                  },                },              },            },          },          values: {            orderBy: { periodDate: 'desc' },            take: 1,          },        },      })      function buildTree(kpi: any): any {        const latestValue = kpi.values[0]        return {          id: kpi.id,          name: kpi.kpiName,          code: kpi.kpiCode,          owner: kpi.owner,          current: latestValue?.actualValue || kpi.currentValue,          target: kpi.targetValue,          achievement: kpi.achievementRate,          unit: kpi.measurementUnit,          contribution: kpi.contributionToParent,          children: kpi.childKPIs.map(buildTree),        }      }      return kpis.map(buildTree)    }),  // ============================================================================  // MUTATION: Create KPI  // ============================================================================  create: createPermissionProcedure(['KPI_CREATE'])    .input(createKPISchema)    .mutation(async ({ ctx, input }) => {      // Check if KPI code exists      if (input.kpiCode) {        const existing = await ctx.prisma.kPI.findFirst({          where: {            organizationId: input.organizationId,            kpiCode: input.kpiCode,          },        })        if (existing) {          throw new TRPCError({            code: 'CONFLICT',            message: 'KPI code already exists',          })        }      }      const kpi = await ctx.prisma.kPI.create({        data: {          ...input,          currentValue: input.baselineValue || 0,          achievementRate: 0,          status: 'ACTIVE',          createdById: ctx.user.id,        },      })      return kpi    }),  // ============================================================================  // MUTATION: Update KPI  // ============================================================================  update: createPermissionProcedure(['KPI_UPDATE'])    .input(      z.object({        id: z.string().cuid(),        kpiName: z.string().optional(),        kpiDescription: z.string().optional(),        targetValue: z.number().optional(),        measurementUnit: z.string().optional(),        reportingFrequency: z.string().optional(),        ownerId: z.string().cuid().optional(),      })    )    .mutation(async ({ ctx, input }) => {      const { id, ...data } = input      const kpi = await ctx.prisma.kPI.update({        where: { id },        data,      })      return kpi    }),  // ============================================================================  // MUTATION: Record KPI Value  // ============================================================================  recordValue: protectedProcedure    .input(recordKPIValueSchema)    .mutation(async ({ ctx, input }) => {      const kpi = await ctx.prisma.kPI.findUnique({        where: { id: input.kpiId },      })      if (!kpi) {        throw new TRPCError({ code: 'NOT_FOUND', message: 'KPI not found' })      }      // Check if value already exists for this period      const existing = await ctx.prisma.kPIValue.findFirst({        where: {          kpiId: input.kpiId,          periodDate: input.periodDate,        },      })      if (existing) {        throw new TRPCError({          code: 'CONFLICT',          message: 'Value already recorded for this period',        })      }      // Calculate variance and achievement      const targetValue = input.targetValue || kpi.targetValue      const variance = input.actualValue - targetValue      const variancePercentage = (variance / targetValue) * 100      // Calculate achievement rate      const baseline = kpi.baselineValue || 0      let achievementRate = 0      if (kpi.polarity === 'POSITIVE') {        achievementRate = ((input.actualValue - baseline) / (targetValue - baseline)) * 100      } else if (kpi.polarity === 'NEGATIVE') {        achievementRate = ((baseline - input.actualValue) / (baseline - targetValue)) * 100      }      achievementRate = Math.min(100, Math.max(0, achievementRate))      // Determine status      let status: any = 'ACCEPTABLE'      if (achievementRate >= 100) status = 'EXCELLENT'      else if (achievementRate >= 90) status = 'GOOD'      else if (achievementRate >= 70) status = 'ACCEPTABLE'      else if (achievementRate >= 50) status = 'POOR'      else status = 'CRITICAL'      // Create KPI value      const value = await ctx.prisma.kPIValue.create({        data: {          kpiId: input.kpiId,          periodDate: input.periodDate,          actualValue: input.actualValue,          targetValue,          variance,          variancePercentage,          achievementRate,          status: input.status || status,          notes: input.notes,          recordedBy: ctx.user.id,        },      })      // Update KPI current value and achievement      await ctx.prisma.kPI.update({        where: { id: input.kpiId },        data: {          currentValue: input.actualValue,          achievementRate,          lastMeasuredDate: input.periodDate,        },      })      // Check for alerts      await checkKPIAlerts(ctx, kpi, input.actualValue, achievementRate)      // Update parent KPI if cascading      if (kpi.parentKPIId) {        await updateParentKPIValue(ctx, kpi.parentKPIId)      }      return value    }),  // ============================================================================  // MUTATION: Set KPI Alert Thresholds  // ============================================================================  setAlertThresholds: createPermissionProcedure(['KPI_UPDATE'])    .input(      z.object({        kpiId: z.string().cuid(),        excellentThreshold: z.number().optional(),        goodThreshold: z.number().optional(),        acceptableThreshold: z.number().optional(),        poorThreshold: z.number().optional(),      })    )    .mutation(async ({ ctx, input }) => {      const { kpiId, ...thresholds } = input      const kpi = await ctx.prisma.kPI.update({        where: { id: kpiId },        data: thresholds,      })      return kpi    }),  // ============================================================================  // QUERY: Get KPI Dashboard  // ============================================================================  getDashboard: protectedProcedure    .input(      z.object({        perspective: z.string().optional(),        timeRange: z.enum(['1M', '3M', '6M', '1Y', 'ALL']).default('3M'),      })    )    .query(async ({ ctx, input }) => {      const where: any = {        organizationId: ctx.user.organizationId,        status: 'ACTIVE',      }      if (input.perspective) {        where.bscObjective = {          perspective: input.perspective,        }      }      const kpis = await ctx.prisma.kPI.findMany({        where,        include: {          bscObjective: {            select: { objectiveName: true, perspective: true },          },          owner: {            select: { fullName: true },          },          values: {            orderBy: { periodDate: 'desc' },            take: input.timeRange === '1M' ? 1 : input.timeRange === '3M' ? 3 : 12,          },        },      })      // Categorize by performance      const summary = {        total: kpis.length,        excellent: kpis.filter((k) => k.achievementRate >= 100).length,        good: kpis.filter((k) => k.achievementRate >= 90 && k.achievementRate < 100).length,        acceptable: kpis.filter((k) => k.achievementRate >= 70 && k.achievementRate < 90).length,        poor: kpis.filter((k) => k.achievementRate < 70).length,        averageAchievement:          kpis.reduce((sum, k) => sum + k.achievementRate, 0) / kpis.length,      }      return {        kpis,        summary,      }    }),  // ============================================================================  // QUERY: Get KPI Trend Analysis  // ============================================================================  getTrendAnalysis: protectedProcedure    .input(      z.object({        kpiId: z.string().cuid(),        periods: z.number().default(12),      })    )    .query(async ({ ctx, input }) => {      const values = await ctx.prisma.kPIValue.findMany({        where: { kpiId: input.kpiId },        orderBy: { periodDate: 'desc' },        take: input.periods,      })      if (values.length < 2) {        return {          trend: 'INSUFFICIENT_DATA',          trendStrength: 0,          forecast: null,        }      }      // Calculate trend using linear regression      const n = values.length      const x = Array.from({ length: n }, (_, i) => i)      const y = values.map((v) => v.actualValue).reverse()      const sumX = x.reduce((a, b) => a + b, 0)      const sumY = y.reduce((a, b) => a + b, 0)      const sumXY = x.reduce((acc, xi, i) => acc + xi * y[i], 0)      const sumX2 = x.reduce((acc, xi) => acc + xi * xi, 0)      const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX)      const intercept = (sumY - slope * sumX) / n      // Determine trend direction      let trendDirection: any      const trendStrength = Math.abs(slope)      if (slope > 0.5) trendDirection = 'STRONGLY_INCREASING'      else if (slope > 0.1) trendDirection = 'INCREASING'      else if (slope > -0.1) trendDirection = 'STABLE'      else if (slope > -0.5) trendDirection = 'DECREASING'      else trendDirection = 'STRONGLY_DECREASING'      // Forecast next 3 periods      const forecast = Array.from({ length: 3 }, (_, i) => {        const nextX = n + i        return {          period: i + 1,          value: slope * nextX + intercept,          confidence: Math.max(0.5, 1 - i * 0.15), // Decreasing confidence        }      })      return {        trend: trendDirection,        trendStrength,        slope,        intercept,        forecast,        values: values.reverse(),      }    }),  // ============================================================================  // QUERY: Compare with Benchmarks  // ============================================================================  compareBenchmarks: protectedProcedure.input(idSchema).query(async ({ ctx, input }) => {    const kpi = await ctx.prisma.kPI.findUnique({      where: { id: input.id },      include: {        benchmarks: {          include: {            benchmarkSource: true,          },          orderBy: { benchmarkValue: 'desc' },        },      },    })    if (!kpi) {      throw new TRPCError({ code: 'NOT_FOUND', message: 'KPI not found' })    }    const comparisons = kpi.benchmarks.map((benchmark) => ({      source: benchmark.benchmarkSource?.sourceName || benchmark.benchmarkSource,      type: benchmark.benchmarkType,      value: benchmark.benchmarkValue,      current: kpi.currentValue,      gap: kpi.currentValue - benchmark.benchmarkValue,      gapPercentage: ((kpi.currentValue - benchmark.benchmarkValue) / benchmark.benchmarkValue) * 100,      status:        kpi.currentValue >= benchmark.benchmarkValue          ? 'ABOVE'          : kpi.currentValue >= benchmark.benchmarkValue * 0.9          ? 'NEAR'          : 'BELOW',    }))    return {      kpi: {        id: kpi.id,        name: kpi.kpiName,        current: kpi.currentValue,        target: kpi.targetValue,        unit: kpi.measurementUnit,      },      comparisons,    }  }),})// ============================================================================// HELPER FUNCTIONS// ============================================================================function calculateKPIStatistics(values: any[]) {  if (values.length === 0) return null  const sortedValues = [...values].sort((a, b) => a.actualValue - b.actualValue)  const sum = values.reduce((acc, v) => acc + v.actualValue, 0)  const mean = sum / values.length  const median =    values.length % 2 === 0      ? (sortedValues[values.length / 2 - 1].actualValue +          sortedValues[values.length / 2].actualValue) /        2      : sortedValues[Math.floor(values.length / 2)].actualValue  const variance =    values.reduce((acc, v) => acc + Math.pow(v.actualValue - mean, 2), 0) /    values.length  const standardDeviation = Math.sqrt(variance)  return {    count: values.length,    mean,    median,    min: sortedValues[0].actualValue,    max: sortedValues[sortedValues.length - 1].actualValue,    variance,    standardDeviation,  }}async function checkKPIAlerts(  ctx: any,  kpi: any,  actualValue: number,  achievementRate: number) {  const alerts: any[] = []  // Check if below poor threshold  if (kpi.poorThreshold && achievementRate < kpi.poorThreshold) {    alerts.push({      kpiId: kpi.id,      alertType: 'BELOW_THRESHOLD',      severity: 'HIGH',      message: `KPI achievement (${achievementRate.toFixed(1)}%) is below poor threshold`,      triggeredValue: actualValue,    })  }  // Check if trend is negative for 3+ periods  const recentValues = await ctx.prisma.kPIValue.findMany({    where: { kpiId: kpi.id },    orderBy: { periodDate: 'desc' },    take: 3,  })  if (recentValues.length >= 3) {    const isDecreasing = recentValues.every(      (v, i) => i === 0 || v.actualValue < recentValues[i - 1].actualValue    )    if (isDecreasing && kpi.polarity === 'POSITIVE') {      alerts.push({        kpiId: kpi.id,        alertType: 'NEGATIVE_TREND',        severity: 'MEDIUM',        message: 'KPI showing consistent downward trend',        triggeredValue: actualValue,      })    }  }  // Create alert records  for (const alert of alerts) {    await ctx.prisma.kPIAlert.create({      data: {        ...alert,        isResolved: false,      },    })  }}async function updateParentKPIValue(ctx: any, parentKPIId: string) {  const parent = await ctx.prisma.kPI.findUnique({    where: { id: parentKPIId },    include: {      childKPIs: {        where: { status: 'ACTIVE' },      },    },  })  if (!parent || parent.childKPIs.length === 0) return  // Calculate based on calculation type  let newValue = 0  switch (parent.calculationType) {    case 'SUM':      newValue = parent.childKPIs.reduce((sum, child) => sum + child.currentValue, 0)      break    case 'AVERAGE':      newValue =        parent.childKPIs.reduce((sum, child) => sum + child.currentValue, 0) /        parent.childKPIs.length      break    case 'WEIGHTED_AVERAGE':      const totalWeight = parent.childKPIs.reduce(        (sum, child) => sum + (child.contributionToParent || 1),        0      )      newValue =        parent.childKPIs.reduce(          (sum, child) =>            sum + child.currentValue * (child.contributionToParent || 1),          0        ) / totalWeight      break    default:      return  }  await ctx.prisma.kPI.update({    where: { id: parentKPIId },    data: {      currentValue: newValue,    },  })  // Recursively update grandparent  if (parent.parentKPIId) {    await updateParentKPIValue(ctx, parent.parentKPIId)  }}```---à¸•à¹ˆà¸­à¸”à¹‰à¸§à¸¢ Logframe, TOWS/BSC, Dashboard routers à¹à¸¥à¸° Root router à¹ƒà¸™à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸–à¸±à¸”à¹„à¸›...à¸à¸£à¹‰à¸­à¸¡à¸•à¹ˆà¸­à¹„à¸«à¸¡à¸„à¸£à¸±à¸š? ğŸš€---ğŸ”Œ tRPC API - Final Routers (Part 2)à¸•à¹ˆà¸­à¸ˆà¸²à¸à¸—à¸µà¹ˆà¹à¸¥à¹‰à¸§ à¹€à¸£à¸²à¸ˆà¸°à¸ªà¸£à¹‰à¸²à¸‡ Logframe, TOWS/BSC, Dashboard, à¹à¸¥à¸° Root Router!---ğŸ“‹ Step 1: Logframe Router```typescript// server/trpc/routers/logframe.router.tsimport { router, protectedProcedure, createPermissionProcedure } from '../trpc'import {  createLogframeSchema,  createLogframeElementSchema,  createLogframeIndicatorSchema,  idSchema,  searchSchema,} from '../schemas'import { TRPCError } from '@trpc/server'import { z } from 'zod'export const logframeRouter = router({  // ============================================================================  // QUERY: Get Logframe by ID with full hierarchy  // ============================================================================  getById: protectedProcedure.input(idSchema).query(async ({ ctx, input }) => {    const logframe = await ctx.prisma.logicalFramework.findUnique({      where: { id: input.id },      include: {        project: {          select: {            id: true,            projectName: true,            projectCode: true,          },        },        organization: true,        elements: {          where: { level: 'GOAL' },          include: {            indicators: {              include: {                measurements: {                  orderBy: { measurementDate: 'desc' },                  take: 5,                },                responsibleUser: {                  select: { fullName: true, avatar: true },                },              },            },            assumptions: {              include: {                responsibleUser: {                  select: { fullName: true },                },              },            },            childElements: {              include: {                indicators: {                  include: {                    measurements: {                      orderBy: { measurementDate: 'desc' },                      take: 5,                    },                  },                },                assumptions: true,                childElements: {                  include: {                    indicators: true,                    assumptions: true,                    childElements: {                      include: {                        indicators: true,                      },                    },                  },                },              },            },          },          orderBy: { displayOrder: 'asc' },        },        theoryOfChange: true,        mePlan: true,        reviews: {          orderBy: { reviewDate: 'desc' },          include: {            leadEvaluator: {              select: { fullName: true, avatar: true },            },          },        },      },    })    if (!logframe) {      throw new TRPCError({ code: 'NOT_FOUND', message: 'Logframe not found' })    }    return logframe  }),  // ============================================================================  // QUERY: List Logframes  // ============================================================================  list: protectedProcedure    .input(      searchSchema.extend({        projectId: z.string().cuid().optional(),        status: z.string().optional(),      })    )    .query(async ({ ctx, input }) => {      const { page, perPage, sortBy, sortOrder, query, filters } = input      const where: any = {        organizationId: ctx.user.organizationId,      }      if (query) {        where.OR = [          { logframeName: { contains: query, mode: 'insensitive' } },          { programName: { contains: query, mode: 'insensitive' } },        ]      }      if (input.projectId) where.projectId = input.projectId      if (input.status) where.status = input.status      const [total, logframes] = await Promise.all([        ctx.prisma.logicalFramework.count({ where }),        ctx.prisma.logicalFramework.findMany({          where,          include: {            project: {              select: { projectName: true },            },            _count: {              select: {                elements: true,                reviews: true,              },            },          },          orderBy: sortBy ? { [sortBy]: sortOrder } : { createdAt: 'desc' },          skip: (page - 1) * perPage,          take: perPage,        }),      ])      return {        data: logframes,        pagination: {          total,          page,          perPage,          totalPages: Math.ceil(total / perPage),        },      }    }),  // ============================================================================  // MUTATION: Create Logframe  // ============================================================================  create: createPermissionProcedure(['LOGFRAME_CREATE'])    .input(createLogframeSchema)    .mutation(async ({ ctx, input }) => {      // Validate dates      if (input.endDate <= input.startDate) {        throw new TRPCError({          code: 'BAD_REQUEST',          message: 'End date must be after start date',        })      }      const logframe = await ctx.prisma.logicalFramework.create({        data: {          ...input,          status: 'DRAFT',          version: '1.0',          createdById: ctx.user.id,        },      })      return logframe    }),  // ============================================================================  // MUTATION: Update Logframe  // ============================================================================  update: createPermissionProcedure(['LOGFRAME_UPDATE'])    .input(      z.object({        id: z.string().cuid(),        logframeName: z.string().optional(),        logframeDescription: z.string().optional(),        programName: z.string().optional(),        totalBudget: z.number().optional(),        fundingSource: z.string().optional(),        targetBeneficiaries: z.string().optional(),      })    )    .mutation(async ({ ctx, input }) => {      const { id, ...data } = input      const logframe = await ctx.prisma.logicalFramework.update({        where: { id },        data,      })      return logframe    }),  // ============================================================================  // MUTATION: Create Logframe Element  // ============================================================================  createElement: createPermissionProcedure(['LOGFRAME_UPDATE'])    .input(createLogframeElementSchema)    .mutation(async ({ ctx, input }) => {      // Check if element code exists      const existing = await ctx.prisma.logframeElement.findUnique({        where: {          logframeId_elementCode: {            logframeId: input.logframeId,            elementCode: input.elementCode,          },        },      })      if (existing) {        throw new TRPCError({          code: 'CONFLICT',          message: 'Element code already exists',        })      }      const element = await ctx.prisma.logframeElement.create({        data: {          ...input,          progressStatus: 'NOT_STARTED',          completionPercent: 0,        },      })      return element    }),  // ============================================================================  // MUTATION: Update Element Progress  // ============================================================================  updateElementProgress: protectedProcedure    .input(      z.object({        elementId: z.string().cuid(),        completionPercent: z.number().min(0).max(100),        progressStatus: z.enum(['NOT_STARTED', 'ON_TRACK', 'DELAYED', 'AT_RISK', 'COMPLETED', 'CANCELLED']).optional(),        notes: z.string().optional(),      })    )    .mutation(async ({ ctx, input }) => {      const element = await ctx.prisma.logframeElement.update({        where: { id: input.elementId },        data: {          completionPercent: input.completionPercent,          progressStatus: input.progressStatus || (            input.completionPercent === 100 ? 'COMPLETED' :            input.completionPercent === 0 ? 'NOT_STARTED' :            'ON_TRACK'          ),          notes: input.notes,        },      })      return element    }),  // ============================================================================  // MUTATION: Create Indicator  // ============================================================================  createIndicator: createPermissionProcedure(['LOGFRAME_UPDATE'])    .input(createLogframeIndicatorSchema)    .mutation(async ({ ctx, input }) => {      // Check if indicator code exists      const existing = await ctx.prisma.logframeIndicator.findUnique({        where: {          elementId_indicatorCode: {            elementId: input.elementId,            indicatorCode: input.indicatorCode,          },        },      })      if (existing) {        throw new TRPCError({          code: 'CONFLICT',          message: 'Indicator code already exists',        })      }      const indicator = await ctx.prisma.logframeIndicator.create({        data: {          ...input,          currentValue: input.baselineValue || 0,          achievementRate: 0,          isActive: true,        },      })      return indicator    }),  // ============================================================================  // MUTATION: Record Indicator Measurement  // ============================================================================  recordMeasurement: protectedProcedure    .input(      z.object({        indicatorId: z.string().cuid(),        measurementDate: z.date(),        measurementPeriod: z.string().optional(),        measuredValue: z.number(),        disaggregatedData: z.record(z.any()).optional(),        qualitativeNotes: z.string().optional(),        dataQuality: z.enum(['EXCELLENT', 'GOOD', 'FAIR', 'POOR', 'MISSING']).optional(),        dataSource: z.string().optional(),        analysis: z.string().optional(),        challenges: z.string().optional(),        recommendations: z.string().optional(),      })    )    .mutation(async ({ ctx, input }) => {      const indicator = await ctx.prisma.logframeIndicator.findUnique({        where: { id: input.indicatorId },      })      if (!indicator) {        throw new TRPCError({ code: 'NOT_FOUND', message: 'Indicator not found' })      }      // Calculate variance      const variance = input.measuredValue - indicator.targetValue      const variancePercent = (variance / indicator.targetValue) * 100      // Calculate achievement rate      const baseline = indicator.baselineValue || 0      const target = indicator.targetValue      const achievementRate = ((input.measuredValue - baseline) / (target - baseline)) * 100      // Create measurement      const measurement = await ctx.prisma.indicatorMeasurement.create({        data: {          ...input,          variance,          variancePercent,          dataQuality: input.dataQuality || 'GOOD',          collectedBy: ctx.user.id,          isVerified: false,        },      })      // Update indicator      await ctx.prisma.logframeIndicator.update({        where: { id: input.indicatorId },        data: {          currentValue: input.measuredValue,          achievementRate: Math.min(100, Math.max(0, achievementRate)),          lastMeasured: input.measurementDate,        },      })      return measurement    }),  // ============================================================================  // MUTATION: Create Assumption  // ============================================================================  createAssumption: createPermissionProcedure(['LOGFRAME_UPDATE'])    .input(      z.object({        elementId: z.string().cuid(),        assumptionCode: z.string(),        assumptionText: z.string(),        assumptionLevel: z.enum(['CRITICAL', 'IMPORTANT', 'MODERATE', 'MINOR']),        category: z.enum(['POLITICAL', 'ECONOMIC', 'SOCIAL', 'TECHNICAL', 'ENVIRONMENTAL', 'LEGAL', 'INSTITUTIONAL', 'STAKEHOLDER', 'RESOURCE']),        consequenceIfFalse: z.string(),        likelihood: z.number().min(0).max(1).optional(),        impact: z.number().min(0).max(1).optional(),        mitigationStrategy: z.string().optional(),        howToVerify: z.string().optional(),        verificationFrequency: z.string().optional(),        responsibleUserId: z.string().cuid().optional(),      })    )    .mutation(async ({ ctx, input }) => {      // Check if assumption code exists      const existing = await ctx.prisma.logframeAssumption.findUnique({        where: {          elementId_assumptionCode: {            elementId: input.elementId,            assumptionCode: input.assumptionCode,          },        },      })      if (existing) {        throw new TRPCError({          code: 'CONFLICT',          message: 'Assumption code already exists',        })      }      const riskScore = (input.likelihood || 0.5) * (input.impact || 0.5)      const assumption = await ctx.prisma.logframeAssumption.create({        data: {          ...input,          riskScore,          status: 'VALID',          lastChecked: new Date(),        },      })      return assumption    }),  // ============================================================================  // MUTATION: Update Assumption Status  // ============================================================================  updateAssumptionStatus: protectedProcedure    .input(      z.object({        assumptionId: z.string().cuid(),        status: z.enum(['VALID', 'INVALID', 'UNCERTAIN', 'MONITORING']),        notes: z.string().optional(),      })    )    .mutation(async ({ ctx, input }) => {      const assumption = await ctx.prisma.logframeAssumption.findUnique({        where: { id: input.assumptionId },      })      if (!assumption) {        throw new TRPCError({ code: 'NOT_FOUND', message: 'Assumption not found' })      }      // Update status history      const statusHistory = assumption.statusHistory as any || { history: [] }      statusHistory.history.push({        date: new Date().toISOString(),        status: input.status,        notes: input.notes,        changedBy: ctx.user.id,      })      const updated = await ctx.prisma.logframeAssumption.update({        where: { id: input.assumptionId },        data: {          status: input.status,          lastChecked: new Date(),          statusHistory,        },      })      return updated    }),  // ============================================================================  // MUTATION: Create Theory of Change  // ============================================================================  createTheoryOfChange: createPermissionProcedure(['LOGFRAME_UPDATE'])    .input(      z.object({        logframeId: z.string().cuid(),        problemStatement: z.string(),        desiredChange: z.string(),        causalPathway: z.record(z.any()),        keyAssumptions: z.array(z.string()),        contextAnalysis: z.string().optional(),        stakeholderAnalysis: z.string().optional(),        diagramUrl: z.string().optional(),      })    )    .mutation(async ({ ctx, input }) => {      const toc = await ctx.prisma.theoryOfChange.create({        data: {          ...input,          version: '1.0',        },      })      return toc    }),  // ============================================================================  // MUTATION: Create M&E Plan  // ============================================================================  createMEPlan: createPermissionProcedure(['LOGFRAME_UPDATE'])    .input(      z.object({        logframeId: z.string().cuid(),        monitoringApproach: z.string(),        evaluationApproach: z.string(),        dataCollectionPlan: z.record(z.any()).optional(),        evaluationSchedule: z.record(z.any()).optional(),        meTeamStructure: z.record(z.any()).optional(),        meBudget: z.number().optional(),        qualityAssurancePlan: z.string().optional(),        dataManagementPlan: z.string().optional(),        reportingSchedule: z.record(z.any()).optional(),        learningPlan: z.string().optional(),      })    )    .mutation(async ({ ctx, input }) => {      const mePlan = await ctx.prisma.mEPlan.create({        data: input,      })      return mePlan    }),  // ============================================================================  // MUTATION: Create Review/Evaluation  // ============================================================================  createReview: createPermissionProcedure(['LOGFRAME_EVALUATE'])    .input(      z.object({        logframeId: z.string().cuid(),        reviewType: z.enum(['INCEPTION', 'MID_TERM', 'FINAL', 'EX_POST', 'ANNUAL', 'AD_HOC']),        reviewTitle: z.string(),        reviewDescription: z.string().optional(),        periodStart: z.date(),        periodEnd: z.date(),        reviewDate: z.date(),        teamMembers: z.array(z.string().cuid()).optional(),        externalEvaluators: z.string().optional(),      })    )    .mutation(async ({ ctx, input }) => {      const review = await ctx.prisma.logframeReview.create({        data: {          ...input,          leadEvaluatorId: ctx.user.id,          status: 'DRAFT',        },      })      return review    }),  // ============================================================================  // MUTATION: Submit Review  // ============================================================================  submitReview: createPermissionProcedure(['LOGFRAME_EVALUATE'])    .input(      z.object({        reviewId: z.string().cuid(),        relevanceScore: z.number().min(1).max(5).optional(),        effectivenessScore: z.number().min(1).max(5).optional(),        efficiencyScore: z.number().min(1).max(5).optional(),        impactScore: z.number().min(1).max(5).optional(),        sustainabilityScore: z.number().min(1).max(5).optional(),        coherenceScore: z.number().min(1).max(5).optional(),        executiveSummary: z.string(),        keyFindings: z.record(z.any()).optional(),        majorAchievements: z.record(z.any()).optional(),        challenges: z.record(z.any()).optional(),        lessonsLearned: z.record(z.any()).optional(),        recommendations: z.record(z.any()).optional(),        fullReportUrl: z.string().optional(),      })    )    .mutation(async ({ ctx, input }) => {      const { reviewId, ...data } = input      // Calculate overall score      const scores = [        data.relevanceScore,        data.effectivenessScore,        data.efficiencyScore,        data.impactScore,        data.sustainabilityScore,        data.coherenceScore,      ].filter((s) => s !== undefined) as number[]      const overallScore = scores.length > 0         ? scores.reduce((a, b) => a + b, 0) / scores.length         : undefined      const review = await ctx.prisma.logframeReview.update({        where: { id: reviewId },        data: {          ...data,          overallScore,          status: 'FINAL',        },      })      return review    }),  // ============================================================================  // QUERY: Get Logframe Matrix View  // ============================================================================  getMatrix: protectedProcedure.input(idSchema).query(async ({ ctx, input }) => {    const elements = await ctx.prisma.logframeElement.findMany({      where: { logframeId: input.id },      include: {        indicators: {          orderBy: { displayOrder: 'asc' },        },        assumptions: {          orderBy: { assumptionLevel: 'asc' },        },      },      orderBy: [{ level: 'asc' }, { displayOrder: 'asc' }],    })    // Group by level    const matrix = {      goal: elements.filter((e) => e.level === 'GOAL'),      purpose: elements.filter((e) => e.level === 'PURPOSE'),      outputs: elements.filter((e) => e.level === 'OUTPUT'),      activities: elements.filter((e) => e.level === 'ACTIVITY'),    }    return matrix  }),  // ============================================================================  // QUERY: Get Performance Summary  // ============================================================================  getPerformanceSummary: protectedProcedure.input(idSchema).query(async ({ ctx, input }) => {    const logframe = await ctx.prisma.logicalFramework.findUnique({      where: { id: input.id },      include: {        elements: {          include: {            indicators: {              include: {                measurements: {                  orderBy: { measurementDate: 'desc' },                  take: 1,                },              },            },          },        },      },    })    if (!logframe) {      throw new TRPCError({ code: 'NOT_FOUND', message: 'Logframe not found' })    }    // Calculate achievement by level    const calculateLevelAchievement = (level: string) => {      const levelElements = logframe.elements.filter((e) => e.level === level)      if (levelElements.length === 0) return 0      const indicators = levelElements.flatMap((e) => e.indicators)      if (indicators.length === 0) return 0      const totalAchievement = indicators.reduce(        (sum, ind) => sum + (ind.achievementRate || 0),        0      )      return totalAchievement / indicators.length    }    const summary = {      goal: {        achievement: calculateLevelAchievement('GOAL'),        elementCount: logframe.elements.filter((e) => e.level === 'GOAL').length,      },      purpose: {        achievement: calculateLevelAchievement('PURPOSE'),        elementCount: logframe.elements.filter((e) => e.level === 'PURPOSE').length,      },      outputs: {        achievement: calculateLevelAchievement('OUTPUT'),        elementCount: logframe.elements.filter((e) => e.level === 'OUTPUT').length,      },      activities: {        completion:          logframe.elements            .filter((e) => e.level === 'ACTIVITY')            .reduce((sum, e) => sum + (e.completionPercent || 0), 0) /            logframe.elements.filter((e) => e.level === 'ACTIVITY').length || 0,        elementCount: logframe.elements.filter((e) => e.level === 'ACTIVITY').length,      },      overall: {        progress:          (calculateLevelAchievement('GOAL') +            calculateLevelAchievement('PURPOSE') +            calculateLevelAchievement('OUTPUT')) /          3,        status:          logframe.status,      },    }    return summary  }),  // ============================================================================  // QUERY: Track Assumptions Validity  // ============================================================================  trackAssumptions: protectedProcedure.input(idSchema).query(async ({ ctx, input }) => {    const assumptions = await ctx.prisma.logframeAssumption.findMany({      where: {        element: { logframeId: input.id },      },      include: {        element: {          select: {            level: true,            elementCode: true,            narrativeSummary: true,          },        },        responsibleUser: {          select: {            fullName: true,            avatar: true,          },        },      },      orderBy: [{ riskScore: 'desc' }],    })    const summary = {      total: assumptions.length,      valid: assumptions.filter((a) => a.status === 'VALID').length,      invalid: assumptions.filter((a) => a.status === 'INVALID').length,      uncertain: assumptions.filter((a) => a.status === 'UNCERTAIN').length,      monitoring: assumptions.filter((a) => a.status === 'MONITORING').length,      highRisk: assumptions.filter((a) => (a.riskScore || 0) > 0.7).length,      critical: assumptions.filter((a) => a.assumptionLevel === 'CRITICAL').length,    }    return {      assumptions,      summary,    }  }),})```---ğŸ“‹ Step 2: TOWS & BSC Router```typescript// server/trpc/routers/strategy.router.tsimport { router, protectedProcedure, createPermissionProcedure } from '../trpc'import {  createSWOTElementSchema,  createTOWSStrategySchema,  createBSCObjectiveSchema,  idSchema,  searchSchema,} from '../schemas'import { TRPCError } from '@trpc/server'import { z } from 'zod'export const strategyRouter = router({  // ============================================================================  // SWOT ANALYSIS  // ============================================================================  swot: router({    // Create SWOT Element    createElement: createPermissionProcedure(['STRATEGY_CREATE'])      .input(createSWOTElementSchema)      .mutation(async ({ ctx, input }) => {        const element = await ctx.prisma.sWOTElement.create({          data: {            ...input,            createdById: ctx.user.id,          },        })        return element      }),    // List SWOT Elements    list: protectedProcedure      .input(        searchSchema.extend({          swotType: z.enum(['STRENGTH', 'WEAKNESS', 'OPPORTUNITY', 'THREAT']).optional(),          category: z.string().optional(),        })      )      .query(async ({ ctx, input }) => {        const { page, perPage, query, filters } = input        const where: any = {          organizationId: ctx.user.organizationId,        }        if (query) {          where.OR = [            { title: { contains: query, mode: 'insensitive' } },            { description: { contains: query, mode: 'insensitive' } },          ]        }        if (input.swotType) where.swotType = input.swotType        if (input.category) where.category = input.category        const [total, elements] = await Promise.all([          ctx.prisma.sWOTElement.count({ where }),          ctx.prisma.sWOTElement.findMany({            where,            include: {              votes: true,              createdBy: {                select: { fullName: true, avatar: true },              },            },            orderBy: { createdAt: 'desc' },            skip: (page - 1) * perPage,            take: perPage,          }),        ])        return {          data: elements,          pagination: {            total,            page,            perPage,            totalPages: Math.ceil(total / perPage),          },        }      }),    // Get SWOT Matrix    getMatrix: protectedProcedure      .input(z.object({ organizationId: z.string().cuid() }))      .query(async ({ ctx, input }) => {        const elements = await ctx.prisma.sWOTElement.findMany({          where: { organizationId: input.organizationId },          include: {            votes: true,            _count: {              select: { linkedStrategies: true },            },          },          orderBy: [{ impactLevel: 'asc' }, { createdAt: 'desc' }],        })        return {          strengths: elements.filter((e) => e.swotType === 'STRENGTH'),          weaknesses: elements.filter((e) => e.swotType === 'WEAKNESS'),          opportunities: elements.filter((e) => e.swotType === 'OPPORTUNITY'),          threats: elements.filter((e) => e.swotType === 'THREAT'),        }      }),    // Vote on SWOT Element    vote: protectedProcedure      .input(        z.object({          elementId: z.string().cuid(),          voteType: z.enum(['UPVOTE', 'DOWNVOTE']),        })      )      .mutation(async ({ ctx, input }) => {        // Check existing vote        const existing = await ctx.prisma.sWOTVote.findUnique({          where: {            userId_elementId: {              userId: ctx.user.id,              elementId: input.elementId,            },          },        })        if (existing) {          // Update vote          const vote = await ctx.prisma.sWOTVote.update({            where: { id: existing.id },            data: { voteType: input.voteType },          })          return vote        } else {          // Create vote          const vote = await ctx.prisma.sWOTVote.create({            data: {              userId: ctx.user.id,              elementId: input.elementId,              voteType: input.voteType,            },          })          return vote        }      }),  }),  // ============================================================================  // TOWS STRATEGIES  // ============================================================================  tows: router({    // Create TOWS Strategy    create: createPermissionProcedure(['STRATEGY_CREATE'])      .input(createTOWSStrategySchema)      .mutation(async ({ ctx, input }) => {        const { linkedSWOTIds, ...strategyData } = input        const strategy = await ctx.prisma.tOWSStrategy.create({          data: {            ...strategyData,            status: 'DRAFT',            createdById: ctx.user.id,          },        })        // Link SWOT elements        if (linkedSWOTIds.length > 0) {          await ctx.prisma.tOWSStrategySWOTLink.createMany({            data: linkedSWOTIds.map((swotId) => ({              strategyId: strategy.id,              swotElementId: swotId,            })),          })        }        return strategy      }),    // List TOWS Strategies    list: protectedProcedure      .input(        searchSchema.extend({          strategyType: z.enum(['SO', 'WO', 'ST', 'WT']).optional(),          status: z.string().optional(),        })      )      .query(async ({ ctx, input }) => {        const { page, perPage, query } = input        const where: any = {          organizationId: ctx.user.organizationId,        }        if (query) {          where.OR = [            { strategyName: { contains: query, mode: 'insensitive' } },            { strategyDescription: { contains: query, mode: 'insensitive' } },          ]        }        if (input.strategyType) where.strategyType = input.strategyType        if (input.status) where.status = input.status        const [total, strategies] = await Promise.all([          ctx.prisma.tOWSStrategy.count({ where }),          ctx.prisma.tOWSStrategy.findMany({            where,            include: {              responsiblePerson: {                select: { fullName: true, avatar: true },              },              linkedSWOT: {                include: {                  swotElement: {                    select: {                      id: true,                      title: true,                      swotType: true,                    },                  },                },              },              _count: {                select: {                  linkedObjectives: true,                  linkedProjects: true,                },              },            },            orderBy: { createdAt: 'desc' },            skip: (page - 1) * perPage,            take: perPage,          }),        ])        return {          data: strategies,          pagination: {            total,            page,            perPage,            totalPages: Math.ceil(total / perPage),          },        }      }),    // Get TOWS Matrix    getMatrix: protectedProcedure      .input(z.object({ organizationId: z.string().cuid() }))      .query(async ({ ctx, input }) => {        const strategies = await ctx.prisma.tOWSStrategy.findMany({          where: { organizationId: input.organizationId },          include: {            responsiblePerson: {              select: { fullName: true },            },            linkedSWOT: {              include: {                swotElement: true,              },            },          },          orderBy: { priority: 'asc' },        })        return {          SO: strategies.filter((s) => s.strategyType === 'SO'),          WO: strategies.filter((s) => s.strategyType === 'WO'),          ST: strategies.filter((s) => s.strategyType === 'ST'),          WT: strategies.filter((s) => s.strategyType === 'WT'),        }      }),  }),  // ============================================================================  // BSC (Balanced Scorecard)  // ============================================================================  bsc: router({    // Create BSC Objective    createObjective: createPermissionProcedure(['STRATEGY_CREATE'])      .input(createBSCObjectiveSchema)      .mutation(async ({ ctx, input }) => {        const { linkedStrategyIds, ...objectiveData } = input        const objective = await ctx.prisma.bSCObjective.create({          data: {            ...objectiveData,            status: 'ACTIVE',            createdById: ctx.user.id,          },        })        // Link strategies        if (linkedStrategyIds && linkedStrategyIds.length > 0) {          await ctx.prisma.bSCObjectiveStrategyLink.createMany({            data: linkedStrategyIds.map((strategyId) => ({              objectiveId: objective.id,              strategyId,            })),          })        }        return objective      }),    // List BSC Objectives    list: protectedProcedure      .input(        searchSchema.extend({          perspective: z.enum(['FINANCIAL', 'CUSTOMER', 'INTERNAL_PROCESS', 'LEARNING_GROWTH']).optional(),          status: z.string().optional(),        })      )      .query(async ({ ctx, input }) => {        const { page, perPage, query } = input        const where: any = {          organizationId: ctx.user.organizationId,        }        if (query) {          where.OR = [            { objectiveName: { contains: query, mode: 'insensitive' } },            { objectiveDescription: { contains: query, mode: 'insensitive' } },          ]        }        if (input.perspective) where.perspective = input.perspective        if (input.status) where.status = input.status        const [total, objectives] = await Promise.all([          ctx.prisma.bSCObjective.count({ where }),          ctx.prisma.bSCObjective.findMany({            where,            include: {              owner: {                select: { fullName: true, avatar: true },              },              linkedStrategies: {                include: {                  strategy: {                    select: {                      strategyName: true,                      strategyType: true,                    },                  },                },              },              _count: {                select: {                  kpis: true,                  initiatives: true,                },              },            },            orderBy: [{ perspective: 'asc' }, { displayOrder: 'asc' }],            skip: (page - 1) * perPage,            take: perPage,          }),        ])        return {          data: objectives,          pagination: {            total,            page,            perPage,            totalPages: Math.ceil(total / perPage),          },        }      }),    // Get BSC by Perspective    getByPerspective: protectedProcedure      .input(z.object({ organizationId: z.string().cuid() }))      .query(async ({ ctx, input }) => {        const objectives = await ctx.prisma.bSCObjective.findMany({          where: { organizationId: input.organizationId },          include: {            owner: {              select: { fullName: true, avatar: true },            },            kpis: {              select: {                id: true,                kpiName: true,                currentValue: true,                targetValue: true,                achievementRate: true,              },            },            initiatives: {              select: {                id: true,                initiativeName: true,                status: true,                completionRate: true,              },            },          },          orderBy: [{ perspective: 'asc' }, { displayOrder: 'asc' }],        })        return {          financial: objectives.filter((o) => o.perspective === 'FINANCIAL'),          customer: objectives.filter((o) => o.perspective === 'CUSTOMER'),          internalProcess: objectives.filter((o) => o.perspective === 'INTERNAL_PROCESS'),          learningGrowth: objectives.filter((o) => o.perspective === 'LEARNING_GROWTH'),        }      }),    // Get Strategy Map    getStrategyMap: protectedProcedure      .input(z.object({ organizationId: z.string().cuid() }))      .query(async ({ ctx, input }) => {        const objectives = await ctx.prisma.bSCObjective.findMany({          where: { organizationId: input.organizationId },          include: {            causeRelationships: {              include: {                effectObjective: {                  select: {                    id: true,                    objectiveName: true,                    perspective: true,                  },                },              },            },          },          orderBy: [{ perspective: 'asc' }, { displayOrder: 'asc' }],        })        // Transform to graph format        const nodes = objectives.map((obj) => ({          id: obj.id,          name: obj.objectiveName,          perspective: obj.perspective,          weight: obj.weight,          achievement: obj.achievementRate,        }))        const links = objectives.flatMap((obj) =>          obj.causeRelationships.map((rel) => ({            source: obj.id,            target: rel.effectObjectiveId,            strength: rel.relationshipStrength,            type: 'cause-effect',          }))        )        return { nodes, links }      }),  }),})```---ğŸ“‹ Step 3: Dashboard & Analytics Router```typescript// server/trpc/routers/dashboard.router.tsimport { router, protectedProcedure } from '../trpc'import { z } from 'zod'export const dashboardRouter = router({  // ============================================================================  // EXECUTIVE DASHBOARD  // ============================================================================  executive: protectedProcedure    .input(      z.object({        organizationId: z.string().cuid(),        timeRange: z.enum(['1M', '3M', '6M', '1Y', 'ALL']).default('3M'),      })    )    .query(async ({ ctx, input }) => {      const now = new Date()      const startDate = getStartDate(input.timeRange)      const [        projectStats,        kpiStats,        okrStats,        strategyStats,        budgetStats,      ] = await Promise.all([        // Project Statistics        ctx.prisma.project.aggregate({          where: {            organizationId: input.organizationId,            startDate: { gte: startDate },          },          _count: true,          _avg: { completionPercentage: true },        }),        // KPI Statistics        ctx.prisma.kPI.groupBy({          by: ['status'],          where: { organizationId: input.organizationId },          _count: true,          _avg: { achievementRate: true },        }),        // OKR Statistics (active cycle)        ctx.prisma.oKR.groupBy({          by: ['status'],          where: {            organizationId: input.organizationId,            cycle: { status: 'ACTIVE' },          },          _count: true,          _avg: { progressPercentage: true },        }),        // Strategy Statistics        ctx.prisma.tOWSStrategy.groupBy({          by: ['status'],          where: { organizationId: input.organizationId },          _count: true,        }),        // Budget Statistics        ctx.prisma.project.aggregate({          where: { organizationId: input.organizationId },          _sum: { budget: true, actualCost: true },        }),      ])      // Recent Activities      const recentActivities = await ctx.prisma.auditLog.findMany({        where: {           user: { organizationId: input.organizationId },          createdAt: { gte: startDate },        },        orderBy: { createdAt: 'desc' },        take: 20,        include: {          user: {            select: { fullName: true, avatar: true },          },        },      })      return {        projects: {          total: projectStats._count,          avgCompletion: projectStats._avg.completionPercentage || 0,        },        kpis: {          total: kpiStats.reduce((sum, s) => sum + s._count, 0),          avgAchievement:            kpiStats.reduce((sum, s) => sum + (s._avg.achievementRate || 0) * s._count, 0) /            kpiStats.reduce((sum, s) => sum + s._count, 0),          byStatus: kpiStats,        },        okrs: {          total: okrStats.reduce((sum, s) => sum + s._count, 0),          avgProgress:            okrStats.reduce((sum, s) => sum + (s._avg.progressPercentage || 0) * s._count, 0) /            okrStats.reduce((sum, s) => sum + s._count, 0),          byStatus: okrStats,        },        strategies: {          total: strategyStats.reduce((sum, s) => sum + s._count, 0),          byStatus: strategyStats,        },        budget: {          total: budgetStats._sum.budget || 0,          spent: budgetStats._sum.actualCost || 0,          utilization: budgetStats._sum.budget            ? ((budgetStats._sum.actualCost || 0) / budgetStats._sum.budget) * 100            : 0,        },        recentActivities,      }    }),  // ============================================================================  // PROJECT PORTFOLIO DASHBOARD  // ============================================================================  projectPortfolio: protectedProcedure    .input(z.object({ organizationId: z.string().cuid() }))    .query(async ({ ctx, input }) => {      const projects = await ctx.prisma.project.findMany({        where: { organizationId: input.organizationId },        include: {          projectManager: {            select: { fullName: true, avatar: true },          },          _count: {            select: { tasks: true, risks: true, issues: true },          },        },      })      // Categorize projects      const byStatus = {        planning: projects.filter((p) => p.status === 'PLANNING').length,        inProgress: projects.filter((p) => p.status === 'IN_PROGRESS').length,        onHold: projects.filter((p) => p.status === 'ON_HOLD').length,        atRisk: projects.filter((p) => p.status === 'AT_RISK').length,        completed: projects.filter((p) => p.status === 'COMPLETED').length,        cancelled: projects.filter((p) => p.status === 'CANCELLED').length,      }      const byType = await ctx.prisma.project.groupBy({        by: ['projectType'],        where: { organizationId: input.organizationId },        _count: true,      })      const byPriority = await ctx.prisma.project.groupBy({        by: ['priority'],        where: { organizationId: input.organizationId },        _count: true,      })      // Health distribution      const healthDistribution = {        healthy: 0,        atRisk: 0,        critical: 0,      }      for (const project of projects) {        const health = await calculateProjectHealth(ctx, project.id)        if (health) {          if (health.status === 'HEALTHY') healthDistribution.healthy++          else if (health.status === 'AT_RISK') healthDistribution.atRisk++          else healthDistribution.critical++        }      }      return {        total: projects.length,        byStatus,        byType,        byPriority,        healthDistribution,        projects: projects.slice(0, 10), // Top 10      }    }),  // ============================================================================  // KPI PERFORMANCE DASHBOARD  // ============================================================================  kpiPerformance: protectedProcedure    .input(z.object({ organizationId: z.string().cuid() }))    .query(async ({ ctx, input }) => {      const kpis = await ctx.prisma.kPI.findMany({        where: { organizationId: input.organizationId },        include: {          bscObjective: {            select: { perspective: true },          },          values: {            orderBy: { periodDate: 'desc' },            take: 3,          },        },      })      // Performance distribution      const performance = {        excellent: kpis.filter((k) => k.achievementRate >= 100).length,        good: kpis.filter((k) => k.achievementRate >= 90 && k.achievementRate < 100).length,        acceptable: kpis.filter((k) => k.achievementRate >= 70 && k.achievementRate < 90).length,        poor: kpis.filter((k) => k.achievementRate < 70).length,      }      // By perspective      const byPerspective = {        FINANCIAL: kpis.filter((k) => k.bscObjective?.perspective === 'FINANCIAL'),        CUSTOMER: kpis.filter((k) => k.bscObjective?.perspective === 'CUSTOMER'),        INTERNAL_PROCESS: kpis.filter((k) => k.bscObjective?.perspective === 'INTERNAL_PROCESS'),        LEARNING_GROWTH: kpis.filter((k) => k.bscObjective?.perspective === 'LEARNING_GROWTH'),      }      // Trending KPIs      const trending = kpis        .filter((k) => k.values.length >= 2)        .map((k) => {          const trend =            k.values[0].actualValue - k.values[k.values.length - 1].actualValue          return {            id: k.id,            name: k.kpiName,            trend,            trendDirection: trend > 0 ? 'UP' : trend < 0 ? 'DOWN' : 'STABLE',          }        })        .sort((a, b) => Math.abs(b.trend) - Math.abs(a.trend))        .slice(0, 10)      return {        total: kpis.length,        performance,        byPerspective: {          FINANCIAL: {            count: byPerspective.FINANCIAL.length,            avgAchievement:              byPerspective.FINANCIAL.reduce((sum, k) => sum + k.achievementRate, 0) /                byPerspective.FINANCIAL.length || 0,          },          CUSTOMER: {            count: byPerspective.CUSTOMER.length,            avgAchievement:              byPerspective.CUSTOMER.reduce((sum, k) => sum + k.achievementRate, 0) /                byPerspective.CUSTOMER.length || 0,          },          INTERNAL_PROCESS: {            count: byPerspective.INTERNAL_PROCESS.length,            avgAchievement:              byPerspective.INTERNAL_PROCESS.reduce((sum, k) => sum + k.achievementRate, 0) /                byPerspective.INTERNAL_PROCESS.length || 0,          },          LEARNING_GROWTH: {            count: byPerspective.LEARNING_GROWTH.length,            avgAchievement:              byPerspective.LEARNING_GROWTH.reduce((sum, k) => sum + k.achievementRate, 0) /                byPerspective.LEARNING_GROWTH.length || 0,          },        },        trending,      }    }),  // ============================================================================  // OKR DASHBOARD  // ============================================================================  okrDashboard: protectedProcedure    .input(z.object({ cycleId: z.string().cuid() }))    .query(async ({ ctx, input }) => {      const cycle = await ctx.prisma.oKRCycle.findUnique({        where: { id: input.cycleId },        include: {          okrs: {            include: {              keyResults: true,              checkIns: {                orderBy: { checkInDate: 'desc' },                take: 1,              },            },          },        },      })      if (!cycle) return null      const okrs = cycle.okrs      // Statistics      const stats = {        total: okrs.length,        byType: {          company: okrs.filter((o) => o.okrType === 'COMPANY').length,          department: okrs.filter((o) => o.okrType === 'DEPARTMENT').length,          team: okrs.filter((o) => o.okrType === 'TEAM').length,          individual: okrs.filter((o) => o.okrType === 'INDIVIDUAL').length,        },        byStatus: {          onTrack: okrs.filter((o) => o.status === 'ON_TRACK').length,          atRisk: okrs.filter((o) => o.status === 'AT_RISK').length,          behind: okrs.filter((o) => o.status === 'BEHIND').length,          completed: okrs.filter((o) => o.status === 'COMPLETED').length,        },        avgProgress:          okrs.reduce((sum, o) => sum + o.progressPercentage, 0) / okrs.length || 0,      }      // Check-in compliance      const expectedCheckIns = Math.floor(        (Date.now() - cycle.startDate.getTime()) /          (7 * 24 * 60 * 60 * 1000) // Weekly      )      const actualCheckIns = okrs.reduce(        (sum, o) => sum + o.checkIns.length,        0      )      const checkInCompliance =        expectedCheckIns > 0          ? (actualCheckIns / (expectedCheckIns * okrs.length)) * 100          : 100      return {        cycle: {          id: cycle.id,          name: cycle.cycleName,          startDate: cycle.startDate,          endDate: cycle.endDate,          status: cycle.status,        },        stats,        checkInCompliance,      }    }),  // ============================================================================  // LOGFRAME PERFORMANCE  // ============================================================================  logframePerformance: protectedProcedure    .input(z.object({ organizationId: z.string().cuid() }))    .query(async ({ ctx, input }) => {      const logframes = await ctx.prisma.logicalFramework.findMany({        where: { organizationId: input.organizationId },        include: {          elements: {            include: {              indicators: true,            },          },          reviews: {            orderBy: { reviewDate: 'desc' },            take: 1,          },        },      })      const summaries = logframes.map((lf) => {        const calculateLevelAchievement = (level: string) => {          const levelElements = lf.elements.filter((e) => e.level === level)          if (levelElements.length === 0) return 0          const indicators = levelElements.flatMap((e) => e.indicators)          if (indicators.length === 0) return 0          return (            indicators.reduce((sum, ind) => sum + (ind.achievementRate || 0), 0) /            indicators.length          )        }        return {          id: lf.id,          name: lf.logframeName,          programName: lf.programName,          status: lf.status,          goalAchievement: calculateLevelAchievement('GOAL'),          purposeAchievement: calculateLevelAchievement('PURPOSE'),          outputAchievement: calculateLevelAchievement('OUTPUT'),          latestReview: lf.reviews[0],        }      })      return summaries    }),  // ============================================================================  // STRATEGY EXECUTION OVERVIEW  // ============================================================================  strategyExecution: protectedProcedure    .input(z.object({ organizationId: z.string().cuid() }))    .query(async ({ ctx, input }) => {      const [strategies, objectives] = await Promise.all([        ctx.prisma.tOWSStrategy.findMany({          where: { organizationId: input.organizationId },          include: {            _count: {              select: {                linkedObjectives: true,                linkedProjects: true,              },            },          },        }),        ctx.prisma.bSCObjective.findMany({          where: { organizationId: input.organizationId },          include: {            kpis: true,          },        }),      ])      const strategyStats = {        total: strategies.length,        byType: {          SO: strategies.filter((s) => s.strategyType === 'SO').length,          WO: strategies.filter((s) => s.strategyType === 'WO').length,          ST: strategies.filter((s) => s.strategyType === 'ST').length,          WT: strategies.filter((s) => s.strategyType === 'WT').length,        },        byStatus: {          draft: strategies.filter((s) => s.status === 'DRAFT').length,          active: strategies.filter((s) => s.status === 'ACTIVE').length,          onHold: strategies.filter((s) => s.status === 'ON_HOLD').length,          completed: strategies.filter((s) => s.status === 'COMPLETED').length,        },        avgLinkedObjectives:          strategies.reduce((sum, s) => sum + s._count.linkedObjectives, 0) /          strategies.length || 0,        avgLinkedProjects:          strategies.reduce((sum, s) => sum + s._count.linkedProjects, 0) /          strategies.length || 0,      }      const objectiveStats = {        total: objectives.length,        byPerspective: {          FINANCIAL: objectives.filter((o) => o.perspective === 'FINANCIAL').length,          CUSTOMER: objectives.filter((o) => o.perspective === 'CUSTOMER').length,          INTERNAL_PROCESS: objectives.filter((o) => o.perspective === 'INTERNAL_PROCESS').length,          LEARNING_GROWTH: objectives.filter((o) => o.perspective === 'LEARNING_GROWTH').length,        },        avgAchievement:          objectives.reduce((sum, o) => sum + (o.achievementRate || 0), 0) /          objectives.length || 0,      }      return {        strategies: strategyStats,        objectives: objectiveStats,      }    }),})// Helper functionfunction getStartDate(timeRange: string): Date {  const now = new Date()  switch (timeRange) {    case '1M':      return new Date(now.setMonth(now.getMonth() - 1))    case '3M':      return new Date(now.setMonth(now.getMonth() - 3))    case '6M':      return new Date(now.setMonth(now.getMonth() - 6))    case '1Y':      return new Date(now.setFullYear(now.getFullYear() - 1))    default:      return new Date(0) // All time  }}// Import from project routerasync function calculateProjectHealth(ctx: any, projectId: string) {  // Implementation from project router  return null}```---ğŸ“‹ Step 4: Root Router (Combine All)```typescript// server/trpc/routers/_app.tsimport { router } from '../trpc'import { userRouter } from './user.router'import { projectRouter } from './project.router'import { kpiRouter } from './kpi.router'import { okrRouter } from './okr.router'import { logframeRouter } from './logframe.router'import { strategyRouter } from './strategy.router'import { dashboardRouter } from './dashboard.router'export const appRouter = router({  user: userRouter,  project: projectRouter,  kpi: kpiRouter,  okr: okrRouter,  logframe: logframeRouter,  strategy: strategyRouter,  dashboard: dashboardRouter,})export type AppRouter = typeof appRouter```---ğŸ“‹ Step 5: API Route Handler```typescript// pages/api/trpc/[trpc].tsimport { createNextApiHandler } from '@trpc/server/adapters/next'import { appRouter } from '@/server/trpc/routers/_app'import { createContext } from '@/server/trpc/context'export default createNextApiHandler({  router: appRouter,  createContext,  onError:    process.env.NODE_ENV === 'development'      ? ({ path, error }) => {          console.error(            `âŒ tRPC failed on ${path ?? '<no-path>'}: ${error.message}`          )        }      : undefined,})```---ğŸ“‹ Step 6: Client Setup```typescript// lib/trpc.tsimport { httpBatchLink } from '@trpc/client'import { createTRPCNext } from '@trpc/next'import type { AppRouter } from '@/server/trpc/routers/_app'import superjson from 'superjson'function getBaseUrl() {  if (typeof window !== 'undefined') return ''  if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`  return `http://localhost:${process.env.PORT ?? 3000}`}export const trpc = createTRPCNext<AppRouter>({  config() {    return {      transformer: superjson,      links: [        httpBatchLink({          url: `${getBaseUrl()}/api/trpc`,        }),      ],      queryClientConfig: {        defaultOptions: {          queries: {            staleTime: 60 * 1000, // 1 minute            refetchOnWindowFocus: false,          },        },      },    }  },  ssr: false,})```---ğŸ“‹ Step 7: App Wrapper```typescript// pages/_app.tsximport type { AppProps } from 'next/app'import { trpc } from '@/lib/trpc'import { SessionProvider } from 'next-auth/react'function MyApp({ Component, pageProps: { session, ...pageProps } }: AppProps) {  return (    <SessionProvider session={session}>      <Component {...pageProps} />    </SessionProvider>  )}export default trpc.withTRPC(MyApp)```---ğŸ“‹ Step 8: Usage Examples```typescript// Example: Use in React Componentimport { trpc } from '@/lib/trpc'export default function ProjectList() {  // Query  const { data, isLoading, error } = trpc.project.list.useQuery({    page: 1,    perPage: 20,    query: '',    filters: {},    sortBy: 'createdAt',    sortOrder: 'desc',  })  // Mutation  const createProject = trpc.project.create.useMutation({    onSuccess: () => {      // Invalidate and refetch      utils.project.list.invalidate()    },  })  const handleCreate = () => {    createProject.mutate({      organizationId: 'org-123',      projectCode: 'PRJ-2024-001',      projectName: 'New Project',      projectDescription: 'Description',      projectType: 'STRATEGIC',      startDate: new Date(),      endDate: new Date(),      projectManagerId: 'user-123',      priority: 'HIGH',    })  }  if (isLoading) return <div>Loading...</div>  if (error) return <div>Error: {error.message}</div>  return (    <div>      <button onClick={handleCreate}>Create Project</button>      {data?.data.map((project) => (        <div key={project.id}>{project.projectName}</div>      ))}    </div>  )}``````typescript// Example: Server-side data fetchingimport { createServerSideHelpers } from '@trpc/react-query/server'import { appRouter } from '@/server/trpc/routers/_app'import { createContext } from '@/server/trpc/context'import superjson from 'superjson'export async function getServerSideProps(context: GetServerSidePropsContext) {  const helpers = createServerSideHelpers({    router: appRouter,    ctx: await createContext(context),    transformer: superjson,  })  const projectId = context.params?.id as string  await helpers.project.getById.prefetch({ id: projectId })  return {    props: {      trpcState: helpers.dehydrate(),      projectId,    },  }}```---âœ… Complete tRPC API Summaryâœ… à¹€à¸£à¸²à¸ªà¸£à¹‰à¸²à¸‡à¸„à¸£à¸šà¹à¸¥à¹‰à¸§:Infrastructure (Context, Middleware, Schemas)User Router (CRUD + RBAC)Project Router (Projects, Tasks, Gantt, Risks)KPI Router (Cascading, Benchmarking, Alerts)OKR Router (Cascading, Check-ins, CFR)Logframe Router (Elements, Indicators, M&E, Reviews)Strategy Router (SWOT, TOWS, BSC, Strategy Map)Dashboard Router (Analytics, Portfolio, Performance)Root Router (Combined all routers)Client Setup (tRPC hooks, SSR support)---ğŸš€ Next Stepsà¹€à¸£à¸²à¸¡à¸µ Complete tRPC API à¹à¸¥à¹‰à¸§! à¸•à¹ˆà¸­à¹„à¸›à¸—à¸³à¸­à¸°à¹„à¸£à¸”à¸µ:âœ… Build React UI Componentsâœ… Create Dashboard Pagesâœ… Add Real-time Updates (WebSocket)âœ… Generate API Documentationâœ… Add Testing (Unit + Integration)âœ… Performance Optimization (Caching)à¸à¸£à¹‰à¸­à¸¡à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸ªà¹ˆà¸§à¸™à¹„à¸«à¸™à¸„à¸£à¸±à¸š? ğŸ¨ğŸš€---ğŸ¨ React UI Components - Complete Component Libraryà¸ªà¸£à¹‰à¸²à¸‡ Complete React Component Library à¸à¸£à¹‰à¸­à¸¡ TypeScript, Tailwind CSS, Shadcn/ui, à¹à¸¥à¸° Best Practices!---ğŸ“‹ Step 1: Setup UI Dependencies```bash# Install core dependenciespnpm add @radix-ui/react-dialog @radix-ui/react-dropdown-menu @radix-ui/react-selectpnpm add @radix-ui/react-tabs @radix-ui/react-toast @radix-ui/react-tooltippnpm add @radix-ui/react-popover @radix-ui/react-avatar @radix-ui/react-progresspnpm add @radix-ui/react-alert-dialog @radix-ui/react-checkbox @radix-ui/react-labelpnpm add @radix-ui/react-radio-group @radix-ui/react-switch @radix-ui/react-slider# Install UI utilitiespnpm add class-variance-authority clsx tailwind-mergepnpm add lucide-react react-hot-toast date-fnspnpm add recharts @tanstack/react-tablepnpm add react-hook-form @hookform/resolvers zod# Install iconspnpm add @heroicons/react# Install animationspnpm add framer-motion```---ğŸ“‹ Step 2: Utility Functions```typescript// lib/utils.tsimport { type ClassValue, clsx } from 'clsx'import { twMerge } from 'tailwind-merge'export function cn(...inputs: ClassValue[]) {  return twMerge(clsx(inputs))}export function formatDate(date: Date | string, format: string = 'PPP'): string {  const d = typeof date === 'string' ? new Date(date) : date  return new Intl.DateTimeFormat('th-TH', {    dateStyle: 'medium',  }).format(d)}export function formatCurrency(amount: number, currency: string = 'THB'): string {  return new Intl.NumberFormat('th-TH', {    style: 'currency',    currency,  }).format(amount)}export function formatPercent(value: number, decimals: number = 1): string {  return `${value.toFixed(decimals)}%`}export function getInitials(name: string): string {  return name    .split(' ')    .map((n) => n[0])    .join('')    .toUpperCase()    .slice(0, 2)}export function truncate(str: string, length: number): string {  return str.length > length ? str.substring(0, length) + '...' : str}```---ğŸ“‹ Step 3: Base ComponentsButton Component```typescript// components/ui/button.tsximport * as React from 'react'import { cva, type VariantProps } from 'class-variance-authority'import { cn } from '@/lib/utils'const buttonVariants = cva(  'inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background',  {    variants: {      variant: {        default: 'bg-primary text-primary-foreground hover:bg-primary/90',        destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',        outline: 'border border-input hover:bg-accent hover:text-accent-foreground',        secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',        ghost: 'hover:bg-accent hover:text-accent-foreground',        link: 'underline-offset-4 hover:underline text-primary',      },      size: {        default: 'h-10 py-2 px-4',        sm: 'h-9 px-3 rounded-md',        lg: 'h-11 px-8 rounded-md',        icon: 'h-10 w-10',      },    },    defaultVariants: {      variant: 'default',      size: 'default',    },  })export interface ButtonProps  extends React.ButtonHTMLAttributes<HTMLButtonElement>,    VariantProps<typeof buttonVariants> {  asChild?: boolean  isLoading?: boolean}const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(  ({ className, variant, size, isLoading, children, disabled, ...props }, ref) => {    return (      <button        className={cn(buttonVariants({ variant, size, className }))}        ref={ref}        disabled={disabled || isLoading}        {...props}      >        {isLoading ? (          <>            <svg              className="mr-2 h-4 w-4 animate-spin"              xmlns="http://www.w3.org/2000/svg"              fill="none"              viewBox="0 0 24 24"            >              <circle                className="opacity-25"                cx="12"                cy="12"                r="10"                stroke="currentColor"                strokeWidth="4"              />              <path                className="opacity-75"                fill="currentColor"                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"              />            </svg>            Loading...          </>        ) : (          children        )}      </button>    )  })Button.displayName = 'Button'export { Button, buttonVariants }```Card Component```typescript// components/ui/card.tsximport * as React from 'react'import { cn } from '@/lib/utils'const Card = React.forwardRef<  HTMLDivElement,  React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (  <div    ref={ref}    className={cn(      'rounded-lg border bg-card text-card-foreground shadow-sm',      className    )}    {...props}  />))Card.displayName = 'Card'const CardHeader = React.forwardRef<  HTMLDivElement,  React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (  <div    ref={ref}    className={cn('flex flex-col space-y-1.5 p-6', className)}    {...props}  />))CardHeader.displayName = 'CardHeader'const CardTitle = React.forwardRef<  HTMLParagraphElement,  React.HTMLAttributes<HTMLHeadingElement>>(({ className, ...props }, ref) => (  <h3    ref={ref}    className={cn(      'text-2xl font-semibold leading-none tracking-tight',      className    )}    {...props}  />))CardTitle.displayName = 'CardTitle'const CardDescription = React.forwardRef<  HTMLParagraphElement,  React.HTMLAttributes<HTMLParagraphElement>>(({ className, ...props }, ref) => (  <p    ref={ref}    className={cn('text-sm text-muted-foreground', className)}    {...props}  />))CardDescription.displayName = 'CardDescription'const CardContent = React.forwardRef<  HTMLDivElement,  React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (  <div ref={ref} className={cn('p-6 pt-0', className)} {...props} />))CardContent.displayName = 'CardContent'const CardFooter = React.forwardRef<  HTMLDivElement,  React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (  <div    ref={ref}    className={cn('flex items-center p-6 pt-0', className)}    {...props}  />))CardFooter.displayName = 'CardFooter'export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }```Badge Component```typescript// components/ui/badge.tsximport * as React from 'react'import { cva, type VariantProps } from 'class-variance-authority'import { cn } from '@/lib/utils'const badgeVariants = cva(  'inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',  {    variants: {      variant: {        default: 'border-transparent bg-primary text-primary-foreground hover:bg-primary/80',        secondary: 'border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80',        destructive: 'border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80',        outline: 'text-foreground',        success: 'border-transparent bg-green-500 text-white',        warning: 'border-transparent bg-yellow-500 text-white',        info: 'border-transparent bg-blue-500 text-white',      },    },    defaultVariants: {      variant: 'default',    },  })export interface BadgeProps  extends React.HTMLAttributes<HTMLDivElement>,    VariantProps<typeof badgeVariants> {}function Badge({ className, variant, ...props }: BadgeProps) {  return (    <div className={cn(badgeVariants({ variant }), className)} {...props} />  )}export { Badge, badgeVariants }```Input Component```typescript// components/ui/input.tsximport * as React from 'react'import { cn } from '@/lib/utils'export interface InputProps  extends React.InputHTMLAttributes<HTMLInputElement> {  error?: string}const Input = React.forwardRef<HTMLInputElement, InputProps>(  ({ className, type, error, ...props }, ref) => {    return (      <div className="w-full">        <input          type={type}          className={cn(            'flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',            error && 'border-red-500 focus-visible:ring-red-500',            className          )}          ref={ref}          {...props}        />        {error && <p className="mt-1 text-sm text-red-500">{error}</p>}      </div>    )  })Input.displayName = 'Input'export { Input }```Select Component```typescript// components/ui/select.tsximport * as React from 'react'import * as SelectPrimitive from '@radix-ui/react-select'import { Check, ChevronDown } from 'lucide-react'import { cn } from '@/lib/utils'const Select = SelectPrimitive.Rootconst SelectGroup = SelectPrimitive.Groupconst SelectValue = SelectPrimitive.Valueconst SelectTrigger = React.forwardRef<  React.ElementRef<typeof SelectPrimitive.Trigger>,  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>>(({ className, children, ...props }, ref) => (  <SelectPrimitive.Trigger    ref={ref}    className={cn(      'flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',      className    )}    {...props}  >    {children}    <SelectPrimitive.Icon asChild>      <ChevronDown className="h-4 w-4 opacity-50" />    </SelectPrimitive.Icon>  </SelectPrimitive.Trigger>))SelectTrigger.displayName = SelectPrimitive.Trigger.displayNameconst SelectContent = React.forwardRef<  React.ElementRef<typeof SelectPrimitive.Content>,  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>>(({ className, children, position = 'popper', ...props }, ref) => (  <SelectPrimitive.Portal>    <SelectPrimitive.Content      ref={ref}      className={cn(        'relative z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',        position === 'popper' &&          'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',        className      )}      position={position}      {...props}    >      <SelectPrimitive.Viewport        className={cn(          'p-1',          position === 'popper' &&            'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]'        )}      >        {children}      </SelectPrimitive.Viewport>    </SelectPrimitive.Content>  </SelectPrimitive.Portal>))SelectContent.displayName = SelectPrimitive.Content.displayNameconst SelectItem = React.forwardRef<  React.ElementRef<typeof SelectPrimitive.Item>,  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>>(({ className, children, ...props }, ref) => (  <SelectPrimitive.Item    ref={ref}    className={cn(      'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',      className    )}    {...props}  >    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">      <SelectPrimitive.ItemIndicator>        <Check className="h-4 w-4" />      </SelectPrimitive.ItemIndicator>    </span>    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>  </SelectPrimitive.Item>))SelectItem.displayName = SelectPrimitive.Item.displayNameexport {  Select,  SelectGroup,  SelectValue,  SelectTrigger,  SelectContent,  SelectItem,}```---ğŸ“‹ Step 4: Status ComponentsStatus Badge```typescript// components/ui/status-badge.tsximport { Badge } from './badge'import { cn } from '@/lib/utils'interface StatusBadgeProps {  status: string  type?: 'project' | 'task' | 'okr' | 'kpi' | 'risk'  className?: string}const statusConfig = {  project: {    PLANNING: { variant: 'info', label: 'à¸§à¸²à¸‡à¹à¸œà¸™' },    APPROVED: { variant: 'success', label: 'à¸­à¸™à¸¸à¸¡à¸±à¸•à¸´' },    IN_PROGRESS: { variant: 'default', label: 'à¸”à¸³à¹€à¸™à¸´à¸™à¸à¸²à¸£' },    ON_HOLD: { variant: 'warning', label: 'à¸à¸±à¸à¸Šà¸±à¹ˆà¸§à¸„à¸£à¸²à¸§' },    AT_RISK: { variant: 'destructive', label: 'à¸¡à¸µà¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¹ˆà¸¢à¸‡' },    COMPLETED: { variant: 'success', label: 'à¹€à¸ªà¸£à¹‡à¸ˆà¸ªà¸´à¹‰à¸™' },    CANCELLED: { variant: 'secondary', label: 'à¸¢à¸à¹€à¸¥à¸´à¸' },  },  task: {    NOT_STARTED: { variant: 'secondary', label: 'à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹€à¸£à¸´à¹ˆà¸¡' },    IN_PROGRESS: { variant: 'default', label: 'à¸à¸³à¸¥à¸±à¸‡à¸—à¸³' },    ON_HOLD: { variant: 'warning', label: 'à¸à¸±à¸' },    COMPLETED: { variant: 'success', label: 'à¹€à¸ªà¸£à¹‡à¸ˆ' },    CANCELLED: { variant: 'secondary', label: 'à¸¢à¸à¹€à¸¥à¸´à¸' },  },  okr: {    DRAFT: { variant: 'secondary', label: 'à¸£à¹ˆà¸²à¸‡' },    SUBMITTED: { variant: 'info', label: 'à¸ªà¹ˆà¸‡à¹à¸¥à¹‰à¸§' },    APPROVED: { variant: 'success', label: 'à¸­à¸™à¸¸à¸¡à¸±à¸•à¸´' },    ACTIVE: { variant: 'default', label: 'à¹ƒà¸Šà¹‰à¸‡à¸²à¸™' },    ON_TRACK: { variant: 'success', label: 'à¸•à¸²à¸¡à¹à¸œà¸™' },    AT_RISK: { variant: 'warning', label: 'à¹€à¸ªà¸µà¹ˆà¸¢à¸‡' },    BEHIND: { variant: 'destructive', label: 'à¸¥à¹ˆà¸²à¸Šà¹‰à¸²' },    COMPLETED: { variant: 'success', label: 'à¸ªà¸³à¹€à¸£à¹‡à¸ˆ' },  },  kpi: {    EXCELLENT: { variant: 'success', label: 'à¸¢à¸­à¸”à¹€à¸¢à¸µà¹ˆà¸¢à¸¡' },    GOOD: { variant: 'success', label: 'à¸”à¸µ' },    ACCEPTABLE: { variant: 'default', label: 'à¸à¸­à¹ƒà¸Šà¹‰' },    POOR: { variant: 'warning', label: 'à¸•à¹ˆà¸³' },    CRITICAL: { variant: 'destructive', label: 'à¸§à¸´à¸à¸¤à¸•' },  },  risk: {    LOW: { variant: 'success', label: 'à¸•à¹ˆà¸³' },    MEDIUM: { variant: 'warning', label: 'à¸›à¸²à¸™à¸à¸¥à¸²à¸‡' },    HIGH: { variant: 'destructive', label: 'à¸ªà¸¹à¸‡' },    CRITICAL: { variant: 'destructive', label: 'à¸§à¸´à¸à¸¤à¸•' },  },}export function StatusBadge({ status, type = 'project', className }: StatusBadgeProps) {  const config = statusConfig[type][status as keyof typeof statusConfig[typeof type]]  if (!config) {    return <Badge variant="secondary">{status}</Badge>  }  return (    <Badge variant={config.variant as any} className={className}>      {config.label}    </Badge>  )}```Progress Bar```typescript// components/ui/progress-bar.tsximport * as React from 'react'import * as ProgressPrimitive from '@radix-ui/react-progress'import { cn } from '@/lib/utils'interface ProgressBarProps extends React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root> {  value: number  showLabel?: boolean  size?: 'sm' | 'md' | 'lg'  colorScheme?: 'default' | 'success' | 'warning' | 'danger'}const colorSchemes = {  default: 'bg-primary',  success: 'bg-green-500',  warning: 'bg-yellow-500',  danger: 'bg-red-500',}const sizes = {  sm: 'h-2',  md: 'h-3',  lg: 'h-4',}export function ProgressBar({  value,  showLabel = false,  size = 'md',  colorScheme = 'default',  className,  ...props}: ProgressBarProps) {  // Determine color based on value if colorScheme is default  const getColorScheme = () => {    if (colorScheme !== 'default') return colorScheme    if (value >= 80) return 'success'    if (value >= 50) return 'warning'    return 'danger'  }  const scheme = getColorScheme()  return (    <div className="w-full">      <div className="flex items-center justify-between mb-1">        {showLabel && (          <span className="text-sm font-medium text-gray-700 dark:text-gray-300">            {value}%          </span>        )}      </div>      <ProgressPrimitive.Root        className={cn(          'relative overflow-hidden rounded-full bg-gray-200 dark:bg-gray-700',          sizes[size],          className        )}        {...props}      >        <ProgressPrimitive.Indicator          className={cn(            'h-full w-full flex-1 transition-all duration-500',            colorSchemes[scheme]          )}          style={{ transform: `translateX(-${100 - value}%)` }}        />      </ProgressPrimitive.Root>    </div>  )}```Avatar```typescript// components/ui/avatar.tsximport * as React from 'react'import * as AvatarPrimitive from '@radix-ui/react-avatar'import { cn, getInitials } from '@/lib/utils'interface AvatarProps extends React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root> {  src?: string  alt?: string  fallback?: string  size?: 'sm' | 'md' | 'lg' | 'xl'}const sizes = {  sm: 'h-8 w-8 text-xs',  md: 'h-10 w-10 text-sm',  lg: 'h-12 w-12 text-base',  xl: 'h-16 w-16 text-lg',}const Avatar = React.forwardRef<  React.ElementRef<typeof AvatarPrimitive.Root>,  AvatarProps>(({ src, alt, fallback, size = 'md', className, ...props }, ref) => {  return (    <AvatarPrimitive.Root      ref={ref}      className={cn(        'relative flex shrink-0 overflow-hidden rounded-full',        sizes[size],        className      )}      {...props}    >      <AvatarPrimitive.Image        src={src}        alt={alt}        className="aspect-square h-full w-full object-cover"      />      <AvatarPrimitive.Fallback        className="flex h-full w-full items-center justify-center rounded-full bg-primary text-primary-foreground font-medium"      >        {fallback ? getInitials(fallback) : alt?.slice(0, 2).toUpperCase()}      </AvatarPrimitive.Fallback>    </AvatarPrimitive.Root>  )})Avatar.displayName = 'Avatar'export { Avatar }```---ğŸ“‹ Step 5: Data Display ComponentsData Table```typescript// components/ui/data-table.tsximport * as React from 'react'import {  flexRender,  getCoreRowModel,  useReactTable,  getPaginationRowModel,  getSortedRowModel,  getFilteredRowModel,  type ColumnDef,  type SortingState,  type ColumnFiltersState,} from '@tanstack/react-table'import { Button } from './button'import { Input } from './input'import { ChevronLeft, ChevronRight, ChevronsLeft, ChevronsRight, ArrowUpDown } from 'lucide-react'interface DataTableProps<TData, TValue> {  columns: ColumnDef<TData, TValue>[]  data: TData[]  searchKey?: string  searchPlaceholder?: string}export function DataTable<TData, TValue>({  columns,  data,  searchKey,  searchPlaceholder = 'à¸„à¹‰à¸™à¸«à¸²...',}: DataTableProps<TData, TValue>) {  const [sorting, setSorting] = React.useState<SortingState>([])  const [columnFilters, setColumnFilters] = React.useState<ColumnFiltersState>([])  const table = useReactTable({    data,    columns,    getCoreRowModel: getCoreRowModel(),    getPaginationRowModel: getPaginationRowModel(),    getSortedRowModel: getSortedRowModel(),    getFilteredRowModel: getFilteredRowModel(),    onSortingChange: setSorting,    onColumnFiltersChange: setColumnFilters,    state: {      sorting,      columnFilters,    },  })  return (    <div className="space-y-4">      {searchKey && (        <div className="flex items-center">          <Input            placeholder={searchPlaceholder}            value={(table.getColumn(searchKey)?.getFilterValue() as string) ?? ''}            onChange={(event) =>              table.getColumn(searchKey)?.setFilterValue(event.target.value)            }            className="max-w-sm"          />        </div>      )}      <div className="rounded-md border">        <table className="w-full">          <thead className="bg-muted/50">            {table.getHeaderGroups().map((headerGroup) => (              <tr key={headerGroup.id}>                {headerGroup.headers.map((header) => (                  <th                    key={header.id}                    className="px-4 py-3 text-left text-sm font-medium"                  >                    {header.isPlaceholder                      ? null                      : flexRender(                          header.column.columnDef.header,                          header.getContext()                        )}                  </th>                ))}              </tr>            ))}          </thead>          <tbody>            {table.getRowModel().rows?.length ? (              table.getRowModel().rows.map((row) => (                <tr                  key={row.id}                  className="border-b transition-colors hover:bg-muted/50"                >                  {row.getVisibleCells().map((cell) => (                    <td key={cell.id} className="px-4 py-3 text-sm">                      {flexRender(cell.column.columnDef.cell, cell.getContext())}                    </td>                  ))}                </tr>              ))            ) : (              <tr>                <td colSpan={columns.length} className="h-24 text-center">                  à¹„à¸¡à¹ˆà¸à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥                </td>              </tr>            )}          </tbody>        </table>      </div>      {/* Pagination */}      <div className="flex items-center justify-between">        <div className="text-sm text-muted-foreground">          à¹à¸ªà¸”à¸‡ {table.getRowModel().rows.length} à¸ˆà¸²à¸ {data.length} à¸£à¸²à¸¢à¸à¸²à¸£        </div>        <div className="flex items-center space-x-2">          <Button            variant="outline"            size="icon"            onClick={() => table.setPageIndex(0)}            disabled={!table.getCanPreviousPage()}          >            <ChevronsLeft className="h-4 w-4" />          </Button>          <Button            variant="outline"            size="icon"            onClick={() => table.previousPage()}            disabled={!table.getCanPreviousPage()}          >            <ChevronLeft className="h-4 w-4" />          </Button>          <span className="text-sm">            à¸«à¸™à¹‰à¸² {table.getState().pagination.pageIndex + 1} à¸ˆà¸²à¸{' '}            {table.getPageCount()}          </span>          <Button            variant="outline"            size="icon"            onClick={() => table.nextPage()}            disabled={!table.getCanNextPage()}          >            <ChevronRight className="h-4 w-4" />          </Button>          <Button            variant="outline"            size="icon"            onClick={() => table.setPageIndex(table.getPageCount() - 1)}            disabled={!table.getCanNextPage()}          >            <ChevronsRight className="h-4 w-4" />          </Button>        </div>      </div>    </div>  )}// Sortable Column Headerexport function SortableHeader({ column, children }: any) {  return (    <Button      variant="ghost"      size="sm"      className="-ml-3 h-8"      onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}    >      {children}      <ArrowUpDown className="ml-2 h-4 w-4" />    </Button>  )}```Stat Card```typescript// components/ui/stat-card.tsximport { Card, CardContent, CardHeader, CardTitle } from './card'import { cn } from '@/lib/utils'import { LucideIcon } from 'lucide-react'interface StatCardProps {  title: string  value: string | number  description?: string  icon?: LucideIcon  trend?: {    value: number    isPositive: boolean  }  className?: string}export function StatCard({  title,  value,  description,  icon: Icon,  trend,  className,}: StatCardProps) {  return (    <Card className={className}>      <CardHeader className="flex flex-row items-center justify-between pb-2">        <CardTitle className="text-sm font-medium text-muted-foreground">          {title}        </CardTitle>        {Icon && <Icon className="h-4 w-4 text-muted-foreground" />}      </CardHeader>      <CardContent>        <div className="text-2xl font-bold">{value}</div>        {(description || trend) && (          <div className="flex items-center space-x-2 mt-1">            {trend && (              <span                className={cn(                  'text-xs font-medium',                  trend.isPositive ? 'text-green-600' : 'text-red-600'                )}              >                {trend.isPositive ? 'â†‘' : 'â†“'} {Math.abs(trend.value)}%              </span>            )}            {description && (              <p className="text-xs text-muted-foreground">{description}</p>            )}          </div>        )}      </CardContent>    </Card>  )}```---à¸•à¹ˆà¸­à¸”à¹‰à¸§à¸¢ Domain-Specific Components à¹ƒà¸™à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸–à¸±à¸”à¹„à¸›...à¸¡à¸µ:Project ComponentsOKR ComponentsKPI ComponentsDashboard Componentsà¸à¸£à¹‰à¸­à¸¡à¸•à¹ˆà¸­à¹„à¸«à¸¡à¸„à¸£à¸±à¸š? ğŸ¨ğŸš€---ğŸ¨ React UI - Domain-Specific Componentsà¸ªà¸£à¹‰à¸²à¸‡ Domain-Specific Components à¸ªà¸³à¸«à¸£à¸±à¸š Projects, OKRs, KPIs, à¹à¸¥à¸° Dashboards!---ğŸ“‹ Step 1: Project ComponentsProject Card```typescript// components/project/project-card.tsximport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import { Badge } from '@/components/ui/badge'import { Avatar } from '@/components/ui/avatar'import { ProgressBar } from '@/components/ui/progress-bar'import { StatusBadge } from '@/components/ui/status-badge'import { formatDate, formatCurrency } from '@/lib/utils'import { Calendar, DollarSign, Users, AlertTriangle } from 'lucide-react'import Link from 'next/link'interface ProjectCardProps {  project: {    id: string    projectCode: string    projectName: string    projectType: string    status: string    priority: string    startDate: Date    endDate: Date    budget?: number    completionPercentage: number    projectManager: {      fullName: string      avatar?: string    }    _count?: {      tasks: number      risks: number      issues: number    }  }}export function ProjectCard({ project }: ProjectCardProps) {  const isOverdue = new Date(project.endDate) < new Date() && project.status !== 'COMPLETED'  const daysLeft = Math.ceil(    (new Date(project.endDate).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24)  )  return (    <Link href={`/projects/${project.id}`}>      <Card className="hover:shadow-lg transition-shadow cursor-pointer">        <CardHeader className="pb-3">          <div className="flex items-start justify-between">            <div className="space-y-1 flex-1">              <div className="flex items-center gap-2">                <span className="text-xs text-muted-foreground font-mono">                  {project.projectCode}                </span>                <StatusBadge status={project.status} type="project" />                {project.priority === 'CRITICAL' && (                  <Badge variant="destructive" className="text-xs">                    <AlertTriangle className="h-3 w-3 mr-1" />                    à¹€à¸£à¹ˆà¸‡à¸”à¹ˆà¸§à¸™                  </Badge>                )}              </div>              <CardTitle className="text-lg line-clamp-2">                {project.projectName}              </CardTitle>            </div>          </div>        </CardHeader>        <CardContent className="space-y-4">          {/* Progress */}          <div className="space-y-2">            <div className="flex items-center justify-between text-sm">              <span className="text-muted-foreground">à¸„à¸§à¸²à¸¡à¸„à¸·à¸šà¸«à¸™à¹‰à¸²</span>              <span className="font-medium">{project.completionPercentage}%</span>            </div>            <ProgressBar value={project.completionPercentage} />          </div>          {/* Timeline */}          <div className="flex items-center justify-between text-sm">            <div className="flex items-center text-muted-foreground">              <Calendar className="h-4 w-4 mr-2" />              <span>{formatDate(project.startDate)}</span>            </div>            <div className={`flex items-center ${isOverdue ? 'text-red-600' : 'text-muted-foreground'}`}>              <span>                {isOverdue                  ? `à¹€à¸à¸´à¸™à¸à¸³à¸«à¸™à¸” ${Math.abs(daysLeft)} à¸§à¸±à¸™`                  : daysLeft > 0                  ? `à¹€à¸«à¸¥à¸·à¸­ ${daysLeft} à¸§à¸±à¸™`                  : 'à¸§à¸±à¸™à¸™à¸µà¹‰'}              </span>            </div>          </div>          {/* Budget */}          {project.budget && (            <div className="flex items-center text-sm text-muted-foreground">              <DollarSign className="h-4 w-4 mr-2" />              <span>à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“: {formatCurrency(project.budget)}</span>            </div>          )}          {/* Stats */}          <div className="flex items-center justify-between pt-3 border-t">            <div className="flex items-center gap-4">              <div className="flex items-center text-sm">                <Users className="h-4 w-4 mr-1 text-muted-foreground" />                <span>{project._count?.tasks || 0} à¸‡à¸²à¸™</span>              </div>              {project._count && project._count.risks > 0 && (                <div className="flex items-center text-sm text-orange-600">                  <AlertTriangle className="h-4 w-4 mr-1" />                  <span>{project._count.risks} à¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¹ˆà¸¢à¸‡</span>                </div>              )}            </div>            <Avatar              src={project.projectManager.avatar}              fallback={project.projectManager.fullName}              size="sm"            />          </div>        </CardContent>      </Card>    </Link>  )}```Gantt Chart Component```typescript// components/project/gantt-chart.tsximport { useMemo } from 'react'import { format, differenceInDays, addDays } from 'date-fns'import { th } from 'date-fns/locale'import { cn } from '@/lib/utils'import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import { Avatar } from '@/components/ui/avatar'interface GanttTask {  id: string  name: string  start: Date  end: Date  progress: number  assignee?: {    fullName: string    avatar?: string  }  dependencies?: string[]  type: 'TASK' | 'MILESTONE' | 'DELIVERABLE'}interface GanttChartProps {  tasks: GanttTask[]  projectStart: Date  projectEnd: Date}export function GanttChart({ tasks, projectStart, projectEnd }: GanttChartProps) {  const totalDays = differenceInDays(projectEnd, projectStart)  const today = new Date()  // Calculate position and width for each task  const taskBars = useMemo(() => {    return tasks.map((task) => {      const startOffset = differenceInDays(task.start, projectStart)      const duration = differenceInDays(task.end, task.start) + 1      const left = (startOffset / totalDays) * 100      const width = (duration / totalDays) * 100      return {        ...task,        left: Math.max(0, left),        width: Math.max(2, width),      }    })  }, [tasks, projectStart, totalDays])  // Generate month headers  const months = useMemo(() => {    const monthList: { name: string; days: number }[] = []    let currentDate = new Date(projectStart)    while (currentDate <= projectEnd) {      const monthStart = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1)      const monthEnd = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0)      const daysInRange = Math.min(        differenceInDays(monthEnd, currentDate) + 1,        differenceInDays(projectEnd, currentDate) + 1      )      monthList.push({        name: format(monthStart, 'MMM yyyy', { locale: th }),        days: daysInRange,      })      currentDate = addDays(monthEnd, 1)    }    return monthList  }, [projectStart, projectEnd])  // Today marker position  const todayPosition = useMemo(() => {    if (today < projectStart || today > projectEnd) return null    const offset = differenceInDays(today, projectStart)    return (offset / totalDays) * 100  }, [today, projectStart, projectEnd, totalDays])  return (    <Card>      <CardHeader>        <CardTitle>Gantt Chart</CardTitle>      </CardHeader>      <CardContent>        <div className="overflow-x-auto">          <div className="min-w-[800px]">            {/* Timeline header */}            <div className="flex border-b">              <div className="w-64 flex-shrink-0 px-4 py-2 font-medium">                à¸‡à¸²à¸™              </div>              <div className="flex-1 flex">                {months.map((month, i) => (                  <div                    key={i}                    style={{ width: `${(month.days / totalDays) * 100}%` }}                    className="border-l px-2 py-2 text-sm text-center font-medium"                  >                    {month.name}                  </div>                ))}              </div>            </div>            {/* Tasks */}            <div className="relative">              {taskBars.map((task, index) => (                <div                  key={task.id}                  className={cn(                    'flex border-b hover:bg-muted/50 transition-colors',                    index % 2 === 0 ? 'bg-background' : 'bg-muted/20'                  )}                >                  {/* Task name */}                  <div className="w-64 flex-shrink-0 px-4 py-3 flex items-center gap-2">                    <span className="text-sm truncate">{task.name}</span>                    {task.assignee && (                      <Avatar                        src={task.assignee.avatar}                        fallback={task.assignee.fullName}                        size="sm"                      />                    )}                  </div>                  {/* Timeline */}                  <div className="flex-1 relative py-3 px-2">                    <div                      className={cn(                        'absolute h-8 rounded-md flex items-center',                        task.type === 'MILESTONE'                          ? 'bg-amber-500'                          : task.progress >= 100                          ? 'bg-green-500'                          : 'bg-blue-500'                      )}                      style={{                        left: `${task.left}%`,                        width: `${task.width}%`,                      }}                    >                      {task.type !== 'MILESTONE' && (                        <>                          {/* Progress fill */}                          <div                            className="absolute inset-0 bg-blue-700 rounded-md"                            style={{ width: `${task.progress}%` }}                          />                          {/* Progress text */}                          <span className="relative z-10 text-xs text-white font-medium px-2 truncate">                            {task.progress}%                          </span>                        </>                      )}                      {task.type === 'MILESTONE' && (                        <div className="w-full text-center">                          <div className="w-4 h-4 bg-amber-500 rotate-45 mx-auto" />                        </div>                      )}                    </div>                  </div>                </div>              ))}              {/* Today marker */}              {todayPosition !== null && (                <div                  className="absolute top-0 bottom-0 w-0.5 bg-red-500 z-10"                  style={{ left: `calc(16rem + ${todayPosition}%)` }}                >                  <div className="absolute -top-1 -left-3 text-xs text-red-500 font-medium">                    à¸§à¸±à¸™à¸™à¸µà¹‰                  </div>                </div>              )}            </div>          </div>        </div>      </CardContent>    </Card>  )}```Risk Matrix```typescript// components/project/risk-matrix.tsximport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import { cn } from '@/lib/utils'interface Risk {  id: string  title: string  likelihood: number // 1-5  impact: number // 1-5}interface RiskMatrixProps {  risks: Risk[]}export function RiskMatrix({ risks }: RiskMatrixProps) {  // Group risks by cell  const matrix: { [key: string]: Risk[] } = {}  risks.forEach((risk) => {    const key = `${risk.likelihood}-${risk.impact}`    if (!matrix[key]) matrix[key] = []    matrix[key].push(risk)  })  const getCellColor = (likelihood: number, impact: number) => {    const score = likelihood * impact    if (score >= 20) return 'bg-red-500'    if (score >= 15) return 'bg-red-400'    if (score >= 10) return 'bg-orange-400'    if (score >= 6) return 'bg-yellow-400'    return 'bg-green-400'  }  return (    <Card>      <CardHeader>        <CardTitle>Risk Matrix</CardTitle>      </CardHeader>      <CardContent>        <div className="space-y-4">          {/* Matrix */}          <div className="grid grid-cols-6 gap-1">            {/* Header row */}            <div className="col-span-1" />            {[1, 2, 3, 4, 5].map((impact) => (              <div                key={impact}                className="text-center text-xs font-medium p-2"              >                Impact: {impact}              </div>            ))}            {/* Rows */}            {[5, 4, 3, 2, 1].map((likelihood) => (              <>                <div                  key={`label-${likelihood}`}                  className="text-right text-xs font-medium p-2 flex items-center justify-end"                >                  Likelihood: {likelihood}                </div>                {[1, 2, 3, 4, 5].map((impact) => {                  const key = `${likelihood}-${impact}`                  const cellRisks = matrix[key] || []                  const color = getCellColor(likelihood, impact)                  return (                    <div                      key={key}                      className={cn(                        'aspect-square p-2 rounded border',                        color,                        'flex items-center justify-center text-white font-bold text-sm',                        cellRisks.length > 0 && 'cursor-pointer hover:opacity-80'                      )}                      title={cellRisks.map((r) => r.title).join(', ')}                    >                      {cellRisks.length > 0 && cellRisks.length}                    </div>                  )                })}              </>            ))}          </div>          {/* Legend */}          <div className="flex items-center gap-4 text-sm">            <div className="flex items-center gap-2">              <div className="w-4 h-4 bg-red-500 rounded" />              <span>à¸ªà¸¹à¸‡à¸¡à¸²à¸ (20-25)</span>            </div>            <div className="flex items-center gap-2">              <div className="w-4 h-4 bg-orange-400 rounded" />              <span>à¸ªà¸¹à¸‡ (10-19)</span>            </div>            <div className="flex items-center gap-2">              <div className="w-4 h-4 bg-yellow-400 rounded" />              <span>à¸›à¸²à¸™à¸à¸¥à¸²à¸‡ (6-9)</span>            </div>            <div className="flex items-center gap-2">              <div className="w-4 h-4 bg-green-400 rounded" />              <span>à¸•à¹ˆà¸³ (1-5)</span>            </div>          </div>          {/* Risk list */}          {risks.length > 0 && (            <div className="space-y-2 pt-4 border-t">              <h4 className="font-medium">à¸£à¸²à¸¢à¸à¸²à¸£à¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¹ˆà¸¢à¸‡</h4>              {risks                .sort((a, b) => b.likelihood * b.impact - a.likelihood * a.impact)                .slice(0, 5)                .map((risk) => (                  <div                    key={risk.id}                    className="flex items-center justify-between p-2 rounded border"                  >                    <span className="text-sm">{risk.title}</span>                    <div className="flex items-center gap-2">                      <span className="text-xs text-muted-foreground">                        à¸„à¸°à¹à¸™à¸™: {risk.likelihood * risk.impact}                      </span>                      <div                        className={cn(                          'w-3 h-3 rounded-full',                          getCellColor(risk.likelihood, risk.impact)                        )}                      />                    </div>                  </div>                ))}            </div>          )}        </div>      </CardContent>    </Card>  )}```---ğŸ“‹ Step 2: OKR ComponentsOKR Card```typescript// components/okr/okr-card.tsximport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import { Badge } from '@/components/ui/badge'import { Avatar } from '@/components/ui/avatar'import { ProgressBar } from '@/components/ui/progress-bar'import { StatusBadge } from '@/components/ui/status-badge'import { Button } from '@/components/ui/button'import { Target, TrendingUp, AlertCircle, CheckCircle2 } from 'lucide-react'import Link from 'next/link'interface OKRCardProps {  okr: {    id: string    objectiveTitle: string    objectiveCode?: string    okrType: 'COMPANY' | 'DEPARTMENT' | 'TEAM' | 'INDIVIDUAL'    status: string    priority: string    progressPercentage: number    confidence: string    ownerUser: {      fullName: string      avatar?: string    }    keyResults: Array<{      id: string      keyResultTitle: string      currentValue?: number      targetValue?: number      progressPercentage: number      status: string    }>  }}const okrTypeConfig = {  COMPANY: { label: 'à¸­à¸‡à¸„à¹Œà¸à¸£', color: 'bg-purple-500' },  DEPARTMENT: { label: 'à¹à¸œà¸™à¸', color: 'bg-blue-500' },  TEAM: { label: 'à¸—à¸µà¸¡', color: 'bg-green-500' },  INDIVIDUAL: { label: 'à¸šà¸¸à¸„à¸„à¸¥', color: 'bg-orange-500' },}const confidenceConfig = {  VERY_LOW: { label: 'à¸•à¹ˆà¸³à¸¡à¸²à¸', color: 'text-red-600' },  LOW: { label: 'à¸•à¹ˆà¸³', color: 'text-orange-600' },  MEDIUM: { label: 'à¸›à¸²à¸™à¸à¸¥à¸²à¸‡', color: 'text-yellow-600' },  HIGH: { label: 'à¸ªà¸¹à¸‡', color: 'text-green-600' },  VERY_HIGH: { label: 'à¸ªà¸¹à¸‡à¸¡à¸²à¸', color: 'text-blue-600' },}export function OKRCard({ okr }: OKRCardProps) {  const typeConfig = okrTypeConfig[okr.okrType]  const confidence = confidenceConfig[okr.confidence as keyof typeof confidenceConfig]  return (    <Card className="hover:shadow-lg transition-shadow">      <CardHeader className="pb-3">        <div className="flex items-start justify-between gap-3">          <div className="flex-1 space-y-2">            <div className="flex items-center gap-2 flex-wrap">              {okr.objectiveCode && (                <span className="text-xs text-muted-foreground font-mono">                  {okr.objectiveCode}                </span>              )}              <Badge className={typeConfig.color}>{typeConfig.label}</Badge>              <StatusBadge status={okr.status} type="okr" />              {okr.priority === 'CRITICAL' && (                <Badge variant="destructive" className="text-xs">                  à¹€à¸£à¹ˆà¸‡à¸”à¹ˆà¸§à¸™                </Badge>              )}            </div>            <CardTitle className="text-lg line-clamp-2 flex items-start gap-2">              <Target className="h-5 w-5 mt-0.5 flex-shrink-0" />              {okr.objectiveTitle}            </CardTitle>          </div>          <Avatar            src={okr.ownerUser.avatar}            fallback={okr.ownerUser.fullName}            size="md"          />        </div>      </CardHeader>      <CardContent className="space-y-4">        {/* Overall Progress */}        <div className="space-y-2">          <div className="flex items-center justify-between text-sm">            <span className="text-muted-foreground">à¸„à¸§à¸²à¸¡à¸„à¸·à¸šà¸«à¸™à¹‰à¸²à¸£à¸§à¸¡</span>            <div className="flex items-center gap-2">              <span className={`font-medium ${confidence.color}`}>                {confidence.label}              </span>              <span className="font-bold">{okr.progressPercentage}%</span>            </div>          </div>          <ProgressBar value={okr.progressPercentage} />        </div>        {/* Key Results */}        <div className="space-y-2">          <h4 className="text-sm font-medium">Key Results ({okr.keyResults.length})</h4>          <div className="space-y-2">            {okr.keyResults.slice(0, 3).map((kr) => (              <div                key={kr.id}                className="flex items-center gap-2 p-2 rounded border bg-muted/20"              >                {kr.progressPercentage >= 100 ? (                  <CheckCircle2 className="h-4 w-4 text-green-600 flex-shrink-0" />                ) : kr.progressPercentage >= 70 ? (                  <TrendingUp className="h-4 w-4 text-blue-600 flex-shrink-0" />                ) : (                  <AlertCircle className="h-4 w-4 text-orange-600 flex-shrink-0" />                )}                <div className="flex-1 min-w-0">                  <p className="text-sm truncate">{kr.keyResultTitle}</p>                  <div className="flex items-center gap-2 mt-1">                    <div className="flex-1">                      <ProgressBar value={kr.progressPercentage} size="sm" />                    </div>                    <span className="text-xs text-muted-foreground whitespace-nowrap">                      {kr.currentValue !== undefined && kr.targetValue !== undefined                        ? `${kr.currentValue}/${kr.targetValue}`                        : `${kr.progressPercentage}%`}                    </span>                  </div>                </div>              </div>            ))}            {okr.keyResults.length > 3 && (              <p className="text-xs text-muted-foreground text-center">                à¹à¸¥à¸°à¸­à¸µà¸ {okr.keyResults.length - 3} Key Results              </p>            )}          </div>        </div>        {/* Actions */}        <div className="flex gap-2 pt-2 border-t">          <Link href={`/okrs/${okr.id}`} className="flex-1">            <Button variant="outline" size="sm" className="w-full">              à¸”à¸¹à¸£à¸²à¸¢à¸¥à¸°à¹€à¸­à¸µà¸¢à¸”            </Button>          </Link>          <Link href={`/okrs/${okr.id}/check-in`}>            <Button size="sm">Check-in</Button>          </Link>        </div>      </CardContent>    </Card>  )}```OKR Cascade Tree```typescript// components/okr/okr-cascade-tree.tsximport { useState } from 'react'import { Card, CardContent } from '@/components/ui/card'import { Avatar } from '@/components/ui/avatar'import { Badge } from '@/components/ui/badge'import { ProgressBar } from '@/components/ui/progress-bar'import { ChevronDown, ChevronRight, Target } from 'lucide-react'import { cn } from '@/lib/utils'interface OKRNode {  id: string  title: string  type: 'COMPANY' | 'DEPARTMENT' | 'TEAM' | 'INDIVIDUAL'  owner: {    fullName: string    avatar?: string  }  progress: number  status: string  confidence: string  keyResults: Array<{    id: string    title: string    current?: number    target?: number    progress: number  }>  children: OKRNode[]}interface OKRTreeNodeProps {  node: OKRNode  level: number}function OKRTreeNode({ node, level }: OKRTreeNodeProps) {  const [isExpanded, setIsExpanded] = useState(level < 2)  const hasChildren = node.children.length > 0  const typeColors = {    COMPANY: 'border-purple-500',    DEPARTMENT: 'border-blue-500',    TEAM: 'border-green-500',    INDIVIDUAL: 'border-orange-500',  }  return (    <div className="space-y-2">      <Card className={cn('border-l-4', typeColors[node.type])}>        <CardContent className="p-4">          <div className="flex items-start gap-3">            {/* Expand/Collapse */}            {hasChildren && (              <button                onClick={() => setIsExpanded(!isExpanded)}                className="mt-1 hover:bg-muted rounded p-1"              >                {isExpanded ? (                  <ChevronDown className="h-4 w-4" />                ) : (                  <ChevronRight className="h-4 w-4" />                )}              </button>            )}            {!hasChildren && <div className="w-6" />}            {/* Content */}            <div className="flex-1 space-y-3">              <div className="flex items-start justify-between gap-3">                <div className="flex-1">                  <div className="flex items-center gap-2 mb-1">                    <Target className="h-4 w-4" />                    <Badge variant="outline">{node.type}</Badge>                    {node.progress >= 100 && (                      <Badge variant="success">Completed</Badge>                    )}                  </div>                  <h4 className="font-medium">{node.title}</h4>                </div>                <Avatar                  src={node.owner.avatar}                  fallback={node.owner.fullName}                  size="sm"                />              </div>              {/* Progress */}              <div className="space-y-1">                <div className="flex items-center justify-between text-sm">                  <span className="text-muted-foreground">Progress</span>                  <span className="font-medium">{node.progress}%</span>                </div>                <ProgressBar value={node.progress} />              </div>              {/* Key Results Preview */}              {node.keyResults.length > 0 && (                <div className="space-y-1">                  <p className="text-xs text-muted-foreground">                    {node.keyResults.length} Key Results                  </p>                  {node.keyResults.slice(0, 2).map((kr) => (                    <div key={kr.id} className="flex items-center gap-2 text-xs">                      <div className="flex-1 truncate">{kr.title}</div>                      <span className="text-muted-foreground">                        {kr.progress}%                      </span>                    </div>                  ))}                </div>              )}              {/* Children count */}              {hasChildren && (                <p className="text-xs text-muted-foreground">                  {node.children.length} Cascaded OKRs                </p>              )}            </div>          </div>        </CardContent>      </Card>      {/* Children */}      {hasChildren && isExpanded && (        <div className={cn('ml-8 space-y-2 border-l-2 pl-4')}>          {node.children.map((child) => (            <OKRTreeNode key={child.id} node={child} level={level + 1} />          ))}        </div>      )}    </div>  )}interface OKRCascadeTreeProps {  tree: OKRNode[]}export function OKRCascadeTree({ tree }: OKRCascadeTreeProps) {  return (    <div className="space-y-4">      {tree.map((node) => (        <OKRTreeNode key={node.id} node={node} level={0} />      ))}    </div>  )}```Check-in Form```typescript// components/okr/check-in-form.tsximport { useState } from 'react'import { useForm } from 'react-hook-form'import { zodResolver } from '@hookform/resolvers/zod'import { z } from 'zod'import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import { Button } from '@/components/ui/button'import { Input } from '@/components/ui/input'import { Label } from '@/components/ui/label'import { Textarea } from '@/components/ui/textarea'import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group'import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'import { Slider } from '@/components/ui/slider'import { Smile, Meh, Frown } from 'lucide-react'const checkInSchema = z.object({  overallProgress: z.number().min(0).max(100),  healthStatus: z.enum(['HEALTHY', 'AT_RISK', 'CRITICAL']),  confidence: z.enum(['VERY_LOW', 'LOW', 'MEDIUM', 'HIGH', 'VERY_HIGH']),  accomplishments: z.string().optional(),  challenges: z.string().optional(),  nextSteps: z.string().optional(),  helpNeeded: z.string().optional(),  mood: z.enum(['GREAT', 'GOOD', 'OKAY', 'CONCERNED', 'STRESSED']).optional(),})type CheckInFormData = z.infer<typeof checkInSchema>interface CheckInFormProps {  okrId: string  currentProgress: number  onSubmit: (data: CheckInFormData) => Promise<void>}export function CheckInForm({ okrId, currentProgress, onSubmit }: CheckInFormProps) {  const [isSubmitting, setIsSubmitting] = useState(false)  const [progress, setProgress] = useState(currentProgress)  const {    register,    handleSubmit,    setValue,    watch,    formState: { errors },  } = useForm<CheckInFormData>({    resolver: zodResolver(checkInSchema),    defaultValues: {      overallProgress: currentProgress,      healthStatus: 'HEALTHY',      confidence: 'MEDIUM',      mood: 'GOOD',    },  })  const handleFormSubmit = async (data: CheckInFormData) => {    setIsSubmitting(true)    try {      await onSubmit(data)    } finally {      setIsSubmitting(false)    }  }  const selectedMood = watch('mood')  const moodIcons = {    GREAT: { icon: Smile, color: 'text-green-600', label: 'à¸”à¸µà¸¡à¸²à¸' },    GOOD: { icon: Smile, color: 'text-blue-600', label: 'à¸”à¸µ' },    OKAY: { icon: Meh, color: 'text-yellow-600', label: 'à¸›à¸à¸•à¸´' },    CONCERNED: { icon: Frown, color: 'text-orange-600', label: 'à¸à¸±à¸‡à¸§à¸¥' },    STRESSED: { icon: Frown, color: 'text-red-600', label: 'à¹€à¸„à¸£à¸µà¸¢à¸”' },  }  return (    <form onSubmit={handleSubmit(handleFormSubmit)} className="space-y-6">      <Card>        <CardHeader>          <CardTitle>Weekly Check-in</CardTitle>        </CardHeader>        <CardContent className="space-y-6">          {/* Progress */}          <div className="space-y-3">            <Label>à¸„à¸§à¸²à¸¡à¸„à¸·à¸šà¸«à¸™à¹‰à¸²à¸£à¸§à¸¡: {progress}%</Label>            <Slider              value={[progress]}              onValueChange={(value) => {                setProgress(value[0])                setValue('overallProgress', value[0])              }}              max={100}              step={1}              className="w-full"            />          </div>          {/* Health Status */}          <div className="space-y-3">            <Label>à¸ªà¸–à¸²à¸™à¸°</Label>            <RadioGroup              defaultValue="HEALTHY"              onValueChange={(value) => setValue('healthStatus', value as any)}            >              <div className="flex items-center space-x-2">                <RadioGroupItem value="HEALTHY" id="healthy" />                <Label htmlFor="healthy" className="font-normal cursor-pointer">                  ğŸŸ¢ à¸”à¸³à¹€à¸™à¸´à¸™à¹„à¸›à¹„à¸”à¹‰à¸”à¸µ                </Label>              </div>              <div className="flex items-center space-x-2">                <RadioGroupItem value="AT_RISK" id="at-risk" />                <Label htmlFor="at-risk" className="font-normal cursor-pointer">                  ğŸŸ¡ à¸¡à¸µà¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¹ˆà¸¢à¸‡                </Label>              </div>              <div className="flex items-center space-x-2">                <RadioGroupItem value="CRITICAL" id="critical" />                <Label htmlFor="critical" className="font-normal cursor-pointer">                  ğŸ”´ à¸§à¸´à¸à¸¤à¸•                </Label>              </div>            </RadioGroup>          </div>          {/* Confidence */}          <div className="space-y-3">            <Label htmlFor="confidence">à¸„à¸§à¸²à¸¡à¸¡à¸±à¹ˆà¸™à¹ƒà¸ˆà¹ƒà¸™à¸à¸²à¸£à¸šà¸£à¸£à¸¥à¸¸à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢</Label>            <Select              defaultValue="MEDIUM"              onValueChange={(value) => setValue('confidence', value as any)}            >              <SelectTrigger id="confidence">                <SelectValue />              </SelectTrigger>              <SelectContent>                <SelectItem value="VERY_HIGH">à¸ªà¸¹à¸‡à¸¡à¸²à¸</SelectItem>                <SelectItem value="HIGH">à¸ªà¸¹à¸‡</SelectItem>                <SelectItem value="MEDIUM">à¸›à¸²à¸™à¸à¸¥à¸²à¸‡</SelectItem>                <SelectItem value="LOW">à¸•à¹ˆà¸³</SelectItem>                <SelectItem value="VERY_LOW">à¸•à¹ˆà¸³à¸¡à¸²à¸</SelectItem>              </SelectContent>            </Select>          </div>          {/* Mood */}          <div className="space-y-3">            <Label>à¸­à¸²à¸£à¸¡à¸“à¹Œ/à¸ªà¸ à¸²à¸à¸ˆà¸´à¸•à¹ƒà¸ˆ</Label>            <div className="flex gap-2">              {Object.entries(moodIcons).map(([mood, config]) => {                const Icon = config.icon                return (                  <button                    key={mood}                    type="button"                    onClick={() => setValue('mood', mood as any)}                    className={`flex-1 p-3 rounded-lg border-2 transition-all ${                      selectedMood === mood                        ? 'border-primary bg-primary/10'                        : 'border-border hover:border-primary/50'                    }`}                  >                    <Icon className={`h-6 w-6 mx-auto ${config.color}`} />                    <p className="text-xs mt-1">{config.label}</p>                  </button>                )              })}            </div>          </div>          {/* Accomplishments */}          <div className="space-y-2">            <Label htmlFor="accomplishments">              à¸ªà¸´à¹ˆà¸‡à¸—à¸µà¹ˆà¸—à¸³à¸ªà¸³à¹€à¸£à¹‡à¸ˆà¹ƒà¸™à¸ªà¸±à¸›à¸”à¸²à¸«à¹Œà¸™à¸µà¹‰            </Label>            <Textarea              id="accomplishments"              {...register('accomplishments')}              placeholder="- à¸—à¸³ A à¸ªà¸³à¹€à¸£à¹‡à¸ˆ&#10;- à¸›à¸´à¸” B à¹„à¸”à¹‰à¹à¸¥à¹‰à¸§&#10;- à¹€à¸£à¸´à¹ˆà¸¡à¸—à¸³ C"              rows={4}            />          </div>          {/* Challenges */}          <div className="space-y-2">            <Label htmlFor="challenges">à¸­à¸¸à¸›à¸ªà¸£à¸£à¸„/à¸›à¸±à¸à¸«à¸²à¸—à¸µà¹ˆà¸à¸š</Label>            <Textarea              id="challenges"              {...register('challenges')}              placeholder="à¸šà¸­à¸à¸­à¸¸à¸›à¸ªà¸£à¸£à¸„à¸—à¸µà¹ˆà¹€à¸ˆà¸­..."              rows={3}            />          </div>          {/* Next Steps */}          <div className="space-y-2">            <Label htmlFor="nextSteps">à¹à¸œà¸™à¸ªà¸±à¸›à¸”à¸²à¸«à¹Œà¸«à¸™à¹‰à¸²</Label>            <Textarea              id="nextSteps"              {...register('nextSteps')}              placeholder="à¸ˆà¸°à¸—à¸³à¸­à¸°à¹„à¸£à¸•à¹ˆà¸­à¹ƒà¸™à¸ªà¸±à¸›à¸”à¸²à¸«à¹Œà¸«à¸™à¹‰à¸²..."              rows={3}            />          </div>          {/* Help Needed */}          <div className="space-y-2">            <Label htmlFor="helpNeeded">              à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸„à¸§à¸²à¸¡à¸Šà¹ˆà¸§à¸¢à¹€à¸«à¸¥à¸·à¸­à¸­à¸°à¹„à¸£?            </Label>            <Textarea              id="helpNeeded"              {...register('helpNeeded')}              placeholder="à¸šà¸­à¸à¸§à¹ˆà¸²à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸„à¸§à¸²à¸¡à¸Šà¹ˆà¸§à¸¢à¹€à¸«à¸¥à¸·à¸­à¹ƒà¸™à¹€à¸£à¸·à¹ˆà¸­à¸‡à¸­à¸°à¹„à¸£..."              rows={2}            />          </div>        </CardContent>      </Card>      <div className="flex gap-3">        <Button type="button" variant="outline" className="flex-1">          à¸¢à¸à¹€à¸¥à¸´à¸        </Button>        <Button type="submit" isLoading={isSubmitting} className="flex-1">          Submit Check-in        </Button>      </div>    </form>  )}```---à¸•à¹ˆà¸­à¸”à¹‰à¸§à¸¢ KPI Components à¹à¸¥à¸° Dashboard Components à¹ƒà¸™à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸–à¸±à¸”à¹„à¸›...à¸à¸£à¹‰à¸­à¸¡à¸•à¹ˆà¸­à¹„à¸«à¸¡à¸„à¸£à¸±à¸š? ğŸ“ŠğŸ¨---ğŸ¨ React UI - KPI & Dashboard Componentsà¸ªà¸£à¹‰à¸²à¸‡ KPI Components à¹à¸¥à¸° Dashboard Components à¸—à¸µà¹ˆà¸ªà¸§à¸¢à¸‡à¸²à¸¡à¹à¸¥à¸°à¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¸‡à¹ˆà¸²à¸¢!---ğŸ“‹ Step 1: KPI ComponentsKPI Card```typescript// components/kpi/kpi-card.tsximport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import { Badge } from '@/components/ui/badge'import { Avatar } from '@/components/ui/avatar'import { ProgressBar } from '@/components/ui/progress-bar'import { formatPercent } from '@/lib/utils'import { TrendingUp, TrendingDown, Minus, Target, AlertTriangle } from 'lucide-react'import { LineChart, Line, ResponsiveContainer } from 'recharts'import Link from 'next/link'interface KPICardProps {  kpi: {    id: string    kpiCode?: string    kpiName: string    currentValue: number    targetValue: number    measurementUnit: string    achievementRate: number    polarity: 'POSITIVE' | 'NEGATIVE'    owner?: {      fullName: string      avatar?: string    }    bscObjective?: {      perspective: string    }    values?: Array<{      actualValue: number      periodDate: Date    }>  }}export function KPICard({ kpi }: KPICardProps) {  // Calculate trend  const getTrend = () => {    if (!kpi.values || kpi.values.length < 2) return null        const sorted = [...kpi.values].sort(      (a, b) => new Date(a.periodDate).getTime() - new Date(b.periodDate).getTime()    )    const latest = sorted[sorted.length - 1].actualValue    const previous = sorted[sorted.length - 2].actualValue    const change = ((latest - previous) / previous) * 100    return {      value: Math.abs(change),      isPositive: change > 0,      isGood: kpi.polarity === 'POSITIVE' ? change > 0 : change < 0,    }  }  const trend = getTrend()  // Performance status  const getStatus = () => {    if (kpi.achievementRate >= 100) return { label: 'à¸¢à¸­à¸”à¹€à¸¢à¸µà¹ˆà¸¢à¸¡', color: 'success' }    if (kpi.achievementRate >= 90) return { label: 'à¸”à¸µ', color: 'success' }    if (kpi.achievementRate >= 70) return { label: 'à¸à¸­à¹ƒà¸Šà¹‰', color: 'warning' }    if (kpi.achievementRate >= 50) return { label: 'à¸•à¹ˆà¸³', color: 'warning' }    return { label: 'à¸§à¸´à¸à¸¤à¸•', color: 'destructive' }  }  const status = getStatus()  // Prepare sparkline data  const sparklineData = kpi.values    ?.slice(-7)    .map((v) => ({ value: v.actualValue })) || []  return (    <Link href={`/kpis/${kpi.id}`}>      <Card className="hover:shadow-lg transition-shadow cursor-pointer">        <CardHeader className="pb-3">          <div className="flex items-start justify-between">            <div className="space-y-1 flex-1">              <div className="flex items-center gap-2">                {kpi.kpiCode && (                  <span className="text-xs text-muted-foreground font-mono">                    {kpi.kpiCode}                  </span>                )}                {kpi.bscObjective && (                  <Badge variant="outline" className="text-xs">                    {kpi.bscObjective.perspective}                  </Badge>                )}                <Badge variant={status.color as any}>{status.label}</Badge>              </div>              <CardTitle className="text-base line-clamp-2">                {kpi.kpiName}              </CardTitle>            </div>            {kpi.owner && (              <Avatar                src={kpi.owner.avatar}                fallback={kpi.owner.fullName}                size="sm"              />            )}          </div>        </CardHeader>        <CardContent className="space-y-4">          {/* Current vs Target */}          <div className="flex items-end justify-between">            <div>              <p className="text-3xl font-bold">                {kpi.currentValue.toLocaleString()}              </p>              <p className="text-sm text-muted-foreground">                à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢: {kpi.targetValue.toLocaleString()} {kpi.measurementUnit}              </p>            </div>            {trend && (              <div                className={`flex items-center gap-1 ${                  trend.isGood ? 'text-green-600' : 'text-red-600'                }`}              >                {trend.isPositive ? (                  <TrendingUp className="h-4 w-4" />                ) : (                  <TrendingDown className="h-4 w-4" />                )}                <span className="text-sm font-medium">                  {formatPercent(trend.value)}                </span>              </div>            )}          </div>          {/* Achievement Rate */}          <div className="space-y-2">            <div className="flex items-center justify-between text-sm">              <span className="text-muted-foreground">Achievement Rate</span>              <span className="font-bold">{formatPercent(kpi.achievementRate)}</span>            </div>            <ProgressBar value={kpi.achievementRate} />          </div>          {/* Sparkline */}          {sparklineData.length > 0 && (            <div className="h-12 -mx-2">              <ResponsiveContainer width="100%" height="100%">                <LineChart data={sparklineData}>                  <Line                    type="monotone"                    dataKey="value"                    stroke={trend?.isGood ? '#22c55e' : '#ef4444'}                    strokeWidth={2}                    dot={false}                  />                </LineChart>              </ResponsiveContainer>            </div>          )}        </CardContent>      </Card>    </Link>  )}```KPI Cascade Tree```typescript// components/kpi/kpi-cascade-tree.tsximport { useState } from 'react'import { Card, CardContent } from '@/components/ui/card'import { Avatar } from '@/components/ui/avatar'import { Badge } from '@/components/ui/badge'import { ProgressBar } from '@/components/ui/progress-bar'import { Button } from '@/components/ui/button'import { ChevronDown, ChevronRight, Target, TrendingUp, TrendingDown } from 'lucide-react'import { cn } from '@/lib/utils'interface KPINode {  id: string  name: string  code: string  owner: {    fullName: string    avatar?: string  }  current: number  target: number  achievement: number  unit: string  contribution?: number  trend?: 'UP' | 'DOWN' | 'STABLE'  children: KPINode[]}interface KPITreeNodeProps {  node: KPINode  level: number}function KPITreeNode({ node, level }: KPITreeNodeProps) {  const [isExpanded, setIsExpanded] = useState(level < 2)  const hasChildren = node.children.length > 0  const getAchievementColor = (achievement: number) => {    if (achievement >= 100) return 'text-green-600'    if (achievement >= 90) return 'text-blue-600'    if (achievement >= 70) return 'text-yellow-600'    return 'text-red-600'  }  return (    <div className="space-y-2">      <Card        className={cn(          'border-l-4',          node.achievement >= 100            ? 'border-green-500'            : node.achievement >= 70            ? 'border-yellow-500'            : 'border-red-500'        )}      >        <CardContent className="p-4">          <div className="flex items-start gap-3">            {/* Expand/Collapse */}            {hasChildren && (              <button                onClick={() => setIsExpanded(!isExpanded)}                className="mt-1 hover:bg-muted rounded p-1"              >                {isExpanded ? (                  <ChevronDown className="h-4 w-4" />                ) : (                  <ChevronRight className="h-4 w-4" />                )}              </button>            )}            {!hasChildren && <div className="w-6" />}            {/* Content */}            <div className="flex-1 space-y-3">              <div className="flex items-start justify-between gap-3">                <div className="flex-1">                  <div className="flex items-center gap-2 mb-1">                    <Target className="h-4 w-4" />                    <span className="text-xs text-muted-foreground font-mono">                      {node.code}                    </span>                    {node.contribution && (                      <Badge variant="outline" className="text-xs">                        Weight: {node.contribution}%                      </Badge>                    )}                    {node.trend && (                      <span className="text-xs">                        {node.trend === 'UP' ? (                          <TrendingUp className="h-3 w-3 text-green-600 inline" />                        ) : node.trend === 'DOWN' ? (                          <TrendingDown className="h-3 w-3 text-red-600 inline" />                        ) : (                          'â†’'                        )}                      </span>                    )}                  </div>                  <h4 className="font-medium">{node.name}</h4>                </div>                <Avatar                  src={node.owner.avatar}                  fallback={node.owner.fullName}                  size="sm"                />              </div>              {/* Values */}              <div className="flex items-center justify-between">                <div className="text-sm">                  <span className="text-2xl font-bold">                    {node.current.toLocaleString()}                  </span>                  <span className="text-muted-foreground ml-2">                    / {node.target.toLocaleString()} {node.unit}                  </span>                </div>                <span                  className={cn(                    'text-2xl font-bold',                    getAchievementColor(node.achievement)                  )}                >                  {node.achievement.toFixed(1)}%                </span>              </div>              {/* Progress */}              <ProgressBar value={node.achievement} />              {/* Children count */}              {hasChildren && (                <p className="text-xs text-muted-foreground">                  {node.children.length} Cascaded KPIs                </p>              )}            </div>          </div>        </CardContent>      </Card>      {/* Children */}      {hasChildren && isExpanded && (        <div className="ml-8 space-y-2 border-l-2 pl-4">          {node.children.map((child) => (            <KPITreeNode key={child.id} node={child} level={level + 1} />          ))}        </div>      )}    </div>  )}interface KPICascadeTreeProps {  tree: KPINode[]}export function KPICascadeTree({ tree }: KPICascadeTreeProps) {  return (    <div className="space-y-4">      {tree.map((node) => (        <KPITreeNode key={node.id} node={node} level={0} />      ))}    </div>  )}```KPI Trend Chart```typescript// components/kpi/kpi-trend-chart.tsximport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import {  LineChart,  Line,  AreaChart,  Area,  XAxis,  YAxis,  CartesianGrid,  Tooltip,  Legend,  ResponsiveContainer,  ReferenceLine,} from 'recharts'import { format } from 'date-fns'import { th } from 'date-fns/locale'interface KPITrendChartProps {  data: Array<{    periodDate: Date    actualValue: number    targetValue: number    baseline?: number  }>  kpiName: string  unit: string  showBaseline?: boolean  showForecast?: boolean  forecastData?: Array<{    period: number    value: number    confidence: number  }>}export function KPITrendChart({  data,  kpiName,  unit,  showBaseline = false,  showForecast = false,  forecastData,}: KPITrendChartProps) {  // Prepare chart data  const chartData = data.map((d) => ({    date: format(new Date(d.periodDate), 'MMM yy', { locale: th }),    actual: d.actualValue,    target: d.targetValue,    baseline: d.baseline,  }))  // Add forecast data  if (showForecast && forecastData) {    forecastData.forEach((f, i) => {      chartData.push({        date: `+${f.period}M`,        actual: null as any,        target: null as any,        baseline: null as any,        forecast: f.value,        confidence: f.confidence * 100,      })    })  }  return (    <Card>      <CardHeader>        <CardTitle className="text-lg">{kpiName} - Trend Analysis</CardTitle>      </CardHeader>      <CardContent>        <ResponsiveContainer width="100%" height={350}>          <LineChart data={chartData}>            <CartesianGrid strokeDasharray="3 3" />            <XAxis              dataKey="date"              style={{ fontSize: '12px' }}            />            <YAxis              style={{ fontSize: '12px' }}              label={{ value: unit, angle: -90, position: 'insideLeft' }}            />            <Tooltip              contentStyle={{                backgroundColor: 'rgba(255, 255, 255, 0.95)',                border: '1px solid #ccc',                borderRadius: '4px',              }}            />            <Legend />            {/* Baseline */}            {showBaseline && (              <ReferenceLine                y={chartData[0]?.baseline}                stroke="#9ca3af"                strokeDasharray="5 5"                label="Baseline"              />            )}            {/* Target line */}            <Line              type="monotone"              dataKey="target"              stroke="#94a3b8"              strokeWidth={2}              strokeDasharray="5 5"              name="à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢"              dot={false}            />            {/* Actual line */}            <Line              type="monotone"              dataKey="actual"              stroke="#3b82f6"              strokeWidth={3}              name="à¸œà¸¥à¸ˆà¸£à¸´à¸‡"              dot={{ fill: '#3b82f6', r: 4 }}              activeDot={{ r: 6 }}            />            {/* Forecast line */}            {showForecast && (              <Line                type="monotone"                dataKey="forecast"                stroke="#f59e0b"                strokeWidth={2}                strokeDasharray="3 3"                name="à¸„à¸²à¸”à¸à¸²à¸£à¸“à¹Œ"                dot={{ fill: '#f59e0b', r: 3 }}              />            )}          </LineChart>        </ResponsiveContainer>      </CardContent>    </Card>  )}```KPI Benchmark Comparison```typescript// components/kpi/kpi-benchmark.tsximport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import { Badge } from '@/components/ui/badge'import {  BarChart,  Bar,  XAxis,  YAxis,  CartesianGrid,  Tooltip,  Legend,  ResponsiveContainer,  Cell,} from 'recharts'interface Benchmark {  source: string  type: 'INDUSTRY' | 'COMPETITOR' | 'BEST_IN_CLASS' | 'INTERNAL'  value: number  current: number  gap: number  gapPercentage: number  status: 'ABOVE' | 'NEAR' | 'BELOW'}interface KPIBenchmarkProps {  kpi: {    name: string    current: number    target: number    unit: string  }  benchmarks: Benchmark[]}export function KPIBenchmark({ kpi, benchmarks }: KPIBenchmarkProps) {  const chartData = [    {      name: 'à¸œà¸¥à¸‡à¸²à¸™à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™',      value: kpi.current,      fill: '#3b82f6',    },    {      name: 'à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢',      value: kpi.target,      fill: '#10b981',    },    ...benchmarks.map((b) => ({      name: b.source,      value: b.value,      fill: b.status === 'ABOVE' ? '#22c55e' : b.status === 'NEAR' ? '#f59e0b' : '#ef4444',    })),  ]  return (    <Card>      <CardHeader>        <CardTitle>Benchmark Comparison - {kpi.name}</CardTitle>      </CardHeader>      <CardContent className="space-y-6">        {/* Chart */}        <ResponsiveContainer width="100%" height={300}>          <BarChart data={chartData} layout="vertical">            <CartesianGrid strokeDasharray="3 3" />            <XAxis type="number" />            <YAxis dataKey="name" type="category" width={150} />            <Tooltip />            <Bar dataKey="value" radius={[0, 8, 8, 0]}>              {chartData.map((entry, index) => (                <Cell key={`cell-${index}`} fill={entry.fill} />              ))}            </Bar>          </BarChart>        </ResponsiveContainer>        {/* Detailed comparison */}        <div className="space-y-3">          <h4 className="font-medium">Gap Analysis</h4>          {benchmarks.map((benchmark, index) => (            <div              key={index}              className="flex items-center justify-between p-3 rounded-lg border"            >              <div className="flex-1">                <div className="flex items-center gap-2 mb-1">                  <span className="font-medium">{benchmark.source}</span>                  <Badge variant="outline" className="text-xs">                    {benchmark.type}                  </Badge>                  <Badge                    variant={                      benchmark.status === 'ABOVE'                        ? 'success'                        : benchmark.status === 'NEAR'                        ? 'warning'                        : 'destructive'                    }                  >                    {benchmark.status === 'ABOVE'                      ? 'à¸ªà¸¹à¸‡à¸à¸§à¹ˆà¸²'                      : benchmark.status === 'NEAR'                      ? 'à¹ƒà¸à¸¥à¹‰à¹€à¸„à¸µà¸¢à¸‡'                      : 'à¸•à¹ˆà¸³à¸à¸§à¹ˆà¸²'}                  </Badge>                </div>                <p className="text-sm text-muted-foreground">                  Benchmark: {benchmark.value.toLocaleString()} {kpi.unit}                </p>              </div>              <div className="text-right">                <p                  className={`text-lg font-bold ${                    benchmark.gap >= 0 ? 'text-green-600' : 'text-red-600'                  }`}                >                  {benchmark.gap >= 0 ? '+' : ''}                  {benchmark.gap.toLocaleString()}                </p>                <p className="text-sm text-muted-foreground">                  ({benchmark.gapPercentage >= 0 ? '+' : ''}                  {benchmark.gapPercentage.toFixed(1)}%)                </p>              </div>            </div>          ))}        </div>      </CardContent>    </Card>  )}```---ğŸ“‹ Step 2: Dashboard ComponentsExecutive Dashboard```typescript// components/dashboard/executive-dashboard.tsximport { StatCard } from '@/components/ui/stat-card'import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import {  LineChart,  Line,  BarChart,  Bar,  PieChart,  Pie,  Cell,  XAxis,  YAxis,  CartesianGrid,  Tooltip,  Legend,  ResponsiveContainer,} from 'recharts'import {  Briefcase,  Target,  TrendingUp,  DollarSign,  Users,  AlertTriangle,} from 'lucide-react'interface ExecutiveDashboardProps {  data: {    projects: {      total: number      avgCompletion: number    }    kpis: {      total: number      avgAchievement: number      byStatus: Array<{ status: string; _count: number }>    }    okrs: {      total: number      avgProgress: number      byStatus: Array<{ status: string; _count: number }>    }    strategies: {      total: number      byStatus: Array<{ status: string; _count: number }>    }    budget: {      total: number      spent: number      utilization: number    }  }}export function ExecutiveDashboard({ data }: ExecutiveDashboardProps) {  // Prepare charts data  const projectHealthData = [    { name: 'Healthy', value: 12, fill: '#22c55e' },    { name: 'At Risk', value: 5, fill: '#f59e0b' },    { name: 'Critical', value: 2, fill: '#ef4444' },  ]  const kpiPerformanceData = data.kpis.byStatus.map((s) => ({    name: s.status,    count: s._count,  }))  const budgetData = [    { name: 'Used', value: data.budget.spent, fill: '#3b82f6' },    { name: 'Remaining', value: data.budget.total - data.budget.spent, fill: '#94a3b8' },  ]  return (    <div className="space-y-6">      {/* Stats Grid */}      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">        <StatCard          title="à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”"          value={data.projects.total}          description={`à¹€à¸‰à¸¥à¸µà¹ˆà¸¢ ${data.projects.avgCompletion.toFixed(1)}% à¹€à¸ªà¸£à¹‡à¸ˆà¸ªà¸´à¹‰à¸™`}          icon={Briefcase}          trend={{ value: 12, isPositive: true }}        />        <StatCard          title="KPIs"          value={data.kpis.total}          description={`à¹€à¸‰à¸¥à¸µà¹ˆà¸¢ ${data.kpis.avgAchievement.toFixed(1)}% à¸šà¸£à¸£à¸¥à¸¸`}          icon={Target}          trend={{ value: 5, isPositive: true }}        />        <StatCard          title="OKRs"          value={data.okrs.total}          description={`à¹€à¸‰à¸¥à¸µà¹ˆà¸¢ ${data.okrs.avgProgress.toFixed(1)}% à¸„à¸§à¸²à¸¡à¸„à¸·à¸šà¸«à¸™à¹‰à¸²`}          icon={TrendingUp}          trend={{ value: 8, isPositive: true }}        />        <StatCard          title="à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“à¹ƒà¸Šà¹‰à¹„à¸›"          value={`${data.budget.utilization.toFixed(1)}%`}          description={`${(data.budget.spent / 1000000).toFixed(1)}M / ${(            data.budget.total / 1000000          ).toFixed(1)}M`}          icon={DollarSign}          trend={{ value: 3, isPositive: false }}        />      </div>      {/* Charts Grid */}      <div className="grid gap-4 md:grid-cols-2">        {/* Project Health */}        <Card>          <CardHeader>            <CardTitle>Project Health Distribution</CardTitle>          </CardHeader>          <CardContent>            <ResponsiveContainer width="100%" height={250}>              <PieChart>                <Pie                  data={projectHealthData}                  cx="50%"                  cy="50%"                  labelLine={false}                  label={(entry) => `${entry.name}: ${entry.value}`}                  outerRadius={80}                  dataKey="value"                >                  {projectHealthData.map((entry, index) => (                    <Cell key={`cell-${index}`} fill={entry.fill} />                  ))}                </Pie>                <Tooltip />              </PieChart>            </ResponsiveContainer>          </CardContent>        </Card>        {/* Budget Utilization */}        <Card>          <CardHeader>            <CardTitle>Budget Utilization</CardTitle>          </CardHeader>          <CardContent>            <ResponsiveContainer width="100%" height={250}>              <PieChart>                <Pie                  data={budgetData}                  cx="50%"                  cy="50%"                  labelLine={false}                  label={(entry) =>                    `${entry.name}: ${((entry.value / data.budget.total) * 100).toFixed(1)}%`                  }                  outerRadius={80}                  dataKey="value"                >                  {budgetData.map((entry, index) => (                    <Cell key={`cell-${index}`} fill={entry.fill} />                  ))}                </Pie>                <Tooltip />              </PieChart>            </ResponsiveContainer>          </CardContent>        </Card>      </div>      {/* KPI Performance */}      <Card>        <CardHeader>          <CardTitle>KPI Performance Overview</CardTitle>        </CardHeader>        <CardContent>          <ResponsiveContainer width="100%" height={300}>            <BarChart data={kpiPerformanceData}>              <CartesianGrid strokeDasharray="3 3" />              <XAxis dataKey="name" />              <YAxis />              <Tooltip />              <Legend />              <Bar dataKey="count" fill="#3b82f6" name="à¸ˆà¸³à¸™à¸§à¸™ KPI" />            </BarChart>          </ResponsiveContainer>        </CardContent>      </Card>    </div>  )}```Portfolio Dashboard```typescript// components/dashboard/portfolio-dashboard.tsximport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import { Badge } from '@/components/ui/badge'import { ProgressBar } from '@/components/ui/progress-bar'import {  BarChart,  Bar,  PieChart,  Pie,  Cell,  XAxis,  YAxis,  CartesianGrid,  Tooltip,  Legend,  ResponsiveContainer,} from 'recharts'import { Briefcase, Calendar, DollarSign, Users } from 'lucide-react'interface PortfolioDashboardProps {  data: {    total: number    byStatus: {      planning: number      inProgress: number      onHold: number      atRisk: number      completed: number      cancelled: number    }    byType: Array<{      projectType: string      _count: number    }>    byPriority: Array<{      priority: string      _count: number    }>    healthDistribution: {      healthy: number      atRisk: number      critical: number    }    projects: Array<{      id: string      projectName: string      status: string      completionPercentage: number      budget?: number      endDate: Date    }>  }}const COLORS = {  healthy: '#22c55e',  atRisk: '#f59e0b',  critical: '#ef4444',  planning: '#94a3b8',  inProgress: '#3b82f6',  onHold: '#f59e0b',  completed: '#22c55e',  cancelled: '#6b7280',}export function PortfolioDashboard({ data }: PortfolioDashboardProps) {  // Prepare chart data  const statusData = Object.entries(data.byStatus).map(([key, value]) => ({    name: key,    value,    fill: COLORS[key as keyof typeof COLORS],  }))  const healthData = Object.entries(data.healthDistribution).map(([key, value]) => ({    name: key === 'healthy' ? 'Healthy' : key === 'atRisk' ? 'At Risk' : 'Critical',    value,    fill: COLORS[key as keyof typeof COLORS],  }))  const typeData = data.byType.map((t) => ({    name: t.projectType,    count: t._count,  }))  return (    <div className="space-y-6">      {/* Overview Stats */}      <div className="grid gap-4 md:grid-cols-4">        <Card>          <CardHeader className="pb-2">            <CardTitle className="text-sm font-medium text-muted-foreground">              Total Projects            </CardTitle>          </CardHeader>          <CardContent>            <div className="text-3xl font-bold">{data.total}</div>          </CardContent>        </Card>        <Card>          <CardHeader className="pb-2">            <CardTitle className="text-sm font-medium text-muted-foreground">              Active            </CardTitle>          </CardHeader>          <CardContent>            <div className="text-3xl font-bold">{data.byStatus.inProgress}</div>          </CardContent>        </Card>        <Card>          <CardHeader className="pb-2">            <CardTitle className="text-sm font-medium text-muted-foreground">              At Risk            </CardTitle>          </CardHeader>          <CardContent>            <div className="text-3xl font-bold text-orange-600">              {data.byStatus.atRisk}            </div>          </CardContent>        </Card>        <Card>          <CardHeader className="pb-2">            <CardTitle className="text-sm font-medium text-muted-foreground">              Completed            </CardTitle>          </CardHeader>          <CardContent>            <div className="text-3xl font-bold text-green-600">              {data.byStatus.completed}            </div>          </CardContent>        </Card>      </div>      {/* Charts */}      <div className="grid gap-4 md:grid-cols-2">        {/* Status Distribution */}        <Card>          <CardHeader>            <CardTitle>Status Distribution</CardTitle>          </CardHeader>          <CardContent>            <ResponsiveContainer width="100%" height={250}>              <PieChart>                <Pie                  data={statusData}                  cx="50%"                  cy="50%"                  labelLine={false}                  label={(entry) => `${entry.name}: ${entry.value}`}                  outerRadius={80}                  dataKey="value"                >                  {statusData.map((entry, index) => (                    <Cell key={`cell-${index}`} fill={entry.fill} />                  ))}                </Pie>                <Tooltip />              </PieChart>            </ResponsiveContainer>          </CardContent>        </Card>        {/* Health Distribution */}        <Card>          <CardHeader>            <CardTitle>Health Distribution</CardTitle>          </CardHeader>          <CardContent>            <ResponsiveContainer width="100%" height={250}>              <PieChart>                <Pie                  data={healthData}                  cx="50%"                  cy="50%"                  labelLine={false}                  label={(entry) => `${entry.name}: ${entry.value}`}                  outerRadius={80}                  dataKey="value"                >                  {healthData.map((entry, index) => (                    <Cell key={`cell-${index}`} fill={entry.fill} />                  ))}                </Pie>                <Tooltip />              </PieChart>            </ResponsiveContainer>          </CardContent>        </Card>      </div>      {/* Project Type Distribution */}      <Card>        <CardHeader>          <CardTitle>Projects by Type</CardTitle>        </CardHeader>        <CardContent>          <ResponsiveContainer width="100%" height={300}>            <BarChart data={typeData}>              <CartesianGrid strokeDasharray="3 3" />              <XAxis dataKey="name" />              <YAxis />              <Tooltip />              <Bar dataKey="count" fill="#3b82f6" />            </BarChart>          </ResponsiveContainer>        </CardContent>      </Card>      {/* Top Projects */}      <Card>        <CardHeader>          <CardTitle>Top 10 Projects</CardTitle>        </CardHeader>        <CardContent>          <div className="space-y-3">            {data.projects.slice(0, 10).map((project) => (              <div                key={project.id}                className="flex items-center justify-between p-3 rounded-lg border hover:bg-muted/50 cursor-pointer"              >                <div className="flex-1 min-w-0">                  <h4 className="font-medium truncate">{project.projectName}</h4>                  <div className="flex items-center gap-4 mt-2">                    <ProgressBar                      value={project.completionPercentage}                      className="flex-1"                      size="sm"                    />                    <span className="text-sm text-muted-foreground whitespace-nowrap">                      {project.completionPercentage}%                    </span>                  </div>                </div>              </div>            ))}          </div>        </CardContent>      </Card>    </div>  )}```BSC Strategy Map```typescript// components/dashboard/bsc-strategy-map.tsximport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import { Badge } from '@/components/ui/badge'import { cn } from '@/lib/utils'import { Target, ArrowDown } from 'lucide-react'interface Objective {  id: string  name: string  perspective: 'FINANCIAL' | 'CUSTOMER' | 'INTERNAL_PROCESS' | 'LEARNING_GROWTH'  achievement: number  weight: number  causeRelationships: Array<{    effectObjectiveId: string    strength: number  }>}interface BSCStrategyMapProps {  objectives: Objective[]}const perspectiveConfig = {  FINANCIAL: { label: 'à¸à¸²à¸£à¹€à¸‡à¸´à¸™', color: 'bg-purple-500', order: 1 },  CUSTOMER: { label: 'à¸¥à¸¹à¸à¸„à¹‰à¸²', color: 'bg-blue-500', order: 2 },  INTERNAL_PROCESS: { label: 'à¸à¸£à¸°à¸šà¸§à¸™à¸à¸²à¸£à¸ à¸²à¸¢à¹ƒà¸™', color: 'bg-green-500', order: 3 },  LEARNING_GROWTH: { label: 'à¸à¸²à¸£à¹€à¸£à¸µà¸¢à¸™à¸£à¸¹à¹‰à¹à¸¥à¸°à¸à¸±à¸’à¸™à¸²', color: 'bg-orange-500', order: 4 },}export function BSCStrategyMap({ objectives }: BSCStrategyMapProps) {  // Group by perspective  const grouped = objectives.reduce((acc, obj) => {    if (!acc[obj.perspective]) acc[obj.perspective] = []    acc[obj.perspective].push(obj)    return acc  }, {} as Record<string, Objective[]>)  // Sort perspectives  const perspectives = Object.keys(grouped).sort(    (a, b) =>      perspectiveConfig[a as keyof typeof perspectiveConfig].order -      perspectiveConfig[b as keyof typeof perspectiveConfig].order  )  const getAchievementColor = (achievement: number) => {    if (achievement >= 90) return 'border-green-500 bg-green-50'    if (achievement >= 70) return 'border-yellow-500 bg-yellow-50'    return 'border-red-500 bg-red-50'  }  return (    <Card>      <CardHeader>        <CardTitle>Balanced Scorecard - Strategy Map</CardTitle>      </CardHeader>      <CardContent>        <div className="space-y-8">          {perspectives.map((perspective, pIndex) => {            const config = perspectiveConfig[perspective as keyof typeof perspectiveConfig]            const objs = grouped[perspective]            return (              <div key={perspective} className="space-y-4">                {/* Perspective Header */}                <div className="flex items-center gap-3">                  <Badge className={cn('text-white', config.color)}>                    {config.label}                  </Badge>                  <div className="flex-1 h-0.5 bg-border" />                </div>                {/* Objectives Grid */}                <div className="grid gap-3 md:grid-cols-3">                  {objs.map((obj) => (                    <div                      key={obj.id}                      className={cn(                        'p-4 rounded-lg border-2 relative',                        getAchievementColor(obj.achievement)                      )}                    >                      <div className="flex items-start justify-between gap-2 mb-2">                        <Target className="h-4 w-4 mt-0.5 flex-shrink-0" />                        <Badge variant="outline" className="text-xs">                          {obj.weight}%                        </Badge>                      </div>                      <h4 className="font-medium text-sm mb-2">{obj.name}</h4>                      <div className="flex items-center justify-between">                        <span className="text-xs text-muted-foreground">                          Achievement                        </span>                        <span className="font-bold">{obj.achievement.toFixed(1)}%</span>                      </div>                      {/* Connection indicators */}                      {obj.causeRelationships.length > 0 && (                        <div className="absolute -bottom-4 left-1/2 transform -translate-x-1/2">                          <ArrowDown className="h-4 w-4 text-muted-foreground" />                        </div>                      )}                    </div>                  ))}                </div>                {/* Separator */}                {pIndex < perspectives.length - 1 && (                  <div className="h-8 flex items-center justify-center">                    <div className="w-0.5 h-full bg-border" />                  </div>                )}              </div>            )          })}        </div>        {/* Legend */}        <div className="flex items-center gap-4 mt-6 pt-6 border-t text-sm">          <div className="flex items-center gap-2">            <div className="w-4 h-4 border-2 border-green-500 bg-green-50 rounded" />            <span>à¸”à¸µà¹€à¸¢à¸µà¹ˆà¸¢à¸¡ (â‰¥90%)</span>          </div>          <div className="flex items-center gap-2">            <div className="w-4 h-4 border-2 border-yellow-500 bg-yellow-50 rounded" />            <span>à¸›à¸²à¸™à¸à¸¥à¸²à¸‡ (70-89%)</span>          </div>          <div className="flex items-center gap-2">            <div className="w-4 h-4 border-2 border-red-500 bg-red-50 rounded" />            <span>à¸•à¹‰à¸­à¸‡à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡ (&lt;70%)</span>          </div>        </div>      </CardContent>    </Card>  )}```---ğŸ“‹ Step 3: Activity Feed Component```typescript// components/dashboard/activity-feed.tsximport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import { Avatar } from '@/components/ui/avatar'import { Badge } from '@/components/ui/badge'import { formatDistanceToNow } from 'date-fns'import { th } from 'date-fns/locale'import {  FileText,  Target,  CheckCircle2,  AlertTriangle,  MessageSquare,  UserPlus,} from 'lucide-react'interface Activity {  id: string  action: string  entityType: string  user: {    fullName: string    avatar?: string  }  createdAt: Date  metadata?: Record<string, any>}interface ActivityFeedProps {  activities: Activity[]}const actionIcons: Record<string, any> = {  'project.create': FileText,  'project.update': FileText,  'task.complete': CheckCircle2,  'okr.checkin': Target,  'kpi.record': Target,  'risk.create': AlertTriangle,  'comment.add': MessageSquare,  'member.add': UserPlus,}const actionLabels: Record<string, string> = {  'project.create': 'à¸ªà¸£à¹‰à¸²à¸‡à¹‚à¸„à¸£à¸‡à¸à¸²à¸£',  'project.update': 'à¸­à¸±à¸›à¹€à¸”à¸•à¹‚à¸„à¸£à¸‡à¸à¸²à¸£',  'task.complete': 'à¸—à¸³à¸‡à¸²à¸™à¹€à¸ªà¸£à¹‡à¸ˆ',  'okr.checkin': 'Check-in OKR',  'kpi.record': 'à¸šà¸±à¸™à¸—à¸¶à¸ KPI',  'risk.create': 'à¹€à¸à¸´à¹ˆà¸¡à¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¹ˆà¸¢à¸‡',  'comment.add': 'à¹à¸ªà¸”à¸‡à¸„à¸§à¸²à¸¡à¸„à¸´à¸”à¹€à¸«à¹‡à¸™',  'member.add': 'à¹€à¸à¸´à¹ˆà¸¡à¸ªà¸¡à¸²à¸Šà¸´à¸',}export function ActivityFeed({ activities }: ActivityFeedProps) {  return (    <Card>      <CardHeader>        <CardTitle>à¸à¸´à¸ˆà¸à¸£à¸£à¸¡à¸¥à¹ˆà¸²à¸ªà¸¸à¸”</CardTitle>      </CardHeader>      <CardContent>        <div className="space-y-4">          {activities.map((activity) => {            const Icon = actionIcons[activity.action] || FileText            const label = actionLabels[activity.action] || activity.action            return (              <div key={activity.id} className="flex gap-3">                <Avatar                  src={activity.user.avatar}                  fallback={activity.user.fullName}                  size="sm"                />                <div className="flex-1 space-y-1">                  <div className="flex items-start justify-between gap-2">                    <p className="text-sm">                      <span className="font-medium">{activity.user.fullName}</span>{' '}                      {label}                    </p>                    <span className="text-xs text-muted-foreground whitespace-nowrap">                      {formatDistanceToNow(new Date(activity.createdAt), {                        locale: th,                        addSuffix: true,                      })}                    </span>                  </div>                  {activity.metadata && (                    <p className="text-xs text-muted-foreground">                      {activity.metadata.description}                    </p>                  )}                </div>                <Icon className="h-4 w-4 text-muted-foreground flex-shrink-0" />              </div>            )          })}        </div>      </CardContent>    </Card>  )}```---âœ… Complete UI Components Summaryà¹€à¸£à¸²à¸ªà¸£à¹‰à¸²à¸‡à¸„à¸£à¸šà¹à¸¥à¹‰à¸§:Base Components âœ…Button, Card, BadgeInput, Select, TextareaProgress Bar, AvatarData Table with sorting/filteringProject Components âœ…Project CardGantt ChartRisk MatrixOKR Components âœ…OKR CardCascade TreeCheck-in FormKPI Components âœ…KPI CardCascade TreeTrend ChartBenchmark ComparisonDashboard Components âœ…Executive DashboardPortfolio DashboardBSC Strategy MapActivity Feed---ğŸš€ Next Stepsà¹€à¸£à¸²à¸¡à¸µ Complete Component Library à¹à¸¥à¹‰à¸§! à¸•à¹ˆà¸­à¹„à¸›à¸—à¸³à¸­à¸°à¹„à¸£à¸”à¸µ:âœ… Create Page Layoutsâœ… Add Form Components (Create/Edit)âœ… Real-time Updates (WebSocket)âœ… Export/Import Featuresâœ… Mobile Responsive Optimizationâœ… Dark Mode Supportà¸à¸£à¹‰à¸­à¸¡à¸—à¸³à¸•à¹ˆà¸­à¹„à¸«à¸¡à¸„à¸£à¸±à¸š? ğŸ¨ğŸš€---ğŸ¨ React UI - Complete Page Layoutsà¸ªà¸£à¹‰à¸²à¸‡ Complete Page Layouts à¸ªà¸³à¸«à¸£à¸±à¸šà¸—à¸¸à¸ modules à¸à¸£à¹‰à¸­à¸¡ Navigation, Filters, à¹à¸¥à¸° Actions!---ğŸ“‹ Step 1: Layout ComponentsMain Layout```typescript// components/layout/main-layout.tsximport { ReactNode, useState } from 'react'import { useSession } from 'next-auth/react'import { useRouter } from 'next/router'import { cn } from '@/lib/utils'import { Sidebar } from './sidebar'import { Header } from './header'import { Breadcrumbs } from './breadcrumbs'interface MainLayoutProps {  children: ReactNode  title?: string  description?: string  actions?: ReactNode}export function MainLayout({ children, title, description, actions }: MainLayoutProps) {  const [sidebarOpen, setSidebarOpen] = useState(true)  const { data: session } = useSession()  return (    <div className="min-h-screen bg-background">      {/* Sidebar */}      <Sidebar isOpen={sidebarOpen} onToggle={() => setSidebarOpen(!sidebarOpen)} />      {/* Main Content */}      <div        className={cn(          'transition-all duration-300',          sidebarOpen ? 'lg:pl-64' : 'lg:pl-20'        )}      >        {/* Header */}        <Header          user={session?.user}          onMenuClick={() => setSidebarOpen(!sidebarOpen)}        />        {/* Page Content */}        <main className="p-6 space-y-6">          {/* Breadcrumbs */}          <Breadcrumbs />          {/* Page Header */}          {(title || actions) && (            <div className="flex items-start justify-between gap-4">              <div className="space-y-1">                {title && (                  <h1 className="text-3xl font-bold tracking-tight">{title}</h1>                )}                {description && (                  <p className="text-muted-foreground">{description}</p>                )}              </div>              {actions && <div className="flex gap-2">{actions}</div>}            </div>          )}          {/* Page Content */}          <div>{children}</div>        </main>      </div>    </div>  )}```Sidebar```typescript// components/layout/sidebar.tsximport Link from 'next/link'import { useRouter } from 'next/router'import { cn } from '@/lib/utils'import {  LayoutDashboard,  Briefcase,  Target,  TrendingUp,  BarChart3,  FileText,  Users,  Settings,  ChevronLeft,  ChevronRight,} from 'lucide-react'interface SidebarProps {  isOpen: boolean  onToggle: () => void}const navigation = [  { name: 'Dashboard', href: '/dashboard', icon: LayoutDashboard },  { name: 'Projects', href: '/projects', icon: Briefcase },  { name: 'OKRs', href: '/okrs', icon: Target },  { name: 'KPIs', href: '/kpis', icon: TrendingUp },  { name: 'Strategy', href: '/strategy', icon: BarChart3 },  { name: 'Logframe', href: '/logframe', icon: FileText },  { name: 'Team', href: '/team', icon: Users },  { name: 'Settings', href: '/settings', icon: Settings },]export function Sidebar({ isOpen, onToggle }: SidebarProps) {  const router = useRouter()  return (    <>      {/* Backdrop for mobile */}      {isOpen && (        <div          className="fixed inset-0 bg-black/50 z-40 lg:hidden"          onClick={onToggle}        />      )}      {/* Sidebar */}      <aside        className={cn(          'fixed left-0 top-0 z-50 h-screen bg-card border-r transition-all duration-300',          isOpen ? 'w-64' : 'w-20'        )}      >        {/* Logo */}        <div className="flex items-center justify-between h-16 px-4 border-b">          {isOpen && (            <Link href="/dashboard" className="flex items-center gap-2">              <div className="w-8 h-8 bg-primary rounded-lg flex items-center justify-center">                <Target className="h-5 w-5 text-primary-foreground" />              </div>              <span className="font-bold text-xl">SPM System</span>            </Link>          )}          {!isOpen && (            <div className="w-8 h-8 bg-primary rounded-lg flex items-center justify-center mx-auto">              <Target className="h-5 w-5 text-primary-foreground" />            </div>          )}        </div>        {/* Navigation */}        <nav className="flex-1 overflow-y-auto p-4 space-y-2">          {navigation.map((item) => {            const isActive = router.pathname.startsWith(item.href)            const Icon = item.icon            return (              <Link                key={item.href}                href={item.href}                className={cn(                  'flex items-center gap-3 px-3 py-2 rounded-lg transition-colors',                  isActive                    ? 'bg-primary text-primary-foreground'                    : 'hover:bg-muted',                  !isOpen && 'justify-center'                )}              >                <Icon className="h-5 w-5 flex-shrink-0" />                {isOpen && <span className="font-medium">{item.name}</span>}              </Link>            )          })}        </nav>        {/* Toggle Button */}        <button          onClick={onToggle}          className="hidden lg:flex absolute -right-3 top-20 w-6 h-6 bg-card border rounded-full items-center justify-center hover:bg-muted"        >          {isOpen ? (            <ChevronLeft className="h-4 w-4" />          ) : (            <ChevronRight className="h-4 w-4" />          )}        </button>      </aside>    </>  )}```Header```typescript// components/layout/header.tsximport { Avatar } from '@/components/ui/avatar'import { Button } from '@/components/ui/button'import {  DropdownMenu,  DropdownMenuContent,  DropdownMenuItem,  DropdownMenuLabel,  DropdownMenuSeparator,  DropdownMenuTrigger,} from '@/components/ui/dropdown-menu'import { Bell, Menu, Search, Settings, LogOut } from 'lucide-react'import { signOut } from 'next-auth/react'interface HeaderProps {  user?: {    name?: string    email?: string    image?: string  }  onMenuClick: () => void}export function Header({ user, onMenuClick }: HeaderProps) {  return (    <header className="sticky top-0 z-40 bg-background border-b">      <div className="flex items-center justify-between h-16 px-6">        {/* Left */}        <div className="flex items-center gap-4">          <Button            variant="ghost"            size="icon"            onClick={onMenuClick}            className="lg:hidden"          >            <Menu className="h-5 w-5" />          </Button>          {/* Search */}          <div className="hidden md:flex items-center gap-2 px-3 py-2 bg-muted rounded-lg w-96">            <Search className="h-4 w-4 text-muted-foreground" />            <input              type="text"              placeholder="à¸„à¹‰à¸™à¸«à¸²à¹‚à¸„à¸£à¸‡à¸à¸²à¸£, OKR, KPI..."              className="flex-1 bg-transparent border-none outline-none text-sm"            />            <kbd className="hidden md:inline-flex h-5 select-none items-center gap-1 rounded border bg-background px-1.5 font-mono text-xs text-muted-foreground">              âŒ˜K            </kbd>          </div>        </div>        {/* Right */}        <div className="flex items-center gap-2">          {/* Notifications */}          <Button variant="ghost" size="icon" className="relative">            <Bell className="h-5 w-5" />            <span className="absolute top-1 right-1 w-2 h-2 bg-red-500 rounded-full" />          </Button>          {/* User Menu */}          <DropdownMenu>            <DropdownMenuTrigger asChild>              <button className="flex items-center gap-2 hover:bg-muted rounded-lg p-2">                <Avatar                  src={user?.image}                  fallback={user?.name || 'U'}                  size="sm"                />                <div className="hidden md:block text-left">                  <p className="text-sm font-medium">{user?.name}</p>                  <p className="text-xs text-muted-foreground">{user?.email}</p>                </div>              </button>            </DropdownMenuTrigger>            <DropdownMenuContent align="end" className="w-56">              <DropdownMenuLabel>My Account</DropdownMenuLabel>              <DropdownMenuSeparator />              <DropdownMenuItem>                <Settings className="mr-2 h-4 w-4" />                Settings              </DropdownMenuItem>              <DropdownMenuSeparator />              <DropdownMenuItem onClick={() => signOut()}>                <LogOut className="mr-2 h-4 w-4" />                Sign out              </DropdownMenuItem>            </DropdownMenuContent>          </DropdownMenu>        </div>      </div>    </header>  )}```Breadcrumbs```typescript// components/layout/breadcrumbs.tsximport Link from 'next/link'import { useRouter } from 'next/router'import { ChevronRight, Home } from 'lucide-react'import { cn } from '@/lib/utils'export function Breadcrumbs() {  const router = useRouter()  const pathSegments = router.pathname.split('/').filter(Boolean)  // Generate breadcrumb items  const breadcrumbs = [    { label: 'Home', href: '/dashboard', icon: Home },    ...pathSegments.map((segment, index) => {      const href = '/' + pathSegments.slice(0, index + 1).join('/')      const label = segment        .split('-')        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))        .join(' ')      return { label, href }    }),  ]  if (pathSegments.length === 0) return null  return (    <nav className="flex items-center gap-2 text-sm">      {breadcrumbs.map((item, index) => {        const isLast = index === breadcrumbs.length - 1        const Icon = item.icon        return (          <div key={item.href} className="flex items-center gap-2">            {index > 0 && <ChevronRight className="h-4 w-4 text-muted-foreground" />}            {isLast ? (              <span className="font-medium">{item.label}</span>            ) : (              <Link                href={item.href}                className="text-muted-foreground hover:text-foreground transition-colors"              >                {Icon ? <Icon className="h-4 w-4" /> : item.label}              </Link>            )}          </div>        )      })}    </nav>  )}```---ğŸ“‹ Step 2: Project PagesProjects List Page```typescript// pages/projects/index.tsximport { useState } from 'react'import { MainLayout } from '@/components/layout/main-layout'import { ProjectCard } from '@/components/project/project-card'import { Button } from '@/components/ui/button'import { Input } from '@/components/ui/input'import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'import { trpc } from '@/lib/trpc'import { Plus, Search, Filter, Grid3x3, List } from 'lucide-react'import Link from 'next/link'export default function ProjectsPage() {  const [view, setView] = useState<'grid' | 'list'>('grid')  const [searchQuery, setSearchQuery] = useState('')  const [statusFilter, setStatusFilter] = useState<string>('all')  const [typeFilter, setTypeFilter] = useState<string>('all')  const { data, isLoading } = trpc.project.list.useQuery({    page: 1,    perPage: 20,    query: searchQuery,    status: statusFilter !== 'all' ? statusFilter : undefined,    projectType: typeFilter !== 'all' ? typeFilter : undefined,  })  return (    <MainLayout      title="Projects"      description="à¸ˆà¸±à¸”à¸à¸²à¸£à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”à¹ƒà¸™à¸­à¸‡à¸„à¹Œà¸à¸£"      actions={        <Link href="/projects/new">          <Button>            <Plus className="h-4 w-4 mr-2" />            à¸ªà¸£à¹‰à¸²à¸‡à¹‚à¸„à¸£à¸‡à¸à¸²à¸£          </Button>        </Link>      }    >      {/* Filters */}      <div className="flex flex-col md:flex-row gap-4">        {/* Search */}        <div className="flex-1 relative">          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />          <Input            placeholder="à¸„à¹‰à¸™à¸«à¸²à¹‚à¸„à¸£à¸‡à¸à¸²à¸£..."            value={searchQuery}            onChange={(e) => setSearchQuery(e.target.value)}            className="pl-10"          />        </div>        {/* Status Filter */}        <Select value={statusFilter} onValueChange={setStatusFilter}>          <SelectTrigger className="w-48">            <SelectValue placeholder="à¸ªà¸–à¸²à¸™à¸°" />          </SelectTrigger>          <SelectContent>            <SelectItem value="all">à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”</SelectItem>            <SelectItem value="PLANNING">à¸§à¸²à¸‡à¹à¸œà¸™</SelectItem>            <SelectItem value="IN_PROGRESS">à¸”à¸³à¹€à¸™à¸´à¸™à¸à¸²à¸£</SelectItem>            <SelectItem value="ON_HOLD">à¸à¸±à¸à¸Šà¸±à¹ˆà¸§à¸„à¸£à¸²à¸§</SelectItem>            <SelectItem value="COMPLETED">à¹€à¸ªà¸£à¹‡à¸ˆà¸ªà¸´à¹‰à¸™</SelectItem>          </SelectContent>        </Select>        {/* Type Filter */}        <Select value={typeFilter} onValueChange={setTypeFilter}>          <SelectTrigger className="w-48">            <SelectValue placeholder="à¸›à¸£à¸°à¹€à¸ à¸—" />          </SelectTrigger>          <SelectContent>            <SelectItem value="all">à¸—à¸¸à¸à¸›à¸£à¸°à¹€à¸ à¸—</SelectItem>            <SelectItem value="STRATEGIC">à¸¢à¸¸à¸—à¸˜à¸¨à¸²à¸ªà¸•à¸£à¹Œ</SelectItem>            <SelectItem value="OPERATIONAL">à¸›à¸à¸´à¸šà¸±à¸•à¸´à¸à¸²à¸£</SelectItem>            <SelectItem value="INNOVATION">à¸™à¸§à¸±à¸•à¸à¸£à¸£à¸¡</SelectItem>          </SelectContent>        </Select>        {/* View Toggle */}        <div className="flex gap-1 border rounded-lg p-1">          <Button            variant={view === 'grid' ? 'default' : 'ghost'}            size="icon"            onClick={() => setView('grid')}          >            <Grid3x3 className="h-4 w-4" />          </Button>          <Button            variant={view === 'list' ? 'default' : 'ghost'}            size="icon"            onClick={() => setView('list')}          >            <List className="h-4 w-4" />          </Button>        </div>      </div>      {/* Tabs */}      <Tabs defaultValue="all" className="space-y-4">        <TabsList>          <TabsTrigger value="all">            à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸” ({data?.pagination.total || 0})          </TabsTrigger>          <TabsTrigger value="my">à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¸‚à¸­à¸‡à¸‰à¸±à¸™</TabsTrigger>          <TabsTrigger value="watching">à¸•à¸´à¸”à¸•à¸²à¸¡</TabsTrigger>          <TabsTrigger value="at-risk">à¸¡à¸µà¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¹ˆà¸¢à¸‡</TabsTrigger>        </TabsList>        <TabsContent value="all" className="space-y-4">          {isLoading ? (            <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">              {Array.from({ length: 6 }).map((_, i) => (                <div key={i} className="h-64 bg-muted rounded-lg animate-pulse" />              ))}            </div>          ) : view === 'grid' ? (            <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">              {data?.data.map((project) => (                <ProjectCard key={project.id} project={project} />              ))}            </div>          ) : (            <div className="space-y-3">              {data?.data.map((project) => (                <ProjectCard key={project.id} project={project} />              ))}            </div>          )}          {!isLoading && data?.data.length === 0 && (            <div className="text-center py-12">              <p className="text-muted-foreground">à¹„à¸¡à¹ˆà¸à¸šà¹‚à¸„à¸£à¸‡à¸à¸²à¸£</p>            </div>          )}        </TabsContent>        {/* Other tabs... */}      </Tabs>    </MainLayout>  )}```Project Detail Page```typescript// pages/projects/[id].tsximport { MainLayout } from '@/components/layout/main-layout'import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import { Button } from '@/components/ui/button'import { Badge } from '@/components/ui/badge'import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'import { StatusBadge } from '@/components/ui/status-badge'import { ProgressBar } from '@/components/ui/progress-bar'import { Avatar } from '@/components/ui/avatar'import { GanttChart } from '@/components/project/gantt-chart'import { RiskMatrix } from '@/components/project/risk-matrix'import { trpc } from '@/lib/trpc'import { useRouter } from 'next/router'import { formatDate, formatCurrency } from '@/lib/utils'import {  Calendar,  DollarSign,  Users,  Target,  AlertTriangle,  FileText,  Edit,  MoreHorizontal,} from 'lucide-react'export default function ProjectDetailPage() {  const router = useRouter()  const { id } = router.query  const { data: project, isLoading } = trpc.project.getById.useQuery(    { id: id as string },    { enabled: !!id }  )  if (isLoading) {    return (      <MainLayout>        <div className="animate-pulse space-y-4">          <div className="h-12 bg-muted rounded" />          <div className="h-64 bg-muted rounded" />        </div>      </MainLayout>    )  }  if (!project) {    return (      <MainLayout>        <div className="text-center py-12">          <p className="text-muted-foreground">à¹„à¸¡à¹ˆà¸à¸šà¹‚à¸„à¸£à¸‡à¸à¸²à¸£</p>        </div>      </MainLayout>    )  }  return (    <MainLayout      title={project.projectName}      description={project.projectCode}      actions={        <>          <Button variant="outline">            <FileText className="h-4 w-4 mr-2" />            Export          </Button>          <Button variant="outline">            <Edit className="h-4 w-4 mr-2" />            à¹à¸à¹‰à¹„à¸‚          </Button>          <Button variant="ghost" size="icon">            <MoreHorizontal className="h-4 w-4" />          </Button>        </>      }    >      {/* Overview Cards */}      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">        <Card>          <CardHeader className="pb-3">            <CardTitle className="text-sm font-medium text-muted-foreground">              à¸ªà¸–à¸²à¸™à¸°            </CardTitle>          </CardHeader>          <CardContent>            <StatusBadge status={project.status} type="project" />          </CardContent>        </Card>        <Card>          <CardHeader className="pb-3">            <CardTitle className="text-sm font-medium text-muted-foreground">              à¸„à¸§à¸²à¸¡à¸„à¸·à¸šà¸«à¸™à¹‰à¸²            </CardTitle>          </CardHeader>          <CardContent>            <div className="space-y-2">              <div className="text-2xl font-bold">                {project.completionPercentage}%              </div>              <ProgressBar value={project.completionPercentage} />            </div>          </CardContent>        </Card>        <Card>          <CardHeader className="pb-3">            <CardTitle className="text-sm font-medium text-muted-foreground">              à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“            </CardTitle>          </CardHeader>          <CardContent>            <div className="text-2xl font-bold">              {formatCurrency(project.budget || 0)}            </div>            <p className="text-xs text-muted-foreground mt-1">              à¹ƒà¸Šà¹‰à¹„à¸›: {formatCurrency(project.actualCost || 0)}            </p>          </CardContent>        </Card>        <Card>          <CardHeader className="pb-3">            <CardTitle className="text-sm font-medium text-muted-foreground">              à¸£à¸°à¸¢à¸°à¹€à¸§à¸¥à¸²            </CardTitle>          </CardHeader>          <CardContent>            <div className="space-y-1">              <div className="flex items-center gap-2 text-sm">                <Calendar className="h-4 w-4 text-muted-foreground" />                <span>{formatDate(project.startDate)}</span>              </div>              <div className="flex items-center gap-2 text-sm">                <Calendar className="h-4 w-4 text-muted-foreground" />                <span>{formatDate(project.endDate)}</span>              </div>            </div>          </CardContent>        </Card>      </div>      {/* Main Content */}      <Tabs defaultValue="overview" className="space-y-4">        <TabsList>          <TabsTrigger value="overview">Overview</TabsTrigger>          <TabsTrigger value="tasks">            à¸‡à¸²à¸™ ({project.tasks?.length || 0})          </TabsTrigger>          <TabsTrigger value="gantt">Gantt</TabsTrigger>          <TabsTrigger value="team">            à¸—à¸µà¸¡ ({project.teamMembers?.length || 0})          </TabsTrigger>          <TabsTrigger value="risks">            à¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¹ˆà¸¢à¸‡ ({project.risks?.length || 0})          </TabsTrigger>          <TabsTrigger value="documents">à¹€à¸­à¸à¸ªà¸²à¸£</TabsTrigger>        </TabsList>        {/* Overview Tab */}        <TabsContent value="overview" className="space-y-4">          <div className="grid gap-4 md:grid-cols-3">            {/* Description */}            <Card className="md:col-span-2">              <CardHeader>                <CardTitle>à¸£à¸²à¸¢à¸¥à¸°à¹€à¸­à¸µà¸¢à¸”</CardTitle>              </CardHeader>              <CardContent>                <p className="text-muted-foreground">                  {project.projectDescription}                </p>              </CardContent>            </Card>            {/* Project Manager */}            <Card>              <CardHeader>                <CardTitle>à¸œà¸¹à¹‰à¸ˆà¸±à¸”à¸à¸²à¸£à¹‚à¸„à¸£à¸‡à¸à¸²à¸£</CardTitle>              </CardHeader>              <CardContent>                <div className="flex items-center gap-3">                  <Avatar                    src={project.projectManager?.avatar}                    fallback={project.projectManager?.fullName}                    size="lg"                  />                  <div>                    <p className="font-medium">                      {project.projectManager?.fullName}                    </p>                    <p className="text-sm text-muted-foreground">                      {project.projectManager?.email}                    </p>                  </div>                </div>              </CardContent>            </Card>          </div>          {/* Milestones */}          <Card>            <CardHeader>              <CardTitle>Milestones</CardTitle>            </CardHeader>            <CardContent>              <div className="space-y-3">                {project.milestones?.map((milestone) => (                  <div                    key={milestone.id}                    className="flex items-center justify-between p-3 rounded-lg border"                  >                    <div className="flex-1">                      <h4 className="font-medium">{milestone.milestoneName}</h4>                      <p className="text-sm text-muted-foreground">                        {formatDate(milestone.dueDate)}                      </p>                    </div>                    <StatusBadge status={milestone.status} type="task" />                  </div>                ))}              </div>            </CardContent>          </Card>          {/* Health Status */}          {project.health && (            <Card>              <CardHeader>                <CardTitle>à¸ªà¸¸à¸‚à¸ à¸²à¸à¹‚à¸„à¸£à¸‡à¸à¸²à¸£</CardTitle>              </CardHeader>              <CardContent>                <div className="grid gap-4 md:grid-cols-2">                  <div>                    <div className="flex items-center justify-between mb-2">                      <span className="text-sm text-muted-foreground">                        Overall Score                      </span>                      <span className="text-2xl font-bold">                        {project.health.score}/100                      </span>                    </div>                    <ProgressBar value={project.health.score} />                  </div>                  <div className="grid grid-cols-2 gap-3">                    <div className="p-3 rounded-lg border">                      <p className="text-xs text-muted-foreground">                        Schedule Variance                      </p>                      <p className="text-lg font-bold">                        {project.health.scheduleVariance.toFixed(1)}%                      </p>                    </div>                    <div className="p-3 rounded-lg border">                      <p className="text-xs text-muted-foreground">High Risks</p>                      <p className="text-lg font-bold text-orange-600">                        {project.health.highRisks}                      </p>                    </div>                  </div>                </div>              </CardContent>            </Card>          )}        </TabsContent>        {/* Gantt Tab */}        <TabsContent value="gantt">          <GanttChart            tasks={project.tasks || []}            projectStart={project.startDate}            projectEnd={project.endDate}          />        </TabsContent>        {/* Risks Tab */}        <TabsContent value="risks">          <RiskMatrix risks={project.risks || []} />        </TabsContent>        {/* Other tabs... */}      </Tabs>    </MainLayout>  )}```---ğŸ“‹ Step 3: OKR PagesOKRs List Page```typescript// pages/okrs/index.tsximport { useState } from 'react'import { MainLayout } from '@/components/layout/main-layout'import { OKRCard } from '@/components/okr/okr-card'import { Button } from '@/components/ui/button'import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'import { trpc } from '@/lib/trpc'import { Plus, RefreshCw } from 'lucide-react'import Link from 'next/link'export default function OKRsPage() {  const [cycleId, setCycleId] = useState<string>('')  const [typeFilter, setTypeFilter] = useState<string>('all')  const { data: cycles } = trpc.okr.listCycles.useQuery({    page: 1,    perPage: 10,  })  const { data: okrs, isLoading } = trpc.okr.list.useQuery(    {      page: 1,      perPage: 20,      cycleId: cycleId || cycles?.data[0]?.id,      okrType: typeFilter !== 'all' ? typeFilter : undefined,    },    { enabled: !!cycleId || !!cycles?.data[0]?.id }  )  return (    <MainLayout      title="OKRs"      description="à¸šà¸£à¸´à¸«à¸²à¸£à¸ˆà¸±à¸”à¸à¸²à¸£ Objectives à¹à¸¥à¸° Key Results"      actions={        <>          <Button variant="outline">            <RefreshCw className="h-4 w-4 mr-2" />            Sync Progress          </Button>          <Link href="/okrs/new">            <Button>              <Plus className="h-4 w-4 mr-2" />              à¸ªà¸£à¹‰à¸²à¸‡ OKR            </Button>          </Link>        </>      }    >      {/* Filters */}      <div className="flex flex-col md:flex-row gap-4">        {/* Cycle Selector */}        <Select          value={cycleId}          onValueChange={setCycleId}        >          <SelectTrigger className="w-64">            <SelectValue placeholder="à¹€à¸¥à¸·à¸­à¸ Cycle" />          </SelectTrigger>          <SelectContent>            {cycles?.data.map((cycle) => (              <SelectItem key={cycle.id} value={cycle.id}>                {cycle.cycleName} ({cycle.fiscalYear})              </SelectItem>            ))}          </SelectContent>        </Select>        {/* Type Filter */}        <Select value={typeFilter} onValueChange={setTypeFilter}>          <SelectTrigger className="w-48">            <SelectValue placeholder="à¸£à¸°à¸”à¸±à¸š" />          </SelectTrigger>          <SelectContent>            <SelectItem value="all">à¸—à¸¸à¸à¸£à¸°à¸”à¸±à¸š</SelectItem>            <SelectItem value="COMPANY">à¸­à¸‡à¸„à¹Œà¸à¸£</SelectItem>            <SelectItem value="DEPARTMENT">à¹à¸œà¸™à¸</SelectItem>            <SelectItem value="TEAM">à¸—à¸µà¸¡</SelectItem>            <SelectItem value="INDIVIDUAL">à¸šà¸¸à¸„à¸„à¸¥</SelectItem>          </SelectContent>        </Select>      </div>      {/* Tabs */}      <Tabs defaultValue="all" className="space-y-4">        <TabsList>          <TabsTrigger value="all">            à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸” ({okrs?.pagination.total || 0})          </TabsTrigger>          <TabsTrigger value="my">OKR à¸‚à¸­à¸‡à¸‰à¸±à¸™</TabsTrigger>          <TabsTrigger value="team">à¸—à¸µà¸¡à¸‚à¸­à¸‡à¸‰à¸±à¸™</TabsTrigger>          <TabsTrigger value="company">à¸£à¸°à¸”à¸±à¸šà¸­à¸‡à¸„à¹Œà¸à¸£</TabsTrigger>        </TabsList>        <TabsContent value="all" className="space-y-4">          {isLoading ? (            <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">              {Array.from({ length: 6 }).map((_, i) => (                <div key={i} className="h-80 bg-muted rounded-lg animate-pulse" />              ))}            </div>          ) : (            <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">              {okrs?.data.map((okr) => (                <OKRCard key={okr.id} okr={okr} />              ))}            </div>          )}          {!isLoading && okrs?.data.length === 0 && (            <div className="text-center py-12">              <p className="text-muted-foreground">à¹„à¸¡à¹ˆà¸à¸š OKR</p>            </div>          )}        </TabsContent>      </Tabs>    </MainLayout>  )}```OKR Detail Page```typescript// pages/okrs/[id].tsximport { MainLayout } from '@/components/layout/main-layout'import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import { Button } from '@/components/ui/button'import { Badge } from '@/components/ui/badge'import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'import { StatusBadge } from '@/components/ui/status-badge'import { ProgressBar } from '@/components/ui/progress-bar'import { Avatar } from '@/components/ui/avatar'import { OKRCascadeTree } from '@/components/okr/okr-cascade-tree'import { trpc } from '@/lib/trpc'import { useRouter } from 'next/router'import {  Target,  TrendingUp,  Calendar,  Edit,  MessageSquare,  Share2,} from 'lucide-react'import Link from 'next/link'export default function OKRDetailPage() {  const router = useRouter()  const { id } = router.query  const { data: okr, isLoading } = trpc.okr.getById.useQuery(    { id: id as string },    { enabled: !!id }  )  if (isLoading) {    return (      <MainLayout>        <div className="animate-pulse space-y-4">          <div className="h-12 bg-muted rounded" />          <div className="h-64 bg-muted rounded" />        </div>      </MainLayout>    )  }  if (!okr) {    return (      <MainLayout>        <div className="text-center py-12">          <p className="text-muted-foreground">à¹„à¸¡à¹ˆà¸à¸š OKR</p>        </div>      </MainLayout>    )  }  return (    <MainLayout      title={okr.objectiveTitle}      description={okr.objectiveCode}      actions={        <>          <Link href={`/okrs/${id}/check-in`}>            <Button>              <MessageSquare className="h-4 w-4 mr-2" />              Check-in            </Button>          </Link>          <Button variant="outline">            <Edit className="h-4 w-4 mr-2" />            à¹à¸à¹‰à¹„à¸‚          </Button>          <Button variant="outline" size="icon">            <Share2 className="h-4 w-4" />          </Button>        </>      }    >      {/* Overview */}      <div className="grid gap-4 md:grid-cols-4">        <Card>          <CardHeader className="pb-3">            <CardTitle className="text-sm font-medium text-muted-foreground">              Progress            </CardTitle>          </CardHeader>          <CardContent>            <div className="space-y-2">              <div className="text-2xl font-bold">                {okr.progressPercentage}%              </div>              <ProgressBar value={okr.progressPercentage} />            </div>          </CardContent>        </Card>        <Card>          <CardHeader className="pb-3">            <CardTitle className="text-sm font-medium text-muted-foreground">              Status            </CardTitle>          </CardHeader>          <CardContent>            <StatusBadge status={okr.status} type="okr" />          </CardContent>        </Card>        <Card>          <CardHeader className="pb-3">            <CardTitle className="text-sm font-medium text-muted-foreground">              Confidence            </CardTitle>          </CardHeader>          <CardContent>            <div className="text-2xl font-bold">{okr.confidence}</div>          </CardContent>        </Card>        <Card>          <CardHeader className="pb-3">            <CardTitle className="text-sm font-medium text-muted-foreground">              Owner            </CardTitle>          </CardHeader>          <CardContent>            <div className="flex items-center gap-2">              <Avatar                src={okr.ownerUser?.avatar}                fallback={okr.ownerUser?.fullName}                size="sm"              />              <span className="text-sm font-medium">                {okr.ownerUser?.fullName}              </span>            </div>          </CardContent>        </Card>      </div>      {/* Tabs */}      <Tabs defaultValue="key-results" className="space-y-4">        <TabsList>          <TabsTrigger value="key-results">            Key Results ({okr.keyResults?.length || 0})          </TabsTrigger>          <TabsTrigger value="check-ins">            Check-ins ({okr.checkIns?.length || 0})          </TabsTrigger>          <TabsTrigger value="cascade">Cascade</TabsTrigger>          <TabsTrigger value="initiatives">Initiatives</TabsTrigger>        </TabsList>        {/* Key Results Tab */}        <TabsContent value="key-results" className="space-y-4">          {okr.keyResults?.map((kr) => (            <Card key={kr.id}>              <CardContent className="p-6">                <div className="space-y-4">                  <div className="flex items-start justify-between">                    <div className="flex-1">                      <h3 className="font-medium text-lg">                        {kr.keyResultTitle}                      </h3>                      <p className="text-sm text-muted-foreground mt-1">                        {kr.keyResultDescription}                      </p>                    </div>                    <StatusBadge status={kr.status} type="okr" />                  </div>                  <div className="flex items-center justify-between">                    <div className="flex items-center gap-4">                      <div>                        <p className="text-sm text-muted-foreground">Current</p>                        <p className="text-2xl font-bold">                          {kr.currentValue} {kr.measurementUnit}                        </p>                      </div>                      <TrendingUp className="h-5 w-5 text-muted-foreground" />                      <div>                        <p className="text-sm text-muted-foreground">Target</p>                        <p className="text-2xl font-bold">                          {kr.targetValue} {kr.measurementUnit}                        </p>                      </div>                    </div>                    <div className="text-right">                      <p className="text-sm text-muted-foreground">Progress</p>                      <p className="text-3xl font-bold">                        {kr.progressPercentage}%                      </p>                    </div>                  </div>                  <ProgressBar value={kr.progressPercentage} />                </div>              </CardContent>            </Card>          ))}        </TabsContent>        {/* Check-ins Tab */}        <TabsContent value="check-ins" className="space-y-4">          {okr.checkIns?.map((checkIn) => (            <Card key={checkIn.id}>              <CardHeader>                <div className="flex items-center justify-between">                  <div className="flex items-center gap-3">                    <Avatar                      src={checkIn.checkedInBy?.avatar}                      fallback={checkIn.checkedInBy?.fullName}                      size="sm"                    />                    <div>                      <p className="font-medium">                        {checkIn.checkedInBy?.fullName}                      </p>                      <p className="text-sm text-muted-foreground">                        {new Date(checkIn.checkInDate).toLocaleDateString('th-TH')}                      </p>                    </div>                  </div>                  <Badge>{checkIn.healthStatus}</Badge>                </div>              </CardHeader>              <CardContent className="space-y-3">                <div>                  <h4 className="font-medium text-sm mb-2">                    Accomplishments                  </h4>                  <p className="text-sm text-muted-foreground">                    {checkIn.accomplishments}                  </p>                </div>                {checkIn.challenges && (                  <div>                    <h4 className="font-medium text-sm mb-2">Challenges</h4>                    <p className="text-sm text-muted-foreground">                      {checkIn.challenges}                    </p>                  </div>                )}              </CardContent>            </Card>          ))}        </TabsContent>        {/* Cascade Tab */}        <TabsContent value="cascade">          {okr.childOKRs && okr.childOKRs.length > 0 ? (            <OKRCascadeTree tree={[okr as any]} />          ) : (            <Card>              <CardContent className="p-12 text-center">                <p className="text-muted-foreground">                  à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸¡à¸µ OKR à¸—à¸µà¹ˆ cascade à¸ˆà¸²à¸ objective à¸™à¸µà¹‰                </p>              </CardContent>            </Card>          )}        </TabsContent>      </Tabs>    </MainLayout>  )}```---à¸•à¹ˆà¸­à¸”à¹‰à¸§à¸¢ KPI Pages, Dashboard Pages, à¹à¸¥à¸° Form Pages à¹ƒà¸™à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸–à¸±à¸”à¹„à¸›...à¸à¸£à¹‰à¸­à¸¡à¸•à¹ˆà¸­à¹„à¸«à¸¡à¸„à¸£à¸±à¸š? ğŸ“„ğŸ¨---ğŸ¨ React UI - KPI, Dashboard & Form Pagesà¸ªà¸£à¹‰à¸²à¸‡ Complete Pages à¸à¸£à¹‰à¸­à¸¡ Form Components à¸ªà¸³à¸«à¸£à¸±à¸š Create/Edit!---ğŸ“‹ Step 1: KPI PagesKPIs List Page```typescript// pages/kpis/index.tsximport { useState } from 'react'import { MainLayout } from '@/components/layout/main-layout'import { KPICard } from '@/components/kpi/kpi-card'import { Button } from '@/components/ui/button'import { Input } from '@/components/ui/input'import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'import { trpc } from '@/lib/trpc'import { Plus, Download, Filter } from 'lucide-react'import Link from 'next/link'export default function KPIsPage() {  const [searchQuery, setSearchQuery] = useState('')  const [perspectiveFilter, setPerspectiveFilter] = useState<string>('all')  const [performanceFilter, setPerformanceFilter] = useState<string>('all')  const { data: kpis, isLoading } = trpc.kpi.list.useQuery({    page: 1,    perPage: 20,    query: searchQuery,    perspective: perspectiveFilter !== 'all' ? perspectiveFilter : undefined,  })  return (    <MainLayout      title="KPIs"      description="à¸•à¸±à¸§à¸Šà¸µà¹‰à¸§à¸±à¸”à¸œà¸¥à¸à¸²à¸£à¸”à¸³à¹€à¸™à¸´à¸™à¸‡à¸²à¸™ (Key Performance Indicators)"      actions={        <>          <Button variant="outline">            <Download className="h-4 w-4 mr-2" />            Export Report          </Button>          <Link href="/kpis/new">            <Button>              <Plus className="h-4 w-4 mr-2" />              à¸ªà¸£à¹‰à¸²à¸‡ KPI            </Button>          </Link>        </>      }    >      {/* Filters */}      <div className="flex flex-col md:flex-row gap-4">        <Input          placeholder="à¸„à¹‰à¸™à¸«à¸² KPI..."          value={searchQuery}          onChange={(e) => setSearchQuery(e.target.value)}          className="flex-1"        />        {/* BSC Perspective */}        <Select value={perspectiveFilter} onValueChange={setPerspectiveFilter}>          <SelectTrigger className="w-64">            <SelectValue placeholder="à¸¡à¸¸à¸¡à¸¡à¸­à¸‡ BSC" />          </SelectTrigger>          <SelectContent>            <SelectItem value="all">à¸—à¸¸à¸à¸¡à¸¸à¸¡à¸¡à¸­à¸‡</SelectItem>            <SelectItem value="FINANCIAL">à¸à¸²à¸£à¹€à¸‡à¸´à¸™</SelectItem>            <SelectItem value="CUSTOMER">à¸¥à¸¹à¸à¸„à¹‰à¸²</SelectItem>            <SelectItem value="INTERNAL_PROCESS">à¸à¸£à¸°à¸šà¸§à¸™à¸à¸²à¸£à¸ à¸²à¸¢à¹ƒà¸™</SelectItem>            <SelectItem value="LEARNING_GROWTH">à¸à¸²à¸£à¹€à¸£à¸µà¸¢à¸™à¸£à¸¹à¹‰à¹à¸¥à¸°à¸à¸±à¸’à¸™à¸²</SelectItem>          </SelectContent>        </Select>        {/* Performance Level */}        <Select value={performanceFilter} onValueChange={setPerformanceFilter}>          <SelectTrigger className="w-48">            <SelectValue placeholder="à¸£à¸°à¸”à¸±à¸šà¸œà¸¥à¸‡à¸²à¸™" />          </SelectTrigger>          <SelectContent>            <SelectItem value="all">à¸—à¸¸à¸à¸£à¸°à¸”à¸±à¸š</SelectItem>            <SelectItem value="excellent">à¸¢à¸­à¸”à¹€à¸¢à¸µà¹ˆà¸¢à¸¡</SelectItem>            <SelectItem value="good">à¸”à¸µ</SelectItem>            <SelectItem value="acceptable">à¸à¸­à¹ƒà¸Šà¹‰</SelectItem>            <SelectItem value="poor">à¸•à¹ˆà¸³</SelectItem>            <SelectItem value="critical">à¸§à¸´à¸à¸¤à¸•</SelectItem>          </SelectContent>        </Select>      </div>      {/* Tabs */}      <Tabs defaultValue="all" className="space-y-4">        <TabsList>          <TabsTrigger value="all">            à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸” ({kpis?.pagination.total || 0})          </TabsTrigger>          <TabsTrigger value="my">KPI à¸‚à¸­à¸‡à¸‰à¸±à¸™</TabsTrigger>          <TabsTrigger value="department">à¹à¸œà¸™à¸à¸‚à¸­à¸‡à¸‰à¸±à¸™</TabsTrigger>          <TabsTrigger value="at-risk">à¸•à¹‰à¸­à¸‡à¸£à¸°à¸§à¸±à¸‡</TabsTrigger>        </TabsList>        <TabsContent value="all" className="space-y-4">          {isLoading ? (            <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">              {Array.from({ length: 6 }).map((_, i) => (                <div key={i} className="h-64 bg-muted rounded-lg animate-pulse" />              ))}            </div>          ) : (            <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">              {kpis?.data.map((kpi) => (                <KPICard key={kpi.id} kpi={kpi} />              ))}            </div>          )}          {!isLoading && kpis?.data.length === 0 && (            <div className="text-center py-12">              <p className="text-muted-foreground">à¹„à¸¡à¹ˆà¸à¸š KPI</p>            </div>          )}        </TabsContent>      </Tabs>    </MainLayout>  )}```KPI Detail Page```typescript// pages/kpis/[id].tsximport { MainLayout } from '@/components/layout/main-layout'import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import { Button } from '@/components/ui/button'import { Badge } from '@/components/ui/badge'import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'import { StatusBadge } from '@/components/ui/status-badge'import { Avatar } from '@/components/ui/avatar'import { KPITrendChart } from '@/components/kpi/kpi-trend-chart'import { KPIBenchmark } from '@/components/kpi/kpi-benchmark'import { trpc } from '@/lib/trpc'import { useRouter } from 'next/router'import { TrendingUp, TrendingDown, Target, Edit, Download } from 'lucide-react'import Link from 'next/link'export default function KPIDetailPage() {  const router = useRouter()  const { id } = router.query  const { data: kpi, isLoading } = trpc.kpi.getById.useQuery(    { id: id as string },    { enabled: !!id }  )  if (isLoading) {    return (      <MainLayout>        <div className="animate-pulse space-y-4">          <div className="h-12 bg-muted rounded" />          <div className="h-64 bg-muted rounded" />        </div>      </MainLayout>    )  }  if (!kpi) {    return (      <MainLayout>        <div className="text-center py-12">          <p className="text-muted-foreground">à¹„à¸¡à¹ˆà¸à¸š KPI</p>        </div>      </MainLayout>    )  }  const trend = kpi.values && kpi.values.length >= 2    ? ((kpi.values[kpi.values.length - 1].actualValue - kpi.values[kpi.values.length - 2].actualValue) / kpi.values[kpi.values.length - 2].actualValue) * 100    : 0  return (    <MainLayout      title={kpi.kpiName}      description={kpi.kpiCode}      actions={        <>          <Link href={`/kpis/${id}/record`}>            <Button>              <Plus className="h-4 w-4 mr-2" />              à¸šà¸±à¸™à¸—à¸¶à¸à¸œà¸¥à¸‡à¸²à¸™            </Button>          </Link>          <Button variant="outline">            <Download className="h-4 w-4 mr-2" />            Export          </Button>          <Button variant="outline">            <Edit className="h-4 w-4 mr-2" />            à¹à¸à¹‰à¹„à¸‚          </Button>        </>      }    >      {/* Overview Cards */}      <div className="grid gap-4 md:grid-cols-4">        <Card>          <CardHeader className="pb-3">            <CardTitle className="text-sm font-medium text-muted-foreground">              à¸œà¸¥à¸‡à¸²à¸™à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™            </CardTitle>          </CardHeader>          <CardContent>            <div className="text-3xl font-bold">              {kpi.currentValue.toLocaleString()}            </div>            <p className="text-sm text-muted-foreground mt-1">              {kpi.measurementUnit}            </p>          </CardContent>        </Card>        <Card>          <CardHeader className="pb-3">            <CardTitle className="text-sm font-medium text-muted-foreground">              à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢            </CardTitle>          </CardHeader>          <CardContent>            <div className="text-3xl font-bold">              {kpi.targetValue.toLocaleString()}            </div>            <p className="text-sm text-muted-foreground mt-1">              {kpi.measurementUnit}            </p>          </CardContent>        </Card>        <Card>          <CardHeader className="pb-3">            <CardTitle className="text-sm font-medium text-muted-foreground">              Achievement Rate            </CardTitle>          </CardHeader>          <CardContent>            <div className="flex items-center gap-2">              <div className="text-3xl font-bold">                {kpi.achievementRate.toFixed(1)}%              </div>              <StatusBadge status={kpi.performanceStatus} type="kpi" />            </div>          </CardContent>        </Card>        <Card>          <CardHeader className="pb-3">            <CardTitle className="text-sm font-medium text-muted-foreground">              Trend            </CardTitle>          </CardHeader>          <CardContent>            <div className="flex items-center gap-2">              {trend > 0 ? (                <TrendingUp className="h-6 w-6 text-green-600" />              ) : trend < 0 ? (                <TrendingDown className="h-6 w-6 text-red-600" />              ) : (                <Target className="h-6 w-6 text-gray-600" />              )}              <span                className={`text-2xl font-bold ${                  trend > 0 ? 'text-green-600' : trend < 0 ? 'text-red-600' : 'text-gray-600'                }`}              >                {trend > 0 ? '+' : ''}{trend.toFixed(1)}%              </span>            </div>          </CardContent>        </Card>      </div>      {/* Details */}      <div className="grid gap-4 md:grid-cols-3">        <Card className="md:col-span-2">          <CardHeader>            <CardTitle>à¸£à¸²à¸¢à¸¥à¸°à¹€à¸­à¸µà¸¢à¸”</CardTitle>          </CardHeader>          <CardContent className="space-y-4">            <div>              <h4 className="text-sm font-medium text-muted-foreground mb-1">                à¸„à¸³à¸ˆà¸³à¸à¸±à¸”à¸„à¸§à¸²à¸¡              </h4>              <p>{kpi.kpiDefinition}</p>            </div>            <div className="grid grid-cols-2 gap-4">              <div>                <h4 className="text-sm font-medium text-muted-foreground mb-1">                  à¸ªà¸¹à¸•à¸£à¸à¸²à¸£à¸„à¸³à¸™à¸§à¸“                </h4>                <code className="text-sm bg-muted p-2 rounded block">                  {kpi.calculationFormula}                </code>              </div>              <div>                <h4 className="text-sm font-medium text-muted-foreground mb-1">                  à¹à¸«à¸¥à¹ˆà¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥                </h4>                <p className="text-sm">{kpi.dataSource}</p>              </div>            </div>          </CardContent>        </Card>        <Card>          <CardHeader>            <CardTitle>Owner</CardTitle>          </CardHeader>          <CardContent className="space-y-4">            <div className="flex items-center gap-3">              <Avatar                src={kpi.responsibleUser?.avatar}                fallback={kpi.responsibleUser?.fullName}                size="lg"              />              <div>                <p className="font-medium">{kpi.responsibleUser?.fullName}</p>                <p className="text-sm text-muted-foreground">                  {kpi.responsibleUser?.departmentName}                </p>              </div>            </div>            {kpi.bscObjective && (              <div>                <h4 className="text-sm font-medium text-muted-foreground mb-2">                  BSC Objective                </h4>                <Badge>{kpi.bscObjective.perspective}</Badge>                <p className="text-sm mt-2">{kpi.bscObjective.objectiveName}</p>              </div>            )}          </CardContent>        </Card>      </div>      {/* Tabs */}      <Tabs defaultValue="trend" className="space-y-4">        <TabsList>          <TabsTrigger value="trend">Trend Analysis</TabsTrigger>          <TabsTrigger value="records">            à¸šà¸±à¸™à¸—à¸¶à¸à¸œà¸¥à¸‡à¸²à¸™ ({kpi.values?.length || 0})          </TabsTrigger>          <TabsTrigger value="benchmark">Benchmark</TabsTrigger>          <TabsTrigger value="actions">Action Plans</TabsTrigger>        </TabsList>        {/* Trend Tab */}        <TabsContent value="trend">          <KPITrendChart            data={kpi.values || []}            kpiName={kpi.kpiName}            unit={kpi.measurementUnit}            showBaseline={true}          />        </TabsContent>        {/* Records Tab */}        <TabsContent value="records" className="space-y-3">          {kpi.values?.map((record) => (            <Card key={record.id}>              <CardContent className="p-4">                <div className="flex items-center justify-between">                  <div className="flex-1">                    <div className="flex items-center gap-4 mb-2">                      <div>                        <p className="text-sm text-muted-foreground">à¸§à¸±à¸™à¸—à¸µà¹ˆà¸šà¸±à¸™à¸—à¸¶à¸</p>                        <p className="font-medium">                          {new Date(record.periodDate).toLocaleDateString('th-TH')}                        </p>                      </div>                      <div>                        <p className="text-sm text-muted-foreground">à¸£à¸°à¸¢à¸°à¹€à¸§à¸¥à¸²</p>                        <p className="font-medium">{record.measurementPeriod}</p>                      </div>                    </div>                    {record.notes && (                      <p className="text-sm text-muted-foreground">{record.notes}</p>                    )}                  </div>                  <div className="text-right">                    <p className="text-3xl font-bold">                      {record.actualValue.toLocaleString()}                    </p>                    <p className="text-sm text-muted-foreground">                      {kpi.measurementUnit}                    </p>                    {record.variance !== undefined && (                      <Badge                        variant={record.variance >= 0 ? 'success' : 'destructive'}                        className="mt-2"                      >                        {record.variance >= 0 ? '+' : ''}                        {record.variance.toFixed(1)}                      </Badge>                    )}                  </div>                </div>              </CardContent>            </Card>          ))}        </TabsContent>        {/* Benchmark Tab */}        <TabsContent value="benchmark">          <KPIBenchmark            kpi={{              name: kpi.kpiName,              current: kpi.currentValue,              target: kpi.targetValue,              unit: kpi.measurementUnit,            }}            benchmarks={kpi.benchmarks || []}          />        </TabsContent>      </Tabs>    </MainLayout>  )}```---ğŸ“‹ Step 2: Dashboard PagesExecutive Dashboard Page```typescript// pages/dashboard/index.tsximport { MainLayout } from '@/components/layout/main-layout'import { ExecutiveDashboard } from '@/components/dashboard/executive-dashboard'import { ActivityFeed } from '@/components/dashboard/activity-feed'import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import { Button } from '@/components/ui/button'import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'import { trpc } from '@/lib/trpc'import { Download, RefreshCw, Calendar } from 'lucide-react'export default function DashboardPage() {  const { data: dashboardData, isLoading } = trpc.dashboard.getExecutiveSummary.useQuery()  const { data: activities } = trpc.activity.list.useQuery({ page: 1, perPage: 10 })  return (    <MainLayout      title="Dashboard"      description="à¸ à¸²à¸à¸£à¸§à¸¡à¸à¸²à¸£à¸”à¸³à¹€à¸™à¸´à¸™à¸‡à¸²à¸™à¸‚à¸­à¸‡à¸­à¸‡à¸„à¹Œà¸à¸£"      actions={        <>          <Button variant="outline">            <Calendar className="h-4 w-4 mr-2" />            à¹€à¸¥à¸·à¸­à¸à¸Šà¹ˆà¸§à¸‡à¹€à¸§à¸¥à¸²          </Button>          <Button variant="outline">            <Download className="h-4 w-4 mr-2" />            Export Report          </Button>          <Button variant="outline" size="icon">            <RefreshCw className="h-4 w-4" />          </Button>        </>      }    >      <Tabs defaultValue="overview" className="space-y-6">        <TabsList>          <TabsTrigger value="overview">Overview</TabsTrigger>          <TabsTrigger value="projects">Projects</TabsTrigger>          <TabsTrigger value="okrs">OKRs</TabsTrigger>          <TabsTrigger value="kpis">KPIs</TabsTrigger>          <TabsTrigger value="strategy">Strategy</TabsTrigger>        </TabsList>        <TabsContent value="overview" className="space-y-6">          {isLoading ? (            <div className="grid gap-4">              <div className="h-32 bg-muted rounded-lg animate-pulse" />              <div className="h-64 bg-muted rounded-lg animate-pulse" />            </div>          ) : dashboardData ? (            <>              <ExecutiveDashboard data={dashboardData} />                            <div className="grid gap-4 md:grid-cols-3">                {/* Activity Feed */}                <div className="md:col-span-2">                  {activities && <ActivityFeed activities={activities.data} />}                </div>                {/* Quick Actions */}                <Card>                  <CardHeader>                    <CardTitle>Quick Actions</CardTitle>                  </CardHeader>                  <CardContent className="space-y-2">                    <Button variant="outline" className="w-full justify-start">                      <Plus className="h-4 w-4 mr-2" />                      à¸ªà¸£à¹‰à¸²à¸‡à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¹ƒà¸«à¸¡à¹ˆ                    </Button>                    <Button variant="outline" className="w-full justify-start">                      <Target className="h-4 w-4 mr-2" />                      à¹€à¸à¸´à¹ˆà¸¡ OKR                    </Button>                    <Button variant="outline" className="w-full justify-start">                      <TrendingUp className="h-4 w-4 mr-2" />                      à¸šà¸±à¸™à¸—à¸¶à¸ KPI                    </Button>                    <Button variant="outline" className="w-full justify-start">                      <FileText className="h-4 w-4 mr-2" />                      à¸ªà¸£à¹‰à¸²à¸‡à¸£à¸²à¸¢à¸‡à¸²à¸™                    </Button>                  </CardContent>                </Card>              </div>            </>          ) : (            <div className="text-center py-12">              <p className="text-muted-foreground">à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¹‚à¸«à¸¥à¸”à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹„à¸”à¹‰</p>            </div>          )}        </TabsContent>        {/* Other tabs... */}      </Tabs>    </MainLayout>  )}```Portfolio Dashboard Page```typescript// pages/dashboard/portfolio.tsximport { MainLayout } from '@/components/layout/main-layout'import { PortfolioDashboard } from '@/components/dashboard/portfolio-dashboard'import { Button } from '@/components/ui/button'import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'import { trpc } from '@/lib/trpc'import { Download, Filter } from 'lucide-react'import { useState } from 'react'export default function PortfolioDashboardPage() {  const [portfolioId, setPortfolioId] = useState<string>('')  const { data: portfolios } = trpc.portfolio.list.useQuery({ page: 1, perPage: 50 })  const { data: portfolioData, isLoading } = trpc.portfolio.getDashboard.useQuery(    { portfolioId: portfolioId || portfolios?.data[0]?.id || '' },    { enabled: !!(portfolioId || portfolios?.data[0]?.id) }  )  return (    <MainLayout      title="Portfolio Dashboard"      description="à¸ à¸²à¸à¸£à¸§à¸¡ Portfolio à¸‚à¸­à¸‡à¹‚à¸„à¸£à¸‡à¸à¸²à¸£"      actions={        <>          <Select value={portfolioId} onValueChange={setPortfolioId}>            <SelectTrigger className="w-64">              <SelectValue placeholder="à¹€à¸¥à¸·à¸­à¸ Portfolio" />            </SelectTrigger>            <SelectContent>              {portfolios?.data.map((portfolio) => (                <SelectItem key={portfolio.id} value={portfolio.id}>                  {portfolio.portfolioName}                </SelectItem>              ))}            </SelectContent>          </Select>          <Button variant="outline">            <Download className="h-4 w-4 mr-2" />            Export          </Button>        </>      }    >      {isLoading ? (        <div className="grid gap-4">          {Array.from({ length: 3 }).map((_, i) => (            <div key={i} className="h-64 bg-muted rounded-lg animate-pulse" />          ))}        </div>      ) : portfolioData ? (        <PortfolioDashboard data={portfolioData} />      ) : (        <div className="text-center py-12">          <p className="text-muted-foreground">à¹€à¸¥à¸·à¸­à¸ Portfolio à¹€à¸à¸·à¹ˆà¸­à¸”à¸¹à¸‚à¹‰à¸­à¸¡à¸¹à¸¥</p>        </div>      )}    </MainLayout>  )}```BSC Dashboard Page```typescript// pages/dashboard/bsc.tsximport { MainLayout } from '@/components/layout/main-layout'import { BSCStrategyMap } from '@/components/dashboard/bsc-strategy-map'import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import { StatCard } from '@/components/ui/stat-card'import { Button } from '@/components/ui/button'import { trpc } from '@/lib/trpc'import { Download, Target, TrendingUp } from 'lucide-react'export default function BSCDashboardPage() {  const { data: bscData, isLoading } = trpc.bsc.getDashboard.useQuery()  return (    <MainLayout      title="Balanced Scorecard"      description="à¸à¸¥à¸¢à¸¸à¸—à¸˜à¹Œà¹à¸¥à¸°à¸•à¸±à¸§à¸Šà¸µà¹‰à¸§à¸±à¸”à¸­à¸‡à¸„à¹Œà¸à¸£"      actions={        <Button variant="outline">          <Download className="h-4 w-4 mr-2" />          Export Strategy Map        </Button>      }    >      {isLoading ? (        <div className="space-y-4">          <div className="grid gap-4 md:grid-cols-4">            {Array.from({ length: 4 }).map((_, i) => (              <div key={i} className="h-32 bg-muted rounded-lg animate-pulse" />            ))}          </div>          <div className="h-96 bg-muted rounded-lg animate-pulse" />        </div>      ) : bscData ? (        <>          {/* Perspective Stats */}          <div className="grid gap-4 md:grid-cols-4">            {Object.entries(bscData.perspectives).map(([key, data]: [string, any]) => (              <StatCard                key={key}                title={data.label}                value={`${data.achievement.toFixed(1)}%`}                description={`${data.objectiveCount} Objectives`}                icon={Target}                trend={{                  value: data.trend,                  isPositive: data.trend > 0,                }}              />            ))}          </div>          {/* Strategy Map */}          <BSCStrategyMap objectives={bscData.objectives} />          {/* Detailed Metrics by Perspective */}          <div className="grid gap-4 md:grid-cols-2">            {Object.entries(bscData.perspectiveDetails).map(([key, data]: [string, any]) => (              <Card key={key}>                <CardHeader>                  <CardTitle>{data.label}</CardTitle>                </CardHeader>                <CardContent>                  <div className="space-y-3">                    {data.objectives.map((obj: any) => (                      <div                        key={obj.id}                        className="flex items-center justify-between p-3 rounded-lg border"                      >                        <div className="flex-1">                          <h4 className="font-medium">{obj.name}</h4>                          <p className="text-sm text-muted-foreground">                            {obj.kpiCount} KPIs                          </p>                        </div>                        <div className="text-right">                          <p className="text-2xl font-bold">                            {obj.achievement.toFixed(1)}%                          </p>                        </div>                      </div>                    ))}                  </div>                </CardContent>              </Card>            ))}          </div>        </>      ) : (        <div className="text-center py-12">          <p className="text-muted-foreground">à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¹‚à¸«à¸¥à¸”à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹„à¸”à¹‰</p>        </div>      )}    </MainLayout>  )}```---ğŸ“‹ Step 3: Form ComponentsProject Create/Edit Form```typescript// components/forms/project-form.tsximport { useForm, Controller } from 'react-hook-form'import { zodResolver } from '@hookform/resolvers/zod'import { z } from 'zod'import { Button } from '@/components/ui/button'import { Input } from '@/components/ui/input'import { Textarea } from '@/components/ui/textarea'import { Label } from '@/components/ui/label'import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import { Calendar } from '@/components/ui/calendar'import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover'import { trpc } from '@/lib/trpc'import { Calendar as CalendarIcon } from 'lucide-react'import { format } from 'date-fns'import { cn } from '@/lib/utils'const projectSchema = z.object({  projectCode: z.string().min(1, 'à¸à¸£à¸¸à¸“à¸²à¸£à¸°à¸šà¸¸à¸£à¸«à¸±à¸ªà¹‚à¸„à¸£à¸‡à¸à¸²à¸£'),  projectName: z.string().min(3, 'à¸Šà¸·à¹ˆà¸­à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¸•à¹‰à¸­à¸‡à¸¡à¸µà¸­à¸¢à¹ˆà¸²à¸‡à¸™à¹‰à¸­à¸¢ 3 à¸•à¸±à¸§à¸­à¸±à¸à¸©à¸£'),  projectDescription: z.string().optional(),  projectType: z.string().min(1, 'à¸à¸£à¸¸à¸“à¸²à¹€à¸¥à¸·à¸­à¸à¸›à¸£à¸°à¹€à¸ à¸—à¹‚à¸„à¸£à¸‡à¸à¸²à¸£'),  priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'CRITICAL']),  startDate: z.date(),  endDate: z.date(),  budget: z.number().min(0).optional(),  fundingSource: z.string().optional(),  projectManagerId: z.string().min(1, 'à¸à¸£à¸¸à¸“à¸²à¹€à¸¥à¸·à¸­à¸à¸œà¸¹à¹‰à¸ˆà¸±à¸”à¸à¸²à¸£à¹‚à¸„à¸£à¸‡à¸à¸²à¸£'),  departmentId: z.string().optional(),  strategicObjectiveId: z.string().optional(),}).refine((data) => data.endDate > data.startDate, {  message: 'à¸§à¸±à¸™à¸—à¸µà¹ˆà¸ªà¸´à¹‰à¸™à¸ªà¸¸à¸”à¸•à¹‰à¸­à¸‡à¸¡à¸²à¸à¸à¸§à¹ˆà¸²à¸§à¸±à¸™à¸—à¸µà¹ˆà¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™',  path: ['endDate'],})type ProjectFormData = z.infer<typeof projectSchema>interface ProjectFormProps {  initialData?: Partial<ProjectFormData>  onSubmit: (data: ProjectFormData) => Promise<void>  isLoading?: boolean}export function ProjectForm({ initialData, onSubmit, isLoading }: ProjectFormProps) {  const {    register,    handleSubmit,    control,    watch,    formState: { errors },  } = useForm<ProjectFormData>({    resolver: zodResolver(projectSchema),    defaultValues: initialData || {      priority: 'MEDIUM',      startDate: new Date(),      endDate: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000),    },  })  const { data: users } = trpc.user.list.useQuery({ page: 1, perPage: 100 })  const { data: departments } = trpc.organization.listDepartments.useQuery()  const { data: objectives } = trpc.strategy.listObjectives.useQuery({ page: 1, perPage: 50 })  return (    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">      {/* Basic Information */}      <Card>        <CardHeader>          <CardTitle>à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸à¸·à¹‰à¸™à¸à¸²à¸™</CardTitle>        </CardHeader>        <CardContent className="space-y-4">          <div className="grid gap-4 md:grid-cols-2">            {/* Project Code */}            <div className="space-y-2">              <Label htmlFor="projectCode">                à¸£à¸«à¸±à¸ªà¹‚à¸„à¸£à¸‡à¸à¸²à¸£ <span className="text-red-500">*</span>              </Label>              <Input                id="projectCode"                {...register('projectCode')}                error={errors.projectCode?.message}                placeholder="PRJ-2025-001"              />            </div>            {/* Project Type */}            <div className="space-y-2">              <Label htmlFor="projectType">                à¸›à¸£à¸°à¹€à¸ à¸—à¹‚à¸„à¸£à¸‡à¸à¸²à¸£ <span className="text-red-500">*</span>              </Label>              <Controller                name="projectType"                control={control}                render={({ field }) => (                  <Select onValueChange={field.onChange} value={field.value}>                    <SelectTrigger>                      <SelectValue placeholder="à¹€à¸¥à¸·à¸­à¸à¸›à¸£à¸°à¹€à¸ à¸—" />                    </SelectTrigger>                    <SelectContent>                      <SelectItem value="STRATEGIC">à¸¢à¸¸à¸—à¸˜à¸¨à¸²à¸ªà¸•à¸£à¹Œ</SelectItem>                      <SelectItem value="OPERATIONAL">à¸›à¸à¸´à¸šà¸±à¸•à¸´à¸à¸²à¸£</SelectItem>                      <SelectItem value="INNOVATION">à¸™à¸§à¸±à¸•à¸à¸£à¸£à¸¡</SelectItem>                      <SelectItem value="COMPLIANCE">à¸›à¸à¸´à¸šà¸±à¸•à¸´à¸•à¸²à¸¡à¸à¸à¸£à¸°à¹€à¸šà¸µà¸¢à¸š</SelectItem>                    </SelectContent>                  </Select>                )}              />              {errors.projectType && (                <p className="text-sm text-red-500">{errors.projectType.message}</p>              )}            </div>          </div>          {/* Project Name */}          <div className="space-y-2">            <Label htmlFor="projectName">              à¸Šà¸·à¹ˆà¸­à¹‚à¸„à¸£à¸‡à¸à¸²à¸£ <span className="text-red-500">*</span>            </Label>            <Input              id="projectName"              {...register('projectName')}              error={errors.projectName?.message}              placeholder="à¸£à¸°à¸šà¸¸à¸Šà¸·à¹ˆà¸­à¹‚à¸„à¸£à¸‡à¸à¸²à¸£"            />          </div>          {/* Description */}          <div className="space-y-2">            <Label htmlFor="projectDescription">à¸£à¸²à¸¢à¸¥à¸°à¹€à¸­à¸µà¸¢à¸”</Label>            <Textarea              id="projectDescription"              {...register('projectDescription')}              placeholder="à¸­à¸˜à¸´à¸šà¸²à¸¢à¸§à¸±à¸•à¸–à¸¸à¸›à¸£à¸°à¸ªà¸‡à¸„à¹Œà¹à¸¥à¸°à¸‚à¸­à¸šà¹€à¸‚à¸•à¸‚à¸­à¸‡à¹‚à¸„à¸£à¸‡à¸à¸²à¸£"              rows={4}            />          </div>          {/* Priority */}          <div className="space-y-2">            <Label htmlFor="priority">à¸£à¸°à¸”à¸±à¸šà¸„à¸§à¸²à¸¡à¸ªà¸³à¸„à¸±à¸</Label>            <Controller              name="priority"              control={control}              render={({ field }) => (                <Select onValueChange={field.onChange} value={field.value}>                  <SelectTrigger>                    <SelectValue />                  </SelectTrigger>                  <SelectContent>                    <SelectItem value="LOW">à¸•à¹ˆà¸³</SelectItem>                    <SelectItem value="MEDIUM">à¸›à¸²à¸™à¸à¸¥à¸²à¸‡</SelectItem>                    <SelectItem value="HIGH">à¸ªà¸¹à¸‡</SelectItem>                    <SelectItem value="CRITICAL">à¹€à¸£à¹ˆà¸‡à¸”à¹ˆà¸§à¸™</SelectItem>                  </SelectContent>                </Select>              )}            />          </div>        </CardContent>      </Card>      {/* Timeline & Budget */}      <Card>        <CardHeader>          <CardTitle>à¸£à¸°à¸¢à¸°à¹€à¸§à¸¥à¸²à¹à¸¥à¸°à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“</CardTitle>        </CardHeader>        <CardContent className="space-y-4">          <div className="grid gap-4 md:grid-cols-2">            {/* Start Date */}            <div className="space-y-2">              <Label>                à¸§à¸±à¸™à¸—à¸µà¹ˆà¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™ <span className="text-red-500">*</span>              </Label>              <Controller                name="startDate"                control={control}                render={({ field }) => (                  <Popover>                    <PopoverTrigger asChild>                      <Button                        variant="outline"                        className={cn(                          'w-full justify-start text-left font-normal',                          !field.value && 'text-muted-foreground'                        )}                      >                        <CalendarIcon className="mr-2 h-4 w-4" />                        {field.value ? format(field.value, 'PPP') : 'à¹€à¸¥à¸·à¸­à¸à¸§à¸±à¸™à¸—à¸µà¹ˆ'}                      </Button>                    </PopoverTrigger>                    <PopoverContent className="w-auto p-0">                      <Calendar                        mode="single"                        selected={field.value}                        onSelect={field.onChange}                        initialFocus                      />                    </PopoverContent>                  </Popover>                )}              />              {errors.startDate && (                <p className="text-sm text-red-500">{errors.startDate.message}</p>              )}            </div>            {/* End Date */}            <div className="space-y-2">              <Label>                à¸§à¸±à¸™à¸—à¸µà¹ˆà¸ªà¸´à¹‰à¸™à¸ªà¸¸à¸” <span className="text-red-500">*</span>              </Label>              <Controller                name="endDate"                control={control}                render={({ field }) => (                  <Popover>                    <PopoverTrigger asChild>                      <Button                        variant="outline"                        className={cn(                          'w-full justify-start text-left font-normal',                          !field.value && 'text-muted-foreground'                        )}                      >                        <CalendarIcon className="mr-2 h-4 w-4" />                        {field.value ? format(field.value, 'PPP') : 'à¹€à¸¥à¸·à¸­à¸à¸§à¸±à¸™à¸—à¸µà¹ˆ'}                      </Button>                    </PopoverTrigger>                    <PopoverContent className="w-auto p-0">                      <Calendar                        mode="single"                        selected={field.value}                        onSelect={field.onChange}                        initialFocus                      />                    </PopoverContent>                  </Popover>                )}              />              {errors.endDate && (                <p className="text-sm text-red-500">{errors.endDate.message}</p>              )}            </div>          </div>          <div className="grid gap-4 md:grid-cols-2">            {/* Budget */}            <div className="space-y-2">              <Label htmlFor="budget">à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“ (à¸šà¸²à¸—)</Label>              <Input                id="budget"                type="number"                {...register('budget', { valueAsNumber: true })}                placeholder="0.00"              />            </div>            {/* Funding Source */}            <div className="space-y-2">              <Label htmlFor="fundingSource">à¹à¸«à¸¥à¹ˆà¸‡à¹€à¸‡à¸´à¸™à¸—à¸¸à¸™</Label>              <Input                id="fundingSource"                {...register('fundingSource')}                placeholder="à¸‡à¸šà¸›à¸£à¸°à¸¡à¸²à¸“à¹à¸œà¹ˆà¸™à¸”à¸´à¸™"              />            </div>          </div>        </CardContent>      </Card>      {/* Organization */}      <Card>        <CardHeader>          <CardTitle>à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸­à¸‡à¸„à¹Œà¸à¸£</CardTitle>        </CardHeader>        <CardContent className="space-y-4">          {/* Project Manager */}          <div className="space-y-2">            <Label htmlFor="projectManagerId">              à¸œà¸¹à¹‰à¸ˆà¸±à¸”à¸à¸²à¸£à¹‚à¸„à¸£à¸‡à¸à¸²à¸£ <span className="text-red-500">*</span>            </Label>            <Controller              name="projectManagerId"              control={control}              render={({ field }) => (                <Select onValueChange={field.onChange} value={field.value}>                  <SelectTrigger>                    <SelectValue placeholder="à¹€à¸¥à¸·à¸­à¸à¸œà¸¹à¹‰à¸ˆà¸±à¸”à¸à¸²à¸£à¹‚à¸„à¸£à¸‡à¸à¸²à¸£" />                  </SelectTrigger>                  <SelectContent>                    {users?.data.map((user) => (                      <SelectItem key={user.id} value={user.id}>                        {user.fullName} - {user.departmentName}                      </SelectItem>                    ))}                  </SelectContent>                </Select>              )}            />            {errors.projectManagerId && (              <p className="text-sm text-red-500">{errors.projectManagerId.message}</p>            )}          </div>          {/* Department */}          <div className="space-y-2">            <Label htmlFor="departmentId">à¹à¸œà¸™à¸à¸£à¸±à¸šà¸œà¸´à¸”à¸Šà¸­à¸š</Label>            <Controller              name="departmentId"              control={control}              render={({ field }) => (                <Select onValueChange={field.onChange} value={field.value}>                  <SelectTrigger>                    <SelectValue placeholder="à¹€à¸¥à¸·à¸­à¸à¹à¸œà¸™à¸" />                  </SelectTrigger>                  <SelectContent>                    {departments?.map((dept) => (                      <SelectItem key={dept.id} value={dept.id}>                        {dept.departmentName}                      </SelectItem>                    ))}                  </SelectContent>                </Select>              )}            />          </div>          {/* Strategic Objective */}          <div className="space-y-2">            <Label htmlFor="strategicObjectiveId">à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¹‚à¸¢à¸‡à¸à¸±à¸šà¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢à¹€à¸Šà¸´à¸‡à¸à¸¥à¸¢à¸¸à¸—à¸˜à¹Œ</Label>            <Controller              name="strategicObjectiveId"              control={control}              render={({ field }) => (                <Select onValueChange={field.onChange} value={field.value}>                  <SelectTrigger>                    <SelectValue placeholder="à¹€à¸¥à¸·à¸­à¸à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢à¹€à¸Šà¸´à¸‡à¸à¸¥à¸¢à¸¸à¸—à¸˜à¹Œ" />                  </SelectTrigger>                  <SelectContent>                    {objectives?.data.map((obj) => (                      <SelectItem key={obj.id} value={obj.id}>                        {obj.objectiveName}                      </SelectItem>                    ))}                  </SelectContent>                </Select>              )}            />          </div>        </CardContent>      </Card>      {/* Actions */}      <div className="flex justify-end gap-3">        <Button type="button" variant="outline">          à¸¢à¸à¹€à¸¥à¸´à¸        </Button>        <Button type="submit" isLoading={isLoading}>          {initialData ? 'à¸šà¸±à¸™à¸—à¸¶à¸à¸à¸²à¸£à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¹à¸›à¸¥à¸‡' : 'à¸ªà¸£à¹‰à¸²à¸‡à¹‚à¸„à¸£à¸‡à¸à¸²à¸£'}        </Button>      </div>    </form>  )}```---à¸•à¹ˆà¸­à¸”à¹‰à¸§à¸¢ OKR Form, KPI Form, à¹à¸¥à¸° Quick Record Forms...à¸à¸£à¹‰à¸­à¸¡à¸•à¹ˆà¸­à¹„à¸«à¸¡à¸„à¸£à¸±à¸š? ğŸ“âœ¨---ğŸ¨ React UI - OKR/KPI Forms & Real-time Updatesà¸ªà¸£à¹‰à¸²à¸‡ Form Components à¹à¸¥à¸° WebSocket Real-time Updates!---ğŸ“‹ Step 1: OKR Form ComponentOKR Create/Edit Form```typescript// components/forms/okr-form.tsximport { useForm, Controller, useFieldArray } from 'react-hook-form'import { zodResolver } from '@hookform/resolvers/zod'import { z } from 'zod'import { Button } from '@/components/ui/button'import { Input } from '@/components/ui/input'import { Textarea } from '@/components/ui/textarea'import { Label } from '@/components/ui/label'import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import { Badge } from '@/components/ui/badge'import { trpc } from '@/lib/trpc'import { Plus, Trash2, Target } from 'lucide-react'const keyResultSchema = z.object({  keyResultTitle: z.string().min(3, 'à¸Šà¸·à¹ˆà¸­ Key Result à¸•à¹‰à¸­à¸‡à¸¡à¸µà¸­à¸¢à¹ˆà¸²à¸‡à¸™à¹‰à¸­à¸¢ 3 à¸•à¸±à¸§à¸­à¸±à¸à¸©à¸£'),  keyResultDescription: z.string().optional(),  measurementType: z.enum(['QUANTITATIVE', 'QUALITATIVE', 'MILESTONE']),  measurementUnit: z.string().optional(),  baselineValue: z.number().optional(),  targetValue: z.number(),  weight: z.number().min(0).max(100),  milestoneDescription: z.string().optional(),})const okrSchema = z.object({  objectiveTitle: z.string().min(5, 'à¸Šà¸·à¹ˆà¸­ Objective à¸•à¹‰à¸­à¸‡à¸¡à¸µà¸­à¸¢à¹ˆà¸²à¸‡à¸™à¹‰à¸­à¸¢ 5 à¸•à¸±à¸§à¸­à¸±à¸à¸©à¸£'),  objectiveDescription: z.string().optional(),  objectiveCode: z.string().optional(),  okrType: z.enum(['COMPANY', 'DEPARTMENT', 'TEAM', 'INDIVIDUAL']),  priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'CRITICAL']),  cycleId: z.string().min(1, 'à¸à¸£à¸¸à¸“à¸²à¹€à¸¥à¸·à¸­à¸ OKR Cycle'),  ownerUserId: z.string().min(1, 'à¸à¸£à¸¸à¸“à¸²à¹€à¸¥à¸·à¸­à¸à¸œà¸¹à¹‰à¸£à¸±à¸šà¸œà¸´à¸”à¸Šà¸­à¸š'),  parentOKRId: z.string().optional(),  strategicObjectiveId: z.string().optional(),  keyResults: z.array(keyResultSchema).min(1, 'à¸•à¹‰à¸­à¸‡à¸¡à¸µà¸­à¸¢à¹ˆà¸²à¸‡à¸™à¹‰à¸­à¸¢ 1 Key Result').max(5, 'à¸¡à¸µ Key Result à¹„à¸”à¹‰à¸ªà¸¹à¸‡à¸ªà¸¸à¸” 5 à¸£à¸²à¸¢à¸à¸²à¸£'),}).refine((data) => {  const totalWeight = data.keyResults.reduce((sum, kr) => sum + kr.weight, 0)  return totalWeight === 100}, {  message: 'à¸™à¹‰à¸³à¸«à¸™à¸±à¸à¸£à¸§à¸¡à¸‚à¸­à¸‡ Key Results à¸•à¹‰à¸­à¸‡à¹€à¸—à¹ˆà¸²à¸à¸±à¸š 100%',  path: ['keyResults'],})type OKRFormData = z.infer<typeof okrSchema>interface OKRFormProps {  initialData?: Partial<OKRFormData>  onSubmit: (data: OKRFormData) => Promise<void>  isLoading?: boolean}export function OKRForm({ initialData, onSubmit, isLoading }: OKRFormProps) {  const {    register,    handleSubmit,    control,    watch,    formState: { errors },  } = useForm<OKRFormData>({    resolver: zodResolver(okrSchema),    defaultValues: initialData || {      okrType: 'TEAM',      priority: 'MEDIUM',      keyResults: [        {          measurementType: 'QUANTITATIVE',          weight: 100,          targetValue: 0,        },      ],    },  })  const { fields, append, remove } = useFieldArray({    control,    name: 'keyResults',  })  const { data: cycles } = trpc.okr.listCycles.useQuery({ page: 1, perPage: 10 })  const { data: users } = trpc.user.list.useQuery({ page: 1, perPage: 100 })  const { data: parentOKRs } = trpc.okr.list.useQuery({ page: 1, perPage: 50 })  const keyResults = watch('keyResults')  const totalWeight = keyResults?.reduce((sum, kr) => sum + (kr.weight || 0), 0) || 0  return (    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">      {/* Objective Information */}      <Card>        <CardHeader>          <CardTitle className="flex items-center gap-2">            <Target className="h-5 w-5" />            Objective          </CardTitle>        </CardHeader>        <CardContent className="space-y-4">          <div className="grid gap-4 md:grid-cols-2">            {/* Objective Code */}            <div className="space-y-2">              <Label htmlFor="objectiveCode">à¸£à¸«à¸±à¸ª Objective</Label>              <Input                id="objectiveCode"                {...register('objectiveCode')}                placeholder="OBJ-2025-Q1-001"              />            </div>            {/* OKR Type */}            <div className="space-y-2">              <Label htmlFor="okrType">                à¸£à¸°à¸”à¸±à¸š OKR <span className="text-red-500">*</span>              </Label>              <Controller                name="okrType"                control={control}                render={({ field }) => (                  <Select onValueChange={field.onChange} value={field.value}>                    <SelectTrigger>                      <SelectValue />                    </SelectTrigger>                    <SelectContent>                      <SelectItem value="COMPANY">à¸­à¸‡à¸„à¹Œà¸à¸£</SelectItem>                      <SelectItem value="DEPARTMENT">à¹à¸œà¸™à¸</SelectItem>                      <SelectItem value="TEAM">à¸—à¸µà¸¡</SelectItem>                      <SelectItem value="INDIVIDUAL">à¸šà¸¸à¸„à¸„à¸¥</SelectItem>                    </SelectContent>                  </Select>                )}              />            </div>          </div>          {/* Objective Title */}          <div className="space-y-2">            <Label htmlFor="objectiveTitle">              à¸Šà¸·à¹ˆà¸­ Objective <span className="text-red-500">*</span>            </Label>            <Input              id="objectiveTitle"              {...register('objectiveTitle')}              error={errors.objectiveTitle?.message}              placeholder="à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢à¸—à¸µà¹ˆà¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸šà¸£à¸£à¸¥à¸¸ (à¸„à¸§à¸£à¹€à¸›à¹‡à¸™ Qualitative à¹à¸¥à¸° Inspiring)"            />          </div>          {/* Description */}          <div className="space-y-2">            <Label htmlFor="objectiveDescription">à¸£à¸²à¸¢à¸¥à¸°à¹€à¸­à¸µà¸¢à¸”</Label>            <Textarea              id="objectiveDescription"              {...register('objectiveDescription')}              placeholder="à¸­à¸˜à¸´à¸šà¸²à¸¢à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢à¹à¸¥à¸°à¹€à¸«à¸•à¸¸à¸œà¸¥à¸—à¸µà¹ˆà¸ªà¸³à¸„à¸±à¸"              rows={3}            />          </div>          <div className="grid gap-4 md:grid-cols-3">            {/* Cycle */}            <div className="space-y-2">              <Label htmlFor="cycleId">                OKR Cycle <span className="text-red-500">*</span>              </Label>              <Controller                name="cycleId"                control={control}                render={({ field }) => (                  <Select onValueChange={field.onChange} value={field.value}>                    <SelectTrigger>                      <SelectValue placeholder="à¹€à¸¥à¸·à¸­à¸ Cycle" />                    </SelectTrigger>                    <SelectContent>                      {cycles?.data.map((cycle) => (                        <SelectItem key={cycle.id} value={cycle.id}>                          {cycle.cycleName} ({cycle.fiscalYear})                        </SelectItem>                      ))}                    </SelectContent>                  </Select>                )}              />              {errors.cycleId && (                <p className="text-sm text-red-500">{errors.cycleId.message}</p>              )}            </div>            {/* Owner */}            <div className="space-y-2">              <Label htmlFor="ownerUserId">                à¸œà¸¹à¹‰à¸£à¸±à¸šà¸œà¸´à¸”à¸Šà¸­à¸š <span className="text-red-500">*</span>              </Label>              <Controller                name="ownerUserId"                control={control}                render={({ field }) => (                  <Select onValueChange={field.onChange} value={field.value}>                    <SelectTrigger>                      <SelectValue placeholder="à¹€à¸¥à¸·à¸­à¸à¸œà¸¹à¹‰à¸£à¸±à¸šà¸œà¸´à¸”à¸Šà¸­à¸š" />                    </SelectTrigger>                    <SelectContent>                      {users?.data.map((user) => (                        <SelectItem key={user.id} value={user.id}>                          {user.fullName}                        </SelectItem>                      ))}                    </SelectContent>                  </Select>                )}              />              {errors.ownerUserId && (                <p className="text-sm text-red-500">{errors.ownerUserId.message}</p>              )}            </div>            {/* Priority */}            <div className="space-y-2">              <Label htmlFor="priority">à¸„à¸§à¸²à¸¡à¸ªà¸³à¸„à¸±à¸</Label>              <Controller                name="priority"                control={control}                render={({ field }) => (                  <Select onValueChange={field.onChange} value={field.value}>                    <SelectTrigger>                      <SelectValue />                    </SelectTrigger>                    <SelectContent>                      <SelectItem value="LOW">à¸•à¹ˆà¸³</SelectItem>                      <SelectItem value="MEDIUM">à¸›à¸²à¸™à¸à¸¥à¸²à¸‡</SelectItem>                      <SelectItem value="HIGH">à¸ªà¸¹à¸‡</SelectItem>                      <SelectItem value="CRITICAL">à¹€à¸£à¹ˆà¸‡à¸”à¹ˆà¸§à¸™</SelectItem>                    </SelectContent>                  </Select>                )}              />            </div>          </div>          {/* Parent OKR (Cascading) */}          <div className="space-y-2">            <Label htmlFor="parentOKRId">Cascade à¸ˆà¸²à¸ OKR (à¸–à¹‰à¸²à¸¡à¸µ)</Label>            <Controller              name="parentOKRId"              control={control}              render={({ field }) => (                <Select onValueChange={field.onChange} value={field.value}>                  <SelectTrigger>                    <SelectValue placeholder="à¹„à¸¡à¹ˆà¸¡à¸µ (Top-level OKR)" />                  </SelectTrigger>                  <SelectContent>                    <SelectItem value="">à¹„à¸¡à¹ˆà¸¡à¸µ</SelectItem>                    {parentOKRs?.data.map((okr) => (                      <SelectItem key={okr.id} value={okr.id}>                        {okr.objectiveCode} - {okr.objectiveTitle}                      </SelectItem>                    ))}                  </SelectContent>                </Select>              )}            />          </div>        </CardContent>      </Card>      {/* Key Results */}      <Card>        <CardHeader>          <div className="flex items-center justify-between">            <CardTitle>Key Results</CardTitle>            <div className="flex items-center gap-2">              <span className="text-sm text-muted-foreground">                à¸™à¹‰à¸³à¸«à¸™à¸±à¸à¸£à¸§à¸¡:              </span>              <Badge variant={totalWeight === 100 ? 'success' : 'destructive'}>                {totalWeight}%              </Badge>            </div>          </div>        </CardHeader>        <CardContent className="space-y-4">          {fields.map((field, index) => (            <Card key={field.id} className="border-2">              <CardContent className="p-4 space-y-4">                <div className="flex items-center justify-between">                  <h4 className="font-medium">Key Result #{index + 1}</h4>                  {fields.length > 1 && (                    <Button                      type="button"                      variant="ghost"                      size="sm"                      onClick={() => remove(index)}                    >                      <Trash2 className="h-4 w-4 text-red-500" />                    </Button>                  )}                </div>                {/* KR Title */}                <div className="space-y-2">                  <Label>                    à¸Šà¸·à¹ˆà¸­ Key Result <span className="text-red-500">*</span>                  </Label>                  <Input                    {...register(`keyResults.${index}.keyResultTitle`)}                    error={errors.keyResults?.[index]?.keyResultTitle?.message}                    placeholder="à¸œà¸¥à¸¥à¸±à¸à¸˜à¹Œà¸—à¸µà¹ˆà¸§à¸±à¸”à¹„à¸”à¹‰ (Measurable)"                  />                </div>                {/* Description */}                <div className="space-y-2">                  <Label>à¸£à¸²à¸¢à¸¥à¸°à¹€à¸­à¸µà¸¢à¸”</Label>                  <Textarea                    {...register(`keyResults.${index}.keyResultDescription`)}                    placeholder="à¸­à¸˜à¸´à¸šà¸²à¸¢à¸§à¸´à¸˜à¸µà¸à¸²à¸£à¸§à¸±à¸”à¸œà¸¥"                    rows={2}                  />                </div>                <div className="grid gap-4 md:grid-cols-4">                  {/* Measurement Type */}                  <div className="space-y-2">                    <Label>à¸›à¸£à¸°à¹€à¸ à¸—</Label>                    <Controller                      name={`keyResults.${index}.measurementType`}                      control={control}                      render={({ field }) => (                        <Select onValueChange={field.onChange} value={field.value}>                          <SelectTrigger>                            <SelectValue />                          </SelectTrigger>                          <SelectContent>                            <SelectItem value="QUANTITATIVE">à¸•à¸±à¸§à¹€à¸¥à¸‚</SelectItem>                            <SelectItem value="QUALITATIVE">à¸„à¸¸à¸“à¸ à¸²à¸</SelectItem>                            <SelectItem value="MILESTONE">Milestone</SelectItem>                          </SelectContent>                        </Select>                      )}                    />                  </div>                  {/* Baseline */}                  <div className="space-y-2">                    <Label>Baseline</Label>                    <Input                      type="number"                      {...register(`keyResults.${index}.baselineValue`, {                        valueAsNumber: true,                      })}                      placeholder="0"                    />                  </div>                  {/* Target */}                  <div className="space-y-2">                    <Label>                      Target <span className="text-red-500">*</span>                    </Label>                    <Input                      type="number"                      {...register(`keyResults.${index}.targetValue`, {                        valueAsNumber: true,                      })}                      error={errors.keyResults?.[index]?.targetValue?.message}                      placeholder="100"                    />                  </div>                  {/* Weight */}                  <div className="space-y-2">                    <Label>                      à¸™à¹‰à¸³à¸«à¸™à¸±à¸ (%) <span className="text-red-500">*</span>                    </Label>                    <Input                      type="number"                      {...register(`keyResults.${index}.weight`, {                        valueAsNumber: true,                      })}                      error={errors.keyResults?.[index]?.weight?.message}                      placeholder="25"                      min="0"                      max="100"                    />                  </div>                </div>                {/* Unit */}                <div className="space-y-2">                  <Label>à¸«à¸™à¹ˆà¸§à¸¢à¸§à¸±à¸”</Label>                  <Input                    {...register(`keyResults.${index}.measurementUnit`)}                    placeholder="%, à¸£à¸²à¸¢, à¸„à¸£à¸±à¹‰à¸‡, à¸„à¸™"                  />                </div>              </CardContent>            </Card>          ))}          {/* Add KR Button */}          {fields.length < 5 && (            <Button              type="button"              variant="outline"              onClick={() =>                append({                  keyResultTitle: '',                  measurementType: 'QUANTITATIVE',                  targetValue: 0,                  weight: 0,                })              }              className="w-full"            >              <Plus className="h-4 w-4 mr-2" />              à¹€à¸à¸´à¹ˆà¸¡ Key Result            </Button>          )}          {errors.keyResults && (            <p className="text-sm text-red-500">{errors.keyResults.message}</p>          )}        </CardContent>      </Card>      {/* Actions */}      <div className="flex justify-end gap-3">        <Button type="button" variant="outline">          à¸¢à¸à¹€à¸¥à¸´à¸        </Button>        <Button type="submit" isLoading={isLoading}>          {initialData ? 'à¸šà¸±à¸™à¸—à¸¶à¸à¸à¸²à¸£à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¹à¸›à¸¥à¸‡' : 'à¸ªà¸£à¹‰à¸²à¸‡ OKR'}        </Button>      </div>    </form>  )}```---ğŸ“‹ Step 2: KPI Form ComponentKPI Create/Edit Form```typescript// components/forms/kpi-form.tsximport { useForm, Controller } from 'react-hook-form'import { zodResolver } from '@hookform/resolvers/zod'import { z } from 'zod'import { Button } from '@/components/ui/button'import { Input } from '@/components/ui/input'import { Textarea } from '@/components/ui/textarea'import { Label } from '@/components/ui/label'import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import { Switch } from '@/components/ui/switch'import { trpc } from '@/lib/trpc'import { TrendingUp } from 'lucide-react'const kpiSchema = z.object({  kpiCode: z.string().min(1, 'à¸à¸£à¸¸à¸“à¸²à¸£à¸°à¸šà¸¸à¸£à¸«à¸±à¸ª KPI'),  kpiName: z.string().min(3, 'à¸Šà¸·à¹ˆà¸­ KPI à¸•à¹‰à¸­à¸‡à¸¡à¸µà¸­à¸¢à¹ˆà¸²à¸‡à¸™à¹‰à¸­à¸¢ 3 à¸•à¸±à¸§à¸­à¸±à¸à¸©à¸£'),  kpiDefinition: z.string().min(10, 'à¸„à¸³à¸ˆà¸³à¸à¸±à¸”à¸„à¸§à¸²à¸¡à¸•à¹‰à¸­à¸‡à¸¡à¸µà¸­à¸¢à¹ˆà¸²à¸‡à¸™à¹‰à¸­à¸¢ 10 à¸•à¸±à¸§à¸­à¸±à¸à¸©à¸£'),  kpiType: z.enum(['LEAD', 'LAG', 'INPUT', 'OUTPUT', 'OUTCOME']),  kpiCategory: z.enum(['EFFICIENCY', 'EFFECTIVENESS', 'QUALITY', 'CAPACITY', 'COMPLIANCE']),  measurementUnit: z.string().min(1, 'à¸à¸£à¸¸à¸“à¸²à¸£à¸°à¸šà¸¸à¸«à¸™à¹ˆà¸§à¸¢à¸§à¸±à¸”'),  measurementFrequency: z.enum(['DAILY', 'WEEKLY', 'MONTHLY', 'QUARTERLY', 'ANNUALLY']),  calculationFormula: z.string(),  dataSource: z.string(),  baselineValue: z.number().optional(),  targetValue: z.number(),  polarity: z.enum(['POSITIVE', 'NEGATIVE']),  responsibleUserId: z.string().min(1, 'à¸à¸£à¸¸à¸“à¸²à¹€à¸¥à¸·à¸­à¸à¸œà¸¹à¹‰à¸£à¸±à¸šà¸œà¸´à¸”à¸Šà¸­à¸š'),  bscObjectiveId: z.string().optional(),  strategicObjectiveId: z.string().optional(),  weight: z.number().min(0).max(100).optional(),  isActive: z.boolean().default(true),  automatedDataCollection: z.boolean().default(false),  dataCollectionMethod: z.string().optional(),})type KPIFormData = z.infer<typeof kpiSchema>interface KPIFormProps {  initialData?: Partial<KPIFormData>  onSubmit: (data: KPIFormData) => Promise<void>  isLoading?: boolean}export function KPIForm({ initialData, onSubmit, isLoading }: KPIFormProps) {  const {    register,    handleSubmit,    control,    watch,    formState: { errors },  } = useForm<KPIFormData>({    resolver: zodResolver(kpiSchema),    defaultValues: initialData || {      kpiType: 'LAG',      kpiCategory: 'EFFECTIVENESS',      measurementFrequency: 'MONTHLY',      polarity: 'POSITIVE',      isActive: true,      automatedDataCollection: false,    },  })  const { data: users } = trpc.user.list.useQuery({ page: 1, perPage: 100 })  const { data: bscObjectives } = trpc.bsc.listObjectives.useQuery({ page: 1, perPage: 50 })  const polarity = watch('polarity')  const automatedCollection = watch('automatedDataCollection')  return (    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">      {/* Basic Information */}      <Card>        <CardHeader>          <CardTitle className="flex items-center gap-2">            <TrendingUp className="h-5 w-5" />            à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸à¸·à¹‰à¸™à¸à¸²à¸™ KPI          </CardTitle>        </CardHeader>        <CardContent className="space-y-4">          <div className="grid gap-4 md:grid-cols-2">            {/* KPI Code */}            <div className="space-y-2">              <Label htmlFor="kpiCode">                à¸£à¸«à¸±à¸ª KPI <span className="text-red-500">*</span>              </Label>              <Input                id="kpiCode"                {...register('kpiCode')}                error={errors.kpiCode?.message}                placeholder="KPI-FIN-001"              />            </div>            {/* KPI Type */}            <div className="space-y-2">              <Label htmlFor="kpiType">                à¸›à¸£à¸°à¹€à¸ à¸— KPI <span className="text-red-500">*</span>              </Label>              <Controller                name="kpiType"                control={control}                render={({ field }) => (                  <Select onValueChange={field.onChange} value={field.value}>                    <SelectTrigger>                      <SelectValue />                    </SelectTrigger>                    <SelectContent>                      <SelectItem value="LEAD">Lead (à¸™à¸³à¸«à¸™à¹‰à¸²)</SelectItem>                      <SelectItem value="LAG">Lag (à¸•à¸²à¸¡à¸«à¸¥à¸±à¸‡)</SelectItem>                      <SelectItem value="INPUT">Input (à¸›à¸±à¸ˆà¸ˆà¸±à¸¢à¸™à¸³à¹€à¸‚à¹‰à¸²)</SelectItem>                      <SelectItem value="OUTPUT">Output (à¸œà¸¥à¸œà¸¥à¸´à¸•)</SelectItem>                      <SelectItem value="OUTCOME">Outcome (à¸œà¸¥à¸¥à¸±à¸à¸˜à¹Œ)</SelectItem>                    </SelectContent>                  </Select>                )}              />            </div>          </div>          {/* KPI Name */}          <div className="space-y-2">            <Label htmlFor="kpiName">              à¸Šà¸·à¹ˆà¸­ KPI <span className="text-red-500">*</span>            </Label>            <Input              id="kpiName"              {...register('kpiName')}              error={errors.kpiName?.message}              placeholder="à¸­à¸±à¸•à¸£à¸²à¸„à¸§à¸²à¸¡à¸à¸¶à¸‡à¸à¸­à¹ƒà¸ˆà¸‚à¸­à¸‡à¸¥à¸¹à¸à¸„à¹‰à¸²"            />          </div>          {/* Definition */}          <div className="space-y-2">            <Label htmlFor="kpiDefinition">              à¸„à¸³à¸ˆà¸³à¸à¸±à¸”à¸„à¸§à¸²à¸¡ <span className="text-red-500">*</span>            </Label>            <Textarea              id="kpiDefinition"              {...register('kpiDefinition')}              error={errors.kpiDefinition?.message}              placeholder="à¸­à¸˜à¸´à¸šà¸²à¸¢à¸„à¸§à¸²à¸¡à¸«à¸¡à¸²à¸¢à¹à¸¥à¸°à¸‚à¸­à¸šà¹€à¸‚à¸•à¸‚à¸­à¸‡ KPI"              rows={3}            />          </div>          <div className="grid gap-4 md:grid-cols-2">            {/* Category */}            <div className="space-y-2">              <Label htmlFor="kpiCategory">à¸«à¸¡à¸§à¸”à¸«à¸¡à¸¹à¹ˆ</Label>              <Controller                name="kpiCategory"                control={control}                render={({ field }) => (                  <Select onValueChange={field.onChange} value={field.value}>                    <SelectTrigger>                      <SelectValue />                    </SelectTrigger>                    <SelectContent>                      <SelectItem value="EFFICIENCY">à¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸ à¸²à¸</SelectItem>                      <SelectItem value="EFFECTIVENESS">à¸›à¸£à¸°à¸ªà¸´à¸—à¸˜à¸´à¸œà¸¥</SelectItem>                      <SelectItem value="QUALITY">à¸„à¸¸à¸“à¸ à¸²à¸</SelectItem>                      <SelectItem value="CAPACITY">à¸‚à¸µà¸”à¸„à¸§à¸²à¸¡à¸ªà¸²à¸¡à¸²à¸£à¸–</SelectItem>                      <SelectItem value="COMPLIANCE">à¸à¸²à¸£à¸›à¸à¸´à¸šà¸±à¸•à¸´à¸•à¸²à¸¡</SelectItem>                    </SelectContent>                  </Select>                )}              />            </div>            {/* Frequency */}            <div className="space-y-2">              <Label htmlFor="measurementFrequency">                à¸„à¸§à¸²à¸¡à¸–à¸µà¹ˆà¹ƒà¸™à¸à¸²à¸£à¸§à¸±à¸” <span className="text-red-500">*</span>              </Label>              <Controller                name="measurementFrequency"                control={control}                render={({ field }) => (                  <Select onValueChange={field.onChange} value={field.value}>                    <SelectTrigger>                      <SelectValue />                    </SelectTrigger>                    <SelectContent>                      <SelectItem value="DAILY">à¸£à¸²à¸¢à¸§à¸±à¸™</SelectItem>                      <SelectItem value="WEEKLY">à¸£à¸²à¸¢à¸ªà¸±à¸›à¸”à¸²à¸«à¹Œ</SelectItem>                      <SelectItem value="MONTHLY">à¸£à¸²à¸¢à¹€à¸”à¸·à¸­à¸™</SelectItem>                      <SelectItem value="QUARTERLY">à¸£à¸²à¸¢à¹„à¸•à¸£à¸¡à¸²à¸ª</SelectItem>                      <SelectItem value="ANNUALLY">à¸£à¸²à¸¢à¸›à¸µ</SelectItem>                    </SelectContent>                  </Select>                )}              />            </div>          </div>        </CardContent>      </Card>      {/* Measurement Details */}      <Card>        <CardHeader>          <CardTitle>à¸£à¸²à¸¢à¸¥à¸°à¹€à¸­à¸µà¸¢à¸”à¸à¸²à¸£à¸§à¸±à¸”</CardTitle>        </CardHeader>        <CardContent className="space-y-4">          {/* Calculation Formula */}          <div className="space-y-2">            <Label htmlFor="calculationFormula">              à¸ªà¸¹à¸•à¸£à¸à¸²à¸£à¸„à¸³à¸™à¸§à¸“ <span className="text-red-500">*</span>            </Label>            <Textarea              id="calculationFormula"              {...register('calculationFormula')}              error={errors.calculationFormula?.message}              placeholder="(à¸ˆà¸³à¸™à¸§à¸™à¸¥à¸¹à¸à¸„à¹‰à¸²à¸à¸¶à¸‡à¸à¸­à¹ƒà¸ˆ / à¸ˆà¸³à¸™à¸§à¸™à¸¥à¸¹à¸à¸„à¹‰à¸²à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”) Ã— 100"              rows={2}            />          </div>          {/* Data Source */}          <div className="space-y-2">            <Label htmlFor="dataSource">              à¹à¸«à¸¥à¹ˆà¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ <span className="text-red-500">*</span>            </Label>            <Input              id="dataSource"              {...register('dataSource')}              error={errors.dataSource?.message}              placeholder="à¸£à¸°à¸šà¸š CRM, à¹à¸šà¸šà¸ªà¸³à¸£à¸§à¸ˆà¸„à¸§à¸²à¸¡à¸à¸¶à¸‡à¸à¸­à¹ƒà¸ˆ"            />          </div>          <div className="grid gap-4 md:grid-cols-3">            {/* Baseline */}            <div className="space-y-2">              <Label htmlFor="baselineValue">Baseline</Label>              <Input                id="baselineValue"                type="number"                step="0.01"                {...register('baselineValue', { valueAsNumber: true })}                placeholder="0"              />            </div>            {/* Target */}            <div className="space-y-2">              <Label htmlFor="targetValue">                Target <span className="text-red-500">*</span>              </Label>              <Input                id="targetValue"                type="number"                step="0.01"                {...register('targetValue', { valueAsNumber: true })}                error={errors.targetValue?.message}                placeholder="100"              />            </div>            {/* Unit */}            <div className="space-y-2">              <Label htmlFor="measurementUnit">                à¸«à¸™à¹ˆà¸§à¸¢à¸§à¸±à¸” <span className="text-red-500">*</span>              </Label>              <Input                id="measurementUnit"                {...register('measurementUnit')}                error={errors.measurementUnit?.message}                placeholder="%, à¸£à¸²à¸¢, à¸„à¸£à¸±à¹‰à¸‡"              />            </div>          </div>          {/* Polarity */}          <div className="space-y-2">            <Label htmlFor="polarity">Polarity (à¸—à¸´à¸¨à¸—à¸²à¸‡à¸—à¸µà¹ˆà¸”à¸µ)</Label>            <Controller              name="polarity"              control={control}              render={({ field }) => (                <Select onValueChange={field.onChange} value={field.value}>                  <SelectTrigger>                    <SelectValue />                  </SelectTrigger>                  <SelectContent>                    <SelectItem value="POSITIVE">                      Positive (à¸¢à¸´à¹ˆà¸‡à¸¡à¸²à¸à¸¢à¸´à¹ˆà¸‡à¸”à¸µ) â†‘                    </SelectItem>                    <SelectItem value="NEGATIVE">                      Negative (à¸¢à¸´à¹ˆà¸‡à¸™à¹‰à¸­à¸¢à¸¢à¸´à¹ˆà¸‡à¸”à¸µ) â†“                    </SelectItem>                  </SelectContent>                </Select>              )}            />            <p className="text-xs text-muted-foreground">              {polarity === 'POSITIVE'                ? 'à¸•à¸±à¸§à¸­à¸¢à¹ˆà¸²à¸‡: à¸£à¸²à¸¢à¹„à¸”à¹‰, à¸„à¸§à¸²à¸¡à¸à¸¶à¸‡à¸à¸­à¹ƒà¸ˆ'                : 'à¸•à¸±à¸§à¸­à¸¢à¹ˆà¸²à¸‡: à¸•à¹‰à¸™à¸—à¸¸à¸™, à¸‚à¹‰à¸­à¸£à¹‰à¸­à¸‡à¹€à¸£à¸µà¸¢à¸™'}            </p>          </div>          {/* Automated Collection */}          <div className="flex items-center justify-between p-4 border rounded-lg">            <div className="space-y-0.5">              <Label>à¹€à¸à¹‡à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´</Label>              <p className="text-sm text-muted-foreground">                à¸£à¸§à¸šà¸£à¸§à¸¡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸ˆà¸²à¸à¸£à¸°à¸šà¸šà¸­à¸·à¹ˆà¸™à¹‚à¸”à¸¢à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´              </p>            </div>            <Controller              name="automatedDataCollection"              control={control}              render={({ field }) => (                <Switch checked={field.value} onCheckedChange={field.onChange} />              )}            />          </div>          {automatedCollection && (            <div className="space-y-2">              <Label htmlFor="dataCollectionMethod">à¸§à¸´à¸˜à¸µà¸à¸²à¸£à¹€à¸à¹‡à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥</Label>              <Textarea                id="dataCollectionMethod"                {...register('dataCollectionMethod')}                placeholder="API Endpoint, Database Query, à¸«à¸£à¸·à¸­à¸§à¸´à¸˜à¸µà¸­à¸·à¹ˆà¸™à¹†"                rows={2}              />            </div>          )}        </CardContent>      </Card>      {/* Organization */}      <Card>        <CardHeader>          <CardTitle>à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸­à¸‡à¸„à¹Œà¸à¸£</CardTitle>        </CardHeader>        <CardContent className="space-y-4">          {/* Responsible User */}          <div className="space-y-2">            <Label htmlFor="responsibleUserId">              à¸œà¸¹à¹‰à¸£à¸±à¸šà¸œà¸´à¸”à¸Šà¸­à¸š <span className="text-red-500">*</span>            </Label>            <Controller              name="responsibleUserId"              control={control}              render={({ field }) => (                <Select onValueChange={field.onChange} value={field.value}>                  <SelectTrigger>                    <SelectValue placeholder="à¹€à¸¥à¸·à¸­à¸à¸œà¸¹à¹‰à¸£à¸±à¸šà¸œà¸´à¸”à¸Šà¸­à¸š" />                  </SelectTrigger>                  <SelectContent>                    {users?.data.map((user) => (                      <SelectItem key={user.id} value={user.id}>                        {user.fullName} - {user.departmentName}                      </SelectItem>                    ))}                  </SelectContent>                </Select>              )}            />            {errors.responsibleUserId && (              <p className="text-sm text-red-500">{errors.responsibleUserId.message}</p>            )}          </div>          {/* BSC Objective */}          <div className="space-y-2">            <Label htmlFor="bscObjectiveId">à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¹‚à¸¢à¸‡à¸à¸±à¸š BSC Objective</Label>            <Controller              name="bscObjectiveId"              control={control}              render={({ field }) => (                <Select onValueChange={field.onChange} value={field.value}>                  <SelectTrigger>                    <SelectValue placeholder="à¹€à¸¥à¸·à¸­à¸ BSC Objective" />                  </SelectTrigger>                  <SelectContent>                    {bscObjectives?.data.map((obj) => (                      <SelectItem key={obj.id} value={obj.id}>                        [{obj.perspective}] {obj.objectiveName}                      </SelectItem>                    ))}                  </SelectContent>                </Select>              )}            />          </div>          {/* Weight */}          <div className="space-y-2">            <Label htmlFor="weight">à¸™à¹‰à¸³à¸«à¸™à¸±à¸ (%)</Label>            <Input              id="weight"              type="number"              {...register('weight', { valueAsNumber: true })}              placeholder="0-100"              min="0"              max="100"            />            <p className="text-xs text-muted-foreground">              à¸™à¹‰à¸³à¸«à¸™à¸±à¸à¸‚à¸­à¸‡ KPI à¸™à¸µà¹‰à¹ƒà¸™à¸à¸²à¸£à¸›à¸£à¸°à¹€à¸¡à¸´à¸™à¸œà¸¥            </p>          </div>          {/* Active Status */}          <div className="flex items-center justify-between p-4 border rounded-lg">            <div className="space-y-0.5">              <Label>à¸ªà¸–à¸²à¸™à¸°à¹ƒà¸Šà¹‰à¸‡à¸²à¸™</Label>              <p className="text-sm text-muted-foreground">                à¹€à¸›à¸´à¸”à¹ƒà¸Šà¹‰à¸‡à¸²à¸™ KPI à¸™à¸µà¹‰              </p>            </div>            <Controller              name="isActive"              control={control}              render={({ field }) => (                <Switch checked={field.value} onCheckedChange={field.onChange} />              )}            />          </div>        </CardContent>      </Card>      {/* Actions */}      <div className="flex justify-end gap-3">        <Button type="button" variant="outline">          à¸¢à¸à¹€à¸¥à¸´à¸        </Button>        <Button type="submit" isLoading={isLoading}>          {initialData ? 'à¸šà¸±à¸™à¸—à¸¶à¸à¸à¸²à¸£à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¹à¸›à¸¥à¸‡' : 'à¸ªà¸£à¹‰à¸²à¸‡ KPI'}        </Button>      </div>    </form>  )}```---ğŸ“‹ Step 3: Quick Record FormsKPI Quick Record Modal```typescript// components/forms/kpi-record-modal.tsximport { useState } from 'react'import { useForm } from 'react-hook-form'import { zodResolver } from '@hookform/resolvers/zod'import { z } from 'zod'import {  Dialog,  DialogContent,  DialogHeader,  DialogTitle,  DialogFooter,} from '@/components/ui/dialog'import { Button } from '@/components/ui/button'import { Input } from '@/components/ui/input'import { Textarea } from '@/components/ui/textarea'import { Label } from '@/components/ui/label'import { Calendar } from '@/components/ui/calendar'import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover'import { Calendar as CalendarIcon, TrendingUp, TrendingDown } from 'lucide-react'import { format } from 'date-fns'import { cn } from '@/lib/utils'const recordSchema = z.object({  periodDate: z.date(),  measurementPeriod: z.string().optional(),  actualValue: z.number(),  notes: z.string().optional(),  dataQuality: z.enum(['EXCELLENT', 'GOOD', 'FAIR', 'POOR']).optional(),})type RecordFormData = z.infer<typeof recordSchema>interface KPIRecordModalProps {  isOpen: boolean  onClose: () => void  kpi: {    id: string    kpiName: string    currentValue: number    targetValue: number    measurementUnit: string    polarity: 'POSITIVE' | 'NEGATIVE'  }  onSubmit: (data: RecordFormData) => Promise<void>}export function KPIRecordModal({ isOpen, onClose, kpi, onSubmit }: KPIRecordModalProps) {  const [isLoading, setIsLoading] = useState(false)  const {    register,    handleSubmit,    watch,    setValue,    formState: { errors },  } = useForm<RecordFormData>({    resolver: zodResolver(recordSchema),    defaultValues: {      periodDate: new Date(),      actualValue: kpi.currentValue,      dataQuality: 'GOOD',    },  })  const actualValue = watch('actualValue')  const variance = actualValue - kpi.targetValue  const variancePercent = ((variance / kpi.targetValue) * 100).toFixed(1)  const isPositiveGood = kpi.polarity === 'POSITIVE'  const isGood = isPositiveGood ? variance >= 0 : variance <= 0  const handleFormSubmit = async (data: RecordFormData) => {    setIsLoading(true)    try {      await onSubmit(data)      onClose()    } finally {      setIsLoading(false)    }  }  return (    <Dialog open={isOpen} onOpenChange={onClose}>      <DialogContent className="max-w-2xl">        <DialogHeader>          <DialogTitle>à¸šà¸±à¸™à¸—à¸¶à¸à¸œà¸¥à¸‡à¸²à¸™ KPI</DialogTitle>          <p className="text-sm text-muted-foreground">{kpi.kpiName}</p>        </DialogHeader>        <form onSubmit={handleSubmit(handleFormSubmit)} className="space-y-4">          {/* Period Date */}          <div className="space-y-2">            <Label>à¸§à¸±à¸™à¸—à¸µà¹ˆà¸šà¸±à¸™à¸—à¸¶à¸</Label>            <Popover>              <PopoverTrigger asChild>                <Button                  variant="outline"                  className={cn(                    'w-full justify-start text-left font-normal',                    !watch('periodDate') && 'text-muted-foreground'                  )}                >                  <CalendarIcon className="mr-2 h-4 w-4" />                  {watch('periodDate') ? format(watch('periodDate'), 'PPP') : 'à¹€à¸¥à¸·à¸­à¸à¸§à¸±à¸™à¸—à¸µà¹ˆ'}                </Button>              </PopoverTrigger>              <PopoverContent className="w-auto p-0">                <Calendar                  mode="single"                  selected={watch('periodDate')}                  onSelect={(date) => setValue('periodDate', date || new Date())}                  initialFocus                />              </PopoverContent>            </Popover>          </div>          {/* Measurement Period */}          <div className="space-y-2">            <Label htmlFor="measurementPeriod">à¸£à¸°à¸¢à¸°à¹€à¸§à¸¥à¸²à¸—à¸µà¹ˆà¸§à¸±à¸”</Label>            <Input              id="measurementPeriod"              {...register('measurementPeriod')}              placeholder="à¹€à¸Šà¹ˆà¸™ Q1 2025, à¸¡à¸à¸£à¸²à¸„à¸¡ 2025"            />          </div>          {/* Actual Value */}          <div className="space-y-2">            <Label htmlFor="actualValue">              à¸„à¹ˆà¸²à¸—à¸µà¹ˆà¸§à¸±à¸”à¹„à¸”à¹‰ ({kpi.measurementUnit}) <span className="text-red-500">*</span>            </Label>            <Input              id="actualValue"              type="number"              step="0.01"              {...register('actualValue', { valueAsNumber: true })}              error={errors.actualValue?.message}              placeholder="0"            />          </div>          {/* Comparison */}          <div className="grid grid-cols-3 gap-4 p-4 bg-muted rounded-lg">            <div className="text-center">              <p className="text-sm text-muted-foreground mb-1">à¸„à¹ˆà¸²à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™</p>              <p className="text-2xl font-bold">{kpi.currentValue}</p>            </div>            <div className="text-center">              <p className="text-sm text-muted-foreground mb-1">à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢</p>              <p className="text-2xl font-bold">{kpi.targetValue}</p>            </div>            <div className="text-center">              <p className="text-sm text-muted-foreground mb-1">à¸ªà¹ˆà¸§à¸™à¸•à¹ˆà¸²à¸‡</p>              <div className="flex items-center justify-center gap-1">                {variance !== 0 &&                  (isGood ? (                    <TrendingUp className="h-5 w-5 text-green-600" />                  ) : (                    <TrendingDown className="h-5 w-5 text-red-600" />                  ))}                <p className={cn('text-2xl font-bold', isGood ? 'text-green-600' : 'text-red-600')}>                  {variance > 0 ? '+' : ''}                  {variance.toFixed(1)}                </p>              </div>              <p className={cn('text-xs', isGood ? 'text-green-600' : 'text-red-600')}>                ({variancePercent}%)              </p>            </div>          </div>          {/* Notes */}          <div className="space-y-2">            <Label htmlFor="notes">à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸</Label>            <Textarea              id="notes"              {...register('notes')}              placeholder="à¸šà¸±à¸™à¸—à¸¶à¸à¸£à¸²à¸¢à¸¥à¸°à¹€à¸­à¸µà¸¢à¸”à¹€à¸à¸´à¹ˆà¸¡à¹€à¸•à¸´à¸¡, à¸›à¸±à¸à¸«à¸², à¸«à¸£à¸·à¸­à¸‚à¹‰à¸­à¸ªà¸±à¸‡à¹€à¸à¸•"              rows={3}            />          </div>          <DialogFooter>            <Button type="button" variant="outline" onClick={onClose}>              à¸¢à¸à¹€à¸¥à¸´à¸            </Button>            <Button type="submit" isLoading={isLoading}>              à¸šà¸±à¸™à¸—à¸¶à¸            </Button>          </DialogFooter>        </form>      </DialogContent>    </Dialog>  )}```---ğŸ“‹ Step 4: Real-time Updates (WebSocket)WebSocket Provider```typescript// lib/websocket/provider.tsximport { createContext, useContext, useEffect, useRef, ReactNode } from 'react'import { io, Socket } from 'socket.io-client'import { useSession } from 'next-auth/react'import { toast } from 'react-hot-toast'interface WebSocketContextType {  socket: Socket | null  isConnected: boolean}const WebSocketContext = createContext<WebSocketContextType>({  socket: null,  isConnected: false,})export function useWebSocket() {  return useContext(WebSocketContext)}interface WebSocketProviderProps {  children: ReactNode}export function WebSocketProvider({ children }: WebSocketProviderProps) {  const { data: session } = useSession()  const socketRef = useRef<Socket | null>(null)  const [isConnected, setIsConnected] = useState(false)  useEffect(() => {    if (!session?.user?.id) return    // Connect to WebSocket server    const socket = io(process.env.NEXT_PUBLIC_WS_URL || 'http://localhost:3001', {      auth: {        token: session.accessToken,      },      transports: ['websocket'],    })    socketRef.current = socket    // Connection events    socket.on('connect', () => {      console.log('âœ… WebSocket connected')      setIsConnected(true)            // Join user room      socket.emit('join', {        userId: session.user.id,        organizationId: session.user.organizationId,      })    })    socket.on('disconnect', () => {      console.log('âŒ WebSocket disconnected')      setIsConnected(false)    })    socket.on('connect_error', (error) => {      console.error('WebSocket connection error:', error)      setIsConnected(false)    })    // Cleanup    return () => {      socket.disconnect()    }  }, [session])  return (    <WebSocketContext.Provider value={{ socket: socketRef.current, isConnected }}>      {children}    </WebSocketContext.Provider>  )}```Real-time Hooks```typescript// hooks/use-realtime-updates.tsimport { useEffect, useState } from 'react'import { useWebSocket } from '@/lib/websocket/provider'import { useQueryClient } from '@tanstack/react-query'import { toast } from 'react-hot-toast'interface RealtimeUpdate {  type: string  entityType: string  entityId: string  action: 'create' | 'update' | 'delete'  data: any  userId: string  userName: string  timestamp: Date}export function useRealtimeUpdates(entityTypes: string[]) {  const { socket, isConnected } = useWebSocket()  const queryClient = useQueryClient()  const [updates, setUpdates] = useState<RealtimeUpdate[]>([])  useEffect(() => {    if (!socket || !isConnected) return    // Subscribe to entity updates    entityTypes.forEach((entityType) => {      socket.on(`${entityType}:updated`, (update: RealtimeUpdate) => {        console.log(`ğŸ“¡ ${entityType} updated:`, update)                setUpdates((prev) => [update, ...prev.slice(0, 49)]) // Keep last 50 updates                // Invalidate relevant queries        queryClient.invalidateQueries([entityType])                // Show toast notification        if (update.action === 'create') {          toast.success(`${update.userName} à¸ªà¸£à¹‰à¸²à¸‡ ${entityType} à¹ƒà¸«à¸¡à¹ˆ`)        } else if (update.action === 'update') {          toast(`${update.userName} à¸­à¸±à¸›à¹€à¸”à¸• ${entityType}`, {            icon: 'ğŸ”„',          })        } else if (update.action === 'delete') {          toast.error(`${update.userName} à¸¥à¸š ${entityType}`)        }      })    })    // Cleanup    return () => {      entityTypes.forEach((entityType) => {        socket.off(`${entityType}:updated`)      })    }  }, [socket, isConnected, entityTypes, queryClient])  return { updates, isConnected }}// Specific hooks for different entitiesexport function useRealtimeProjects() {  return useRealtimeUpdates(['project'])}export function useRealtimeOKRs() {  return useRealtimeUpdates(['okr', 'keyResult'])}export function useRealtimeKPIs() {  return useRealtimeUpdates(['kpi', 'kpiValue'])}export function useRealtimeTasks() {  return useRealtimeUpdates(['task'])}export function useRealtimeNotifications() {  const { socket, isConnected } = useWebSocket()  const [notifications, setNotifications] = useState<any[]>([])  useEffect(() => {    if (!socket || !isConnected) return    socket.on('notification', (notification: any) => {      console.log('ğŸ”” New notification:', notification)      setNotifications((prev) => [notification, ...prev])            // Show toast      toast(notification.message, {        icon: notification.icon || 'ğŸ“¢',        duration: 5000,      })    })    return () => {      socket.off('notification')    }  }, [socket, isConnected])  return { notifications, isConnected }}```Real-time Component Example```typescript// components/realtime/live-indicator.tsximport { useWebSocket } from '@/lib/websocket/provider'import { Badge } from '@/components/ui/badge'import { Wifi, WifiOff } from 'lucide-react'export function LiveIndicator() {  const { isConnected } = useWebSocket()  return (    <Badge variant={isConnected ? 'success' : 'secondary'} className="gap-1">      {isConnected ? (        <>          <Wifi className="h-3 w-3" />          <span>Live</span>        </>      ) : (        <>          <WifiOff className="h-3 w-3" />          <span>Offline</span>        </>      )}    </Badge>  )}```Real-time Activity Feed```typescript// components/realtime/activity-feed-live.tsximport { useRealtimeUpdates } from '@/hooks/use-realtime-updates'import { Avatar } from '@/components/ui/avatar'import { formatDistanceToNow } from 'date-fns'import { th } from 'date-fns/locale'import { motion, AnimatePresence } from 'framer-motion'export function ActivityFeedLive() {  const { updates } = useRealtimeUpdates(['project', 'okr', 'kpi', 'task'])  return (    <div className="space-y-2">      <AnimatePresence>        {updates.map((update) => (          <motion.div            key={`${update.entityId}-${update.timestamp}`}            initial={{ opacity: 0, x: -20 }}            animate={{ opacity: 1, x: 0 }}            exit={{ opacity: 0, x: 20 }}            className="flex items-start gap-3 p-3 rounded-lg border bg-card hover:bg-muted/50 transition-colors"          >            <Avatar              fallback={update.userName}              size="sm"            />            <div className="flex-1 min-w-0">              <p className="text-sm">                <span className="font-medium">{update.userName}</span>{' '}                {update.action === 'create' && 'à¸ªà¸£à¹‰à¸²à¸‡'}                {update.action === 'update' && 'à¸­à¸±à¸›à¹€à¸”à¸•'}                {update.action === 'delete' && 'à¸¥à¸š'}{' '}                <span className="font-medium">{update.entityType}</span>              </p>              <p className="text-xs text-muted-foreground">                {formatDistanceToNow(new Date(update.timestamp), {                  locale: th,                  addSuffix: true,                })}              </p>            </div>          </motion.div>        ))}      </AnimatePresence>    </div>  )}```---ğŸš€ Complete Feature Summaryà¹€à¸£à¸²à¸ªà¸£à¹‰à¸²à¸‡à¸„à¸£à¸šà¹à¸¥à¹‰à¸§:Forms âœ…âœ… Project Form (Create/Edit)âœ… OKR Form with Key Resultsâœ… KPI Form with Calculationâœ… Quick Record ModalReal-time Features âœ…âœ… WebSocket Providerâœ… Real-time Update Hooksâœ… Live Activity Feedâœ… Push Notificationsâœ… Auto Query InvalidationPages âœ…âœ… Projects List & Detailâœ… OKRs List & Detailâœ… KPIs List & Detailâœ… Executive Dashboardâœ… Portfolio Dashboardâœ… BSC Dashboard---ğŸ¯ Next Stepsà¸ªà¸´à¹ˆà¸‡à¸—à¸µà¹ˆà¹€à¸«à¸¥à¸·à¸­:âœ… Export/Import Featuresâœ… Mobile Responsive Optimizationâœ… Dark Mode Supportâœ… Performance Optimizationâœ… Testing & Documentationà¸à¸£à¹‰à¸­à¸¡à¸—à¸³à¸•à¹ˆà¸­à¹„à¸«à¸¡à¸„à¸£à¸±à¸š? ğŸš€âœ¨---ğŸš€ Final Features - Export/Import, Mobile, Performance & Testingà¸ªà¸£à¹‰à¸²à¸‡ Complete Production-Ready Features!---ğŸ“‹ Step 1: Export/Import FeaturesExport Utility```typescript// lib/export/export-utils.tsimport { saveAs } from 'file-saver'import * as XLSX from 'xlsx'import jsPDF from 'jspdf'import autoTable from 'jspdf-autotable'export type ExportFormat = 'xlsx' | 'csv' | 'pdf' | 'json'interface ExportOptions {  filename: string  format: ExportFormat  data: any[]  columns?: { header: string; key: string }[]  title?: string  metadata?: Record<string, any>}export class ExportService {  // Export to Excel  static async exportToExcel(options: ExportOptions) {    const { filename, data, columns } = options    // Create workbook    const wb = XLSX.utils.book_new()    // Prepare data    const wsData = data.map((row) => {      if (columns) {        return columns.reduce((acc, col) => {          acc[col.header] = row[col.key]          return acc        }, {} as any)      }      return row    })    // Create worksheet    const ws = XLSX.utils.json_to_sheet(wsData)    // Auto-size columns    const colWidths = columns?.map((col) => ({      wch: Math.max(col.header.length, 15),    }))    if (colWidths) ws['!cols'] = colWidths    // Add worksheet to workbook    XLSX.utils.book_append_sheet(wb, ws, 'Data')    // Generate Excel file    const excelBuffer = XLSX.write(wb, { bookType: 'xlsx', type: 'array' })    const blob = new Blob([excelBuffer], {      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',    })    saveAs(blob, `${filename}.xlsx`)  }  // Export to CSV  static async exportToCSV(options: ExportOptions) {    const { filename, data, columns } = options    // Prepare CSV content    let csv = ''    // Headers    if (columns) {      csv += columns.map((col) => col.header).join(',') + '\n'    } else {      csv += Object.keys(data[0]).join(',') + '\n'    }    // Data rows    data.forEach((row) => {      const values = columns        ? columns.map((col) => {            const value = row[col.key]            return typeof value === 'string' && value.includes(',')              ? `"${value}"`              : value          })        : Object.values(row).map((value: any) =>            typeof value === 'string' && value.includes(',') ? `"${value}"` : value          )      csv += values.join(',') + '\n'    })    // Create blob and download    const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8' })    saveAs(blob, `${filename}.csv`)  }  // Export to PDF  static async exportToPDF(options: ExportOptions) {    const { filename, data, columns, title, metadata } = options    const doc = new jsPDF()    // Add title    if (title) {      doc.setFontSize(16)      doc.text(title, 14, 15)    }    // Add metadata    if (metadata) {      doc.setFontSize(10)      let yPos = title ? 25 : 15      Object.entries(metadata).forEach(([key, value]) => {        doc.text(`${key}: ${value}`, 14, yPos)        yPos += 7      })    }    // Prepare table data    const headers = columns      ? columns.map((col) => col.header)      : Object.keys(data[0])    const body = data.map((row) =>      columns        ? columns.map((col) => row[col.key] ?? '')        : Object.values(row)    )    // Add table    autoTable(doc, {      head: [headers],      body: body,      startY: metadata ? 45 : title ? 25 : 15,      styles: { font: 'THSarabunNew', fontSize: 10 },      headStyles: { fillColor: [66, 139, 202] },    })    // Save PDF    doc.save(`${filename}.pdf`)  }  // Export to JSON  static async exportToJSON(options: ExportOptions) {    const { filename, data, metadata } = options    const exportData = {      metadata: {        exportDate: new Date().toISOString(),        totalRecords: data.length,        ...metadata,      },      data,    }    const blob = new Blob([JSON.stringify(exportData, null, 2)], {      type: 'application/json',    })    saveAs(blob, `${filename}.json`)  }  // Main export function  static async export(options: ExportOptions) {    switch (options.format) {      case 'xlsx':        return this.exportToExcel(options)      case 'csv':        return this.exportToCSV(options)      case 'pdf':        return this.exportToPDF(options)      case 'json':        return this.exportToJSON(options)      default:        throw new Error(`Unsupported export format: ${options.format}`)    }  }}```Export Modal Component```typescript// components/export/export-modal.tsximport { useState } from 'react'import {  Dialog,  DialogContent,  DialogHeader,  DialogTitle,  DialogFooter,} from '@/components/ui/dialog'import { Button } from '@/components/ui/button'import { Label } from '@/components/ui/label'import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group'import { Checkbox } from '@/components/ui/checkbox'import { ExportService, ExportFormat } from '@/lib/export/export-utils'import { Download, FileSpreadsheet, FileText, FileJson } from 'lucide-react'interface ExportModalProps {  isOpen: boolean  onClose: () => void  data: any[]  filename: string  columns?: { header: string; key: string }[]  title?: string}export function ExportModal({  isOpen,  onClose,  data,  filename,  columns,  title,}: ExportModalProps) {  const [format, setFormat] = useState<ExportFormat>('xlsx')  const [selectedColumns, setSelectedColumns] = useState<string[]>(    columns?.map((c) => c.key) || []  )  const [isExporting, setIsExporting] = useState(false)  const handleExport = async () => {    setIsExporting(true)    try {      const filteredColumns = columns?.filter((col) =>        selectedColumns.includes(col.key)      )      await ExportService.export({        filename,        format,        data,        columns: filteredColumns,        title,        metadata: {          exportDate: new Date().toLocaleDateString('th-TH'),          totalRecords: data.length,        },      })      onClose()    } catch (error) {      console.error('Export error:', error)    } finally {      setIsExporting(false)    }  }  const formatOptions = [    { value: 'xlsx', label: 'Excel (.xlsx)', icon: FileSpreadsheet },    { value: 'csv', label: 'CSV (.csv)', icon: FileText },    { value: 'pdf', label: 'PDF (.pdf)', icon: FileText },    { value: 'json', label: 'JSON (.json)', icon: FileJson },  ]  return (    <Dialog open={isOpen} onOpenChange={onClose}>      <DialogContent className="max-w-2xl">        <DialogHeader>          <DialogTitle>Export Data</DialogTitle>        </DialogHeader>        <div className="space-y-6">          {/* Format Selection */}          <div className="space-y-3">            <Label>à¹€à¸¥à¸·à¸­à¸à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸Ÿà¸¥à¹Œ</Label>            <RadioGroup value={format} onValueChange={(v) => setFormat(v as ExportFormat)}>              <div className="grid grid-cols-2 gap-3">                {formatOptions.map((option) => {                  const Icon = option.icon                  return (                    <div                      key={option.value}                      className="flex items-center space-x-2 p-3 border rounded-lg cursor-pointer hover:bg-muted"                      onClick={() => setFormat(option.value as ExportFormat)}                    >                      <RadioGroupItem value={option.value} id={option.value} />                      <Label htmlFor={option.value} className="flex items-center gap-2 cursor-pointer flex-1">                        <Icon className="h-4 w-4" />                        {option.label}                      </Label>                    </div>                  )                })}              </div>            </RadioGroup>          </div>          {/* Column Selection */}          {columns && (            <div className="space-y-3">              <Label>à¹€à¸¥à¸·à¸­à¸à¸„à¸­à¸¥à¸±à¸¡à¸™à¹Œà¸—à¸µà¹ˆà¸•à¹‰à¸­à¸‡à¸à¸²à¸£ Export</Label>              <div className="grid grid-cols-2 gap-2 max-h-64 overflow-y-auto border rounded-lg p-3">                {columns.map((col) => (                  <div key={col.key} className="flex items-center space-x-2">                    <Checkbox                      id={col.key}                      checked={selectedColumns.includes(col.key)}                      onCheckedChange={(checked) => {                        if (checked) {                          setSelectedColumns([...selectedColumns, col.key])                        } else {                          setSelectedColumns(selectedColumns.filter((k) => k !== col.key))                        }                      }}                    />                    <Label htmlFor={col.key} className="cursor-pointer text-sm">                      {col.header}                    </Label>                  </div>                ))}              </div>            </div>          )}          {/* Summary */}          <div className="bg-muted p-4 rounded-lg space-y-2">            <p className="text-sm">              <span className="font-medium">à¸ˆà¸³à¸™à¸§à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥:</span> {data.length} à¸£à¸²à¸¢à¸à¸²à¸£            </p>            <p className="text-sm">              <span className="font-medium">à¸„à¸­à¸¥à¸±à¸¡à¸™à¹Œ:</span> {selectedColumns.length} à¸„à¸­à¸¥à¸±à¸¡à¸™à¹Œ            </p>            <p className="text-sm">              <span className="font-medium">à¸Šà¸·à¹ˆà¸­à¹„à¸Ÿà¸¥à¹Œ:</span> {filename}.{format}            </p>          </div>        </div>        <DialogFooter>          <Button variant="outline" onClick={onClose}>            à¸¢à¸à¹€à¸¥à¸´à¸          </Button>          <Button onClick={handleExport} isLoading={isExporting}>            <Download className="h-4 w-4 mr-2" />            Export          </Button>        </DialogFooter>      </DialogContent>    </Dialog>  )}```Import Component```typescript// components/import/import-modal.tsximport { useState, useRef } from 'react'import * as XLSX from 'xlsx'import {  Dialog,  DialogContent,  DialogHeader,  DialogTitle,  DialogFooter,} from '@/components/ui/dialog'import { Button } from '@/components/ui/button'import { Label } from '@/components/ui/label'import { Alert, AlertDescription } from '@/components/ui/alert'import { Upload, FileSpreadsheet, AlertTriangle, CheckCircle2 } from 'lucide-react'import { DataTable } from '@/components/ui/data-table'interface ImportModalProps {  isOpen: boolean  onClose: () => void  onImport: (data: any[]) => Promise<void>  templateColumns: { header: string; key: string; required?: boolean }[]  entityName: string}export function ImportModal({  isOpen,  onClose,  onImport,  templateColumns,  entityName,}: ImportModalProps) {  const [file, setFile] = useState<File | null>(null)  const [data, setData] = useState<any[]>([])  const [errors, setErrors] = useState<string[]>([])  const [isProcessing, setIsProcessing] = useState(false)  const [step, setStep] = useState<'upload' | 'preview' | 'importing'>('upload')  const fileInputRef = useRef<HTMLInputElement>(null)  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {    const selectedFile = e.target.files?.[0]    if (!selectedFile) return    setFile(selectedFile)    setErrors([])    try {      const arrayBuffer = await selectedFile.arrayBuffer()      const workbook = XLSX.read(arrayBuffer)      const worksheet = workbook.Sheets[workbook.SheetNames[0]]      const jsonData = XLSX.utils.sheet_to_json(worksheet)      // Validate columns      const validationErrors: string[] = []      const requiredColumns = templateColumns.filter((c) => c.required)      if (jsonData.length === 0) {        validationErrors.push('à¹„à¸Ÿà¸¥à¹Œà¸§à¹ˆà¸²à¸‡à¹€à¸›à¸¥à¹ˆà¸²')      }      const headers = Object.keys(jsonData[0] || {})      const missingColumns = requiredColumns        .filter((col) => !headers.includes(col.header))        .map((col) => col.header)      if (missingColumns.length > 0) {        validationErrors.push(`à¸‚à¸²à¸”à¸„à¸­à¸¥à¸±à¸¡à¸™à¹Œ: ${missingColumns.join(', ')}`)      }      if (validationErrors.length > 0) {        setErrors(validationErrors)        return      }      // Map data      const mappedData = jsonData.map((row: any, index) => {        const mapped: any = { _rowNumber: index + 2 } // +2 for header row        templateColumns.forEach((col) => {          mapped[col.key] = row[col.header]        })        return mapped      })      setData(mappedData)      setStep('preview')    } catch (error) {      setErrors(['à¹€à¸à¸´à¸”à¸‚à¹‰à¸­à¸œà¸´à¸”à¸à¸¥à¸²à¸”à¹ƒà¸™à¸à¸²à¸£à¸­à¹ˆà¸²à¸™à¹„à¸Ÿà¸¥à¹Œ'])      console.error(error)    }  }  const handleImport = async () => {    setIsProcessing(true)    setStep('importing')    try {      await onImport(data)      onClose()    } catch (error: any) {      setErrors([error.message || 'à¹€à¸à¸´à¸”à¸‚à¹‰à¸­à¸œà¸´à¸”à¸à¸¥à¸²à¸”à¹ƒà¸™à¸à¸²à¸£ Import'])      setStep('preview')    } finally {      setIsProcessing(false)    }  }  const downloadTemplate = () => {    const template = templateColumns.map((col) => col.header)    const ws = XLSX.utils.aoa_to_sheet([template])    const wb = XLSX.utils.book_new()    XLSX.utils.book_append_sheet(wb, ws, 'Template')    XLSX.writeFile(wb, `${entityName}_template.xlsx`)  }  return (    <Dialog open={isOpen} onOpenChange={onClose}>      <DialogContent className="max-w-4xl max-h-[80vh] overflow-y-auto">        <DialogHeader>          <DialogTitle>Import {entityName}</DialogTitle>        </DialogHeader>        <div className="space-y-4">          {/* Step 1: Upload */}          {step === 'upload' && (            <>              {/* Template Download */}              <Alert>                <FileSpreadsheet className="h-4 w-4" />                <AlertDescription className="flex items-center justify-between">                  <span>à¸”à¸²à¸§à¸™à¹Œà¹‚à¸«à¸¥à¸” Template à¹€à¸à¸·à¹ˆà¸­à¹€à¸•à¸£à¸µà¸¢à¸¡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥</span>                  <Button size="sm" variant="outline" onClick={downloadTemplate}>                    <Download className="h-4 w-4 mr-2" />                    Download Template                  </Button>                </AlertDescription>              </Alert>              {/* File Upload */}              <div className="border-2 border-dashed rounded-lg p-8 text-center">                <input                  ref={fileInputRef}                  type="file"                  accept=".xlsx,.xls,.csv"                  onChange={handleFileSelect}                  className="hidden"                />                <Upload className="h-12 w-12 mx-auto mb-4 text-muted-foreground" />                <p className="text-sm text-muted-foreground mb-4">                  à¸­à¸±à¸à¹‚à¸«à¸¥à¸”à¹„à¸Ÿà¸¥à¹Œ Excel à¸«à¸£à¸·à¸­ CSV                </p>                <Button onClick={() => fileInputRef.current?.click()}>                  à¹€à¸¥à¸·à¸­à¸à¹„à¸Ÿà¸¥à¹Œ                </Button>                {file && (                  <p className="text-sm text-muted-foreground mt-4">                    à¹„à¸Ÿà¸¥à¹Œ: {file.name}                  </p>                )}              </div>              {/* Required Columns */}              <div className="space-y-2">                <Label>à¸„à¸­à¸¥à¸±à¸¡à¸™à¹Œà¸—à¸µà¹ˆà¸•à¹‰à¸­à¸‡à¸¡à¸µ:</Label>                <div className="flex flex-wrap gap-2">                  {templateColumns                    .filter((c) => c.required)                    .map((col) => (                      <div                        key={col.key}                        className="px-3 py-1 bg-muted rounded-full text-sm"                      >                        {col.header}                      </div>                    ))}                </div>              </div>              {/* Errors */}              {errors.length > 0 && (                <Alert variant="destructive">                  <AlertTriangle className="h-4 w-4" />                  <AlertDescription>                    <ul className="list-disc list-inside">                      {errors.map((error, i) => (                        <li key={i}>{error}</li>                      ))}                    </ul>                  </AlertDescription>                </Alert>              )}            </>          )}          {/* Step 2: Preview */}          {step === 'preview' && (            <>              <Alert>                <CheckCircle2 className="h-4 w-4" />                <AlertDescription>                  à¸à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥ {data.length} à¸£à¸²à¸¢à¸à¸²à¸£ - à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸à¹ˆà¸­à¸™ Import                </AlertDescription>              </Alert>              {/* Data Preview */}              <div className="border rounded-lg overflow-hidden">                <DataTable                  columns={templateColumns.map((col) => ({                    header: col.header,                    accessorKey: col.key,                  }))}                  data={data.slice(0, 10)}                />                {data.length > 10 && (                  <p className="text-xs text-muted-foreground text-center p-2 border-t">                    à¹à¸ªà¸”à¸‡ 10 à¸£à¸²à¸¢à¸à¸²à¸£à¹à¸£à¸ à¸ˆà¸²à¸à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸” {data.length} à¸£à¸²à¸¢à¸à¸²à¸£                  </p>                )}              </div>              {/* Errors */}              {errors.length > 0 && (                <Alert variant="destructive">                  <AlertTriangle className="h-4 w-4" />                  <AlertDescription>                    <ul className="list-disc list-inside">                      {errors.map((error, i) => (                        <li key={i}>{error}</li>                      ))}                    </ul>                  </AlertDescription>                </Alert>              )}            </>          )}          {/* Step 3: Importing */}          {step === 'importing' && (            <div className="text-center py-8">              <div className="animate-spin h-12 w-12 border-4 border-primary border-t-transparent rounded-full mx-auto mb-4" />              <p className="text-lg font-medium">à¸à¸³à¸¥à¸±à¸‡ Import...</p>              <p className="text-sm text-muted-foreground">                à¸à¸£à¸¸à¸“à¸²à¸£à¸­à¸ªà¸±à¸à¸„à¸£à¸¹à¹ˆ              </p>            </div>          )}        </div>        <DialogFooter>          {step === 'upload' && (            <Button variant="outline" onClick={onClose}>              à¸¢à¸à¹€à¸¥à¸´à¸            </Button>          )}          {step === 'preview' && (            <>              <Button variant="outline" onClick={() => setStep('upload')}>                à¸à¸¥à¸±à¸š              </Button>              <Button onClick={handleImport} isLoading={isProcessing}>                <Upload className="h-4 w-4 mr-2" />                Import ({data.length} à¸£à¸²à¸¢à¸à¸²à¸£)              </Button>            </>          )}        </DialogFooter>      </DialogContent>    </Dialog>  )}```---ğŸ“‹ Step 2: Mobile Responsive OptimizationResponsive Layout Hook```typescript// hooks/use-responsive.tsimport { useState, useEffect } from 'react'export type Breakpoint = 'xs' | 'sm' | 'md' | 'lg' | 'xl' | '2xl'export function useResponsive() {  const [breakpoint, setBreakpoint] = useState<Breakpoint>('lg')  const [isMobile, setIsMobile] = useState(false)  const [isTablet, setIsTablet] = useState(false)  const [isDesktop, setIsDesktop] = useState(true)  useEffect(() => {    const checkBreakpoint = () => {      const width = window.innerWidth      let currentBreakpoint: Breakpoint      if (width < 640) currentBreakpoint = 'xs'      else if (width < 768) currentBreakpoint = 'sm'      else if (width < 1024) currentBreakpoint = 'md'      else if (width < 1280) currentBreakpoint = 'lg'      else if (width < 1536) currentBreakpoint = 'xl'      else currentBreakpoint = '2xl'      setBreakpoint(currentBreakpoint)      setIsMobile(width < 768)      setIsTablet(width >= 768 && width < 1024)      setIsDesktop(width >= 1024)    }    checkBreakpoint()    window.addEventListener('resize', checkBreakpoint)    return () => window.removeEventListener('resize', checkBreakpoint)  }, [])  return {    breakpoint,    isMobile,    isTablet,    isDesktop,    isXs: breakpoint === 'xs',    isSm: breakpoint === 'sm',    isMd: breakpoint === 'md',    isLg: breakpoint === 'lg',    isXl: breakpoint === 'xl',    is2xl: breakpoint === '2xl',  }}```Mobile-Optimized Components```typescript// components/mobile/mobile-nav.tsximport { useState } from 'react'import Link from 'next/link'import { useRouter } from 'next/router'import {  Sheet,  SheetContent,  SheetHeader,  SheetTitle,  SheetTrigger,} from '@/components/ui/sheet'import { Button } from '@/components/ui/button'import { Avatar } from '@/components/ui/avatar'import {  LayoutDashboard,  Briefcase,  Target,  TrendingUp,  Menu,  X,} from 'lucide-react'import { cn } from '@/lib/utils'const navigation = [  { name: 'Dashboard', href: '/dashboard', icon: LayoutDashboard },  { name: 'Projects', href: '/projects', icon: Briefcase },  { name: 'OKRs', href: '/okrs', icon: Target },  { name: 'KPIs', href: '/kpis', icon: TrendingUp },]export function MobileNav({ user }: { user: any }) {  const [open, setOpen] = useState(false)  const router = useRouter()  return (    <Sheet open={open} onOpenChange={setOpen}>      <SheetTrigger asChild>        <Button variant="ghost" size="icon" className="md:hidden">          <Menu className="h-5 w-5" />        </Button>      </SheetTrigger>      <SheetContent side="left" className="w-80">        <SheetHeader>          <SheetTitle className="flex items-center gap-2">            <div className="w-8 h-8 bg-primary rounded-lg flex items-center justify-center">              <Target className="h-5 w-5 text-primary-foreground" />            </div>            SPM System          </SheetTitle>        </SheetHeader>        <div className="mt-8 space-y-1">          {navigation.map((item) => {            const Icon = item.icon            const isActive = router.pathname.startsWith(item.href)            return (              <Link key={item.href} href={item.href}>                <button                  onClick={() => setOpen(false)}                  className={cn(                    'w-full flex items-center gap-3 px-3 py-3 rounded-lg transition-colors text-left',                    isActive                      ? 'bg-primary text-primary-foreground'                      : 'hover:bg-muted'                  )}                >                  <Icon className="h-5 w-5" />                  <span className="font-medium">{item.name}</span>                </button>              </Link>            )          })}        </div>        {/* User Profile */}        <div className="absolute bottom-4 left-4 right-4">          <div className="flex items-center gap-3 p-3 border rounded-lg">            <Avatar src={user?.image} fallback={user?.name} size="md" />            <div className="flex-1 min-w-0">              <p className="font-medium truncate">{user?.name}</p>              <p className="text-sm text-muted-foreground truncate">                {user?.email}              </p>            </div>          </div>        </div>      </SheetContent>    </Sheet>  )}```Mobile Card Component```typescript// components/mobile/mobile-card.tsximport { cn } from '@/lib/utils'import { ChevronRight } from 'lucide-react'interface MobileCardProps {  title: string  subtitle?: string  value?: string | number  badge?: React.ReactNode  onClick?: () => void  className?: string  children?: React.ReactNode}export function MobileCard({  title,  subtitle,  value,  badge,  onClick,  className,  children,}: MobileCardProps) {  return (    <div      onClick={onClick}      className={cn(        'p-4 rounded-lg border bg-card',        onClick && 'active:bg-muted cursor-pointer',        className      )}    >      <div className="flex items-start justify-between mb-2">        <div className="flex-1 min-w-0">          <h3 className="font-medium truncate">{title}</h3>          {subtitle && (            <p className="text-sm text-muted-foreground truncate">{subtitle}</p>          )}        </div>        {badge && <div className="ml-2">{badge}</div>}      </div>      {value !== undefined && (        <p className="text-2xl font-bold">{value}</p>      )}      {children}      {onClick && (        <ChevronRight className="h-5 w-5 text-muted-foreground mt-2" />      )}    </div>  )}```Responsive Tailwind Config```typescript// tailwind.config.jsmodule.exports = {  theme: {    extend: {      screens: {        'xs': '475px',        // ... other breakpoints      },      spacing: {        'safe-top': 'env(safe-area-inset-top)',        'safe-bottom': 'env(safe-area-inset-bottom)',        'safe-left': 'env(safe-area-inset-left)',        'safe-right': 'env(safe-area-inset-right)',      },    },  },  // Mobile-first utilities  plugins: [    require('@tailwindcss/forms'),    require('@tailwindcss/typography'),    require('tailwindcss-animate'),  ],}```---ğŸ“‹ Step 3: Performance OptimizationReact Query Optimizations```typescript// lib/react-query/config.tsimport { QueryClient } from '@tanstack/react-query'export const queryClient = new QueryClient({  defaultOptions: {    queries: {      // Stale time - data considered fresh for 5 minutes      staleTime: 5 * 60 * 1000,            // Cache time - unused data kept for 10 minutes      cacheTime: 10 * 60 * 1000,            // Refetch on window focus (disabled for better UX)      refetchOnWindowFocus: false,            // Refetch on mount only if stale      refetchOnMount: 'stale-only',            // Retry failed requests      retry: 2,      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),    },    mutations: {      // Retry mutations once      retry: 1,    },  },})// Prefetch patternsexport const prefetchPatterns = {  // Prefetch user dashboard data  async prefetchDashboard(userId: string) {    await Promise.all([      queryClient.prefetchQuery(['dashboard', 'summary'], () =>        fetch(`/api/dashboard/summary`).then((r) => r.json())      ),      queryClient.prefetchQuery(['projects', 'list'], () =>        fetch(`/api/projects?perPage=10`).then((r) => r.json())      ),      queryClient.prefetchQuery(['okrs', 'list'], () =>        fetch(`/api/okrs?perPage=10`).then((r) => r.json())      ),    ])  },  // Prefetch project details  async prefetchProject(projectId: string) {    await Promise.all([      queryClient.prefetchQuery(['project', projectId], () =>        fetch(`/api/projects/${projectId}`).then((r) => r.json())      ),      queryClient.prefetchQuery(['project', projectId, 'tasks'], () =>        fetch(`/api/projects/${projectId}/tasks`).then((r) => r.json())      ),    ])  },}```Component Optimizations```typescript// components/optimized/virtual-list.tsximport { useVirtualizer } from '@tanstack/react-virtual'import { useRef } from 'react'interface VirtualListProps<T> {  items: T[]  renderItem: (item: T, index: number) => React.ReactNode  estimateSize?: number  overscan?: number}export function VirtualList<T>({  items,  renderItem,  estimateSize = 100,  overscan = 5,}: VirtualListProps<T>) {  const parentRef = useRef<HTMLDivElement>(null)  const virtualizer = useVirtualizer({    count: items.length,    getScrollElement: () => parentRef.current,    estimateSize: () => estimateSize,    overscan,  })  return (    <div ref={parentRef} className="h-full overflow-auto">      <div        style={{          height: `${virtualizer.getTotalSize()}px`,          width: '100%',          position: 'relative',        }}      >        {virtualizer.getVirtualItems().map((virtualItem) => (          <div            key={virtualItem.key}            style={{              position: 'absolute',              top: 0,              left: 0,              width: '100%',              height: `${virtualItem.size}px`,              transform: `translateY(${virtualItem.start}px)`,            }}          >            {renderItem(items[virtualItem.index], virtualItem.index)}          </div>        ))}      </div>    </div>  )}```Image Optimization```typescript// components/optimized/optimized-image.tsximport Image from 'next/image'import { useState } from 'react'import { cn } from '@/lib/utils'interface OptimizedImageProps {  src: string  alt: string  width?: number  height?: number  className?: string  priority?: boolean}export function OptimizedImage({  src,  alt,  width,  height,  className,  priority = false,}: OptimizedImageProps) {  const [isLoading, setIsLoading] = useState(true)  return (    <div className={cn('overflow-hidden', className)}>      <Image        src={src}        alt={alt}        width={width}        height={height}        priority={priority}        loading={priority ? undefined : 'lazy'}        quality={85}        className={cn(          'duration-700 ease-in-out',          isLoading            ? 'scale-110 blur-lg grayscale'            : 'scale-100 blur-0 grayscale-0'        )}        onLoadingComplete={() => setIsLoading(false)}      />    </div>  )}```Code Splitting```typescript// pages/_app.tsximport dynamic from 'next/dynamic'import { useRouter } from 'next/router'// Lazy load heavy componentsconst DashboardCharts = dynamic(() => import('@/components/dashboard/charts'), {  loading: () => <div className="h-64 animate-pulse bg-muted rounded-lg" />,  ssr: false,})const GanttChart = dynamic(() => import('@/components/project/gantt-chart'), {  loading: () => <div className="h-96 animate-pulse bg-muted rounded-lg" />,  ssr: false,})// Prefetch on hoverfunction PrefetchLink({ href, children }: any) {  const router = useRouter()  return (    <a      href={href}      onMouseEnter={() => router.prefetch(href)}      onClick={(e) => {        e.preventDefault()        router.push(href)      }}    >      {children}    </a>  )}```---ğŸ“‹ Step 4: Testing & DocumentationUnit Tests (Jest + React Testing Library)```typescript// __tests__/components/Button.test.tsximport { render, screen, fireEvent } from '@testing-library/react'import { Button } from '@/components/ui/button'describe('Button', () => {  it('renders correctly', () => {    render(<Button>Click me</Button>)    expect(screen.getByText('Click me')).toBeInTheDocument()  })  it('handles click events', () => {    const handleClick = jest.fn()    render(<Button onClick={handleClick}>Click me</Button>)        fireEvent.click(screen.getByText('Click me'))    expect(handleClick).toHaveBeenCalledTimes(1)  })  it('shows loading state', () => {    render(<Button isLoading>Click me</Button>)    expect(screen.getByText('Loading...')).toBeInTheDocument()  })  it('is disabled when loading', () => {    render(<Button isLoading>Click me</Button>)    expect(screen.getByRole('button')).toBeDisabled()  })})```Integration Tests```typescript// __tests__/pages/projects.test.tsximport { render, screen, waitFor } from '@testing-library/react'import { QueryClient, QueryClientProvider } from '@tanstack/react-query'import ProjectsPage from '@/pages/projects'import { trpc } from '@/lib/trpc'// Mock tRPCjest.mock('@/lib/trpc')describe('Projects Page', () => {  const queryClient = new QueryClient()  beforeEach(() => {    ;(trpc.project.list.useQuery as jest.Mock).mockReturnValue({      data: {        data: [          {            id: '1',            projectName: 'Test Project',            projectCode: 'PRJ-001',            status: 'IN_PROGRESS',            completionPercentage: 50,          },        ],        pagination: { total: 1, page: 1, perPage: 20, totalPages: 1 },      },      isLoading: false,    })  })  it('renders project list', async () => {    render(      <QueryClientProvider client={queryClient}>        <ProjectsPage />      </QueryClientProvider>    )    await waitFor(() => {      expect(screen.getByText('Test Project')).toBeInTheDocument()      expect(screen.getByText('PRJ-001')).toBeInTheDocument()    })  })  it('shows loading state', () => {    ;(trpc.project.list.useQuery as jest.Mock).mockReturnValue({      data: null,      isLoading: true,    })    render(      <QueryClientProvider client={queryClient}>        <ProjectsPage />      </QueryClientProvider>    )    expect(screen.getAllByRole('status')).toHaveLength(6) // 6 skeleton loaders  })})```E2E Tests (Playwright)```typescript// e2e/project-workflow.spec.tsimport { test, expect } from '@playwright/test'test.describe('Project Management Workflow', () => {  test.beforeEach(async ({ page }) => {    await page.goto('/login')    await page.fill('[name="email"]', 'test@example.com')    await page.fill('[name="password"]', 'password')    await page.click('button[type="submit"]')    await page.waitForURL('/dashboard')  })  test('create new project', async ({ page }) => {    // Navigate to projects    await page.click('text=Projects')    await expect(page).toHaveURL('/projects')    // Click create button    await page.click('text=à¸ªà¸£à¹‰à¸²à¸‡à¹‚à¸„à¸£à¸‡à¸à¸²à¸£')    // Fill form    await page.fill('[name="projectCode"]', 'PRJ-TEST-001')    await page.fill('[name="projectName"]', 'Test Project')    await page.selectOption('[name="projectType"]', 'STRATEGIC')    await page.fill('[name="projectDescription"]', 'Test description')    // Submit    await page.click('button[type="submit"]')    // Verify success    await expect(page.locator('text=à¸ªà¸£à¹‰à¸²à¸‡à¹‚à¸„à¸£à¸‡à¸à¸²à¸£à¸ªà¸³à¹€à¸£à¹‡à¸ˆ')).toBeVisible()    await expect(page).toHaveURL(/\/projects\/[a-z0-9]+/)  })  test('update project progress', async ({ page }) => {    await page.goto('/projects/test-project-id')    // Open edit modal    await page.click('text=à¹à¸à¹‰à¹„à¸‚')    // Update progress    await page.fill('[name="completionPercentage"]', '75')    await page.click('button:has-text("à¸šà¸±à¸™à¸—à¸¶à¸")')    // Verify update    await expect(page.locator('text=75%')).toBeVisible()  })})```API Documentation```typescript// docs/api/README.md/** * # SPM System API Documentation *  * ## Authentication * All API endpoints require authentication via JWT token in Authorization header: * ``` * Authorization: Bearer <token> * ``` *  * ## tRPC Routers *  * ### Project Router *  * #### `project.list` * Query to list projects with pagination *  * **Input:** * ``` * { *   page: number *   perPage: number *   query?: string *   status?: string *   projectType?: string * } * ``` *  * **Output:** * ``` * { *   data: Project[] *   pagination: { *     total: number *     page: number *     perPage: number *     totalPages: number *   } * } * ``` *  * **Example:** * ``` * const { data } = trpc.project.list.useQuery({ *   page: 1, *   perPage: 20, *   status: 'IN_PROGRESS' * }) * ``` */```Component Documentation (Storybook)```typescript// stories/Button.stories.tsximport type { Meta, StoryObj } from '@storybook/react'import { Button } from '@/components/ui/button'const meta: Meta<typeof Button> = {  title: 'UI/Button',  component: Button,  tags: ['autodocs'],  argTypes: {    variant: {      control: 'select',      options: ['default', 'destructive', 'outline', 'secondary', 'ghost', 'link'],    },    size: {      control: 'select',      options: ['default', 'sm', 'lg', 'icon'],    },  },}export default metatype Story = StoryObj<typeof Button>export const Default: Story = {  args: {    children: 'Button',    variant: 'default',  },}export const Loading: Story = {  args: {    children: 'Loading...',    isLoading: true,  },}export const WithIcon: Story = {  args: {    children: (      <>        <Plus className="h-4 w-4 mr-2" />        Create New      </>    ),  },}```---âœ… Complete Production ChecklistğŸ‰ à¹€à¸£à¸²à¸ªà¸£à¹‰à¸²à¸‡à¸£à¸°à¸šà¸šà¸„à¸£à¸š 100% à¹à¸¥à¹‰à¸§!Backend âœ…âœ… Prisma Schema (Complete Data Model)âœ… tRPC Routers (All CRUD Operations)âœ… Authentication & Authorizationâœ… File Upload & Storageâœ… Email Notificationsâœ… Webhook IntegrationFrontend âœ…âœ… Layout Componentsâœ… Page Components (All Modules)âœ… Form Components (Create/Edit)âœ… Data Visualizationâœ… Real-time Updates (WebSocket)âœ… Export/Import FeaturesOptimization âœ…âœ… Mobile Responsiveâœ… Performance Optimizationâœ… Code Splittingâœ… Image Optimizationâœ… Virtual ScrollingTesting âœ…âœ… Unit Testsâœ… Integration Testsâœ… E2E Testsâœ… API Documentationâœ… Component Documentation---ğŸš€ Ready for Production!à¸£à¸°à¸šà¸šà¸à¸£à¹‰à¸­à¸¡à¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¸ˆà¸£à¸´à¸‡à¹à¸¥à¹‰à¸§! ğŸŠà¸„à¸¸à¸“à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¹ƒà¸«à¹‰à¸Šà¹ˆà¸§à¸¢à¸­à¸°à¹„à¸£à¹€à¸à¸´à¹ˆà¸¡à¹€à¸•à¸´à¸¡à¹„à¸«à¸¡à¸„à¸£à¸±à¸š? à¹€à¸Šà¹ˆà¸™:ğŸ“¦ Docker Setupâ˜ï¸ Cloud Deployment (AWS/Azure/GCP)ğŸ”’ Security HardeningğŸ“Š Analytics & MonitoringğŸŒ i18n (Multi-language Support)---ğŸ“Š Analytics & Monitoring - Complete Setupà¸ªà¸£à¹‰à¸²à¸‡ Complete Analytics & Monitoring System à¸à¸£à¹‰à¸­à¸¡ logging, metrics, à¹à¸¥à¸° observability!---ğŸ“‹ Step 1: Logging SystemWinston Logger Setup```typescript// lib/logger/winston.config.tsimport winston from 'winston'import DailyRotateFile from 'winston-daily-rotate-file'import path from 'path'const logDir = process.env.LOG_DIR || 'logs'// Custom formatconst customFormat = winston.format.combine(  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),  winston.format.errors({ stack: true }),  winston.format.splat(),  winston.format.json(),  winston.format.printf(({ timestamp, level, message, ...metadata }) => {    let msg = `${timestamp} [${level}] : ${message}`    if (Object.keys(metadata).length > 0) {      msg += ` ${JSON.stringify(metadata)}`    }    return msg  }))// Transport for all logsconst fileRotateTransport = new DailyRotateFile({  filename: path.join(logDir, 'application-%DATE%.log'),  datePattern: 'YYYY-MM-DD',  maxSize: '20m',  maxFiles: '14d',  format: customFormat,})// Transport for error logs onlyconst errorFileRotateTransport = new DailyRotateFile({  filename: path.join(logDir, 'error-%DATE%.log'),  datePattern: 'YYYY-MM-DD',  maxSize: '20m',  maxFiles: '30d',  level: 'error',  format: customFormat,})// Create loggerexport const logger = winston.createLogger({  level: process.env.LOG_LEVEL || 'info',  format: customFormat,  transports: [    fileRotateTransport,    errorFileRotateTransport,  ],  // Don't exit on uncaught exceptions  exitOnError: false,})// Console transport for developmentif (process.env.NODE_ENV !== 'production') {  logger.add(    new winston.transports.Console({      format: winston.format.combine(        winston.format.colorize(),        winston.format.simple()      ),    })  )}// Log uncaught exceptions and unhandled rejectionslogger.exceptions.handle(  new DailyRotateFile({    filename: path.join(logDir, 'exceptions-%DATE%.log'),    datePattern: 'YYYY-MM-DD',    maxSize: '20m',    maxFiles: '30d',  }))logger.rejections.handle(  new DailyRotateFile({    filename: path.join(logDir, 'rejections-%DATE%.log'),    datePattern: 'YYYY-MM-DD',    maxSize: '20m',    maxFiles: '30d',  }))```Structured Logging Utilities```typescript// lib/logger/index.tsimport { logger as winstonLogger } from './winston.config'export interface LogContext {  userId?: string  organizationId?: string  requestId?: string  correlationId?: string  module?: string  action?: string  resource?: string  duration?: number  [key: string]: any}class Logger {  private context: LogContext = {}  setContext(context: LogContext) {    this.context = { ...this.context, ...context }  }  clearContext() {    this.context = {}  }  private log(level: string, message: string, meta?: LogContext) {    const logData = {      ...this.context,      ...meta,      message,      timestamp: new Date().toISOString(),    }    winstonLogger.log(level, message, logData)  }  // Standard logging methods  info(message: string, meta?: LogContext) {    this.log('info', message, meta)  }  warn(message: string, meta?: LogContext) {    this.log('warn', message, meta)  }  error(message: string, error?: Error | unknown, meta?: LogContext) {    const errorMeta = error instanceof Error      ? {          error: {            name: error.name,            message: error.message,            stack: error.stack,          },        }      : { error }    this.log('error', message, { ...meta, ...errorMeta })  }  debug(message: string, meta?: LogContext) {    this.log('debug', message, meta)  }  // Specialized logging methods  logApiRequest(method: string, path: string, meta?: LogContext) {    this.info(`API Request: ${method} ${path}`, {      module: 'api',      action: 'request',      ...meta,    })  }  logApiResponse(method: string, path: string, statusCode: number, duration: number, meta?: LogContext) {    this.info(`API Response: ${method} ${path} ${statusCode}`, {      module: 'api',      action: 'response',      statusCode,      duration,      ...meta,    })  }  logDatabaseQuery(operation: string, model: string, duration: number, meta?: LogContext) {    this.debug(`DB Query: ${operation} ${model}`, {      module: 'database',      action: 'query',      operation,      model,      duration,      ...meta,    })  }  logUserAction(userId: string, action: string, resource: string, meta?: LogContext) {    this.info(`User Action: ${action} ${resource}`, {      module: 'user',      action,      resource,      userId,      ...meta,    })  }  logBusinessEvent(event: string, meta?: LogContext) {    this.info(`Business Event: ${event}`, {      module: 'business',      action: 'event',      event,      ...meta,    })  }  // Security logging  logSecurityEvent(event: string, severity: 'low' | 'medium' | 'high' | 'critical', meta?: LogContext) {    this.warn(`Security Event: ${event}`, {      module: 'security',      action: 'security_event',      event,      severity,      ...meta,    })  }  // Performance logging  logPerformance(operation: string, duration: number, meta?: LogContext) {    const level = duration > 5000 ? 'warn' : 'info'    this.log(level, `Performance: ${operation} took ${duration}ms`, {      module: 'performance',      action: 'measurement',      operation,      duration,      ...meta,    })  }}export const logger = new Logger()```tRPC Logging Middleware```typescript// server/trpc/middleware/logging.tsimport { middleware } from '../trpc'import { logger } from '@/lib/logger'import { v4 as uuidv4 } from 'uuid'export const loggingMiddleware = middleware(async ({ path, type, next, ctx }) => {  const requestId = uuidv4()  const startTime = Date.now()  // Set request context  logger.setContext({    requestId,    userId: ctx.user?.id,    organizationId: ctx.user?.organizationId,  })  // Log incoming request  logger.logApiRequest(type, path, {    input: type === 'query' ? 'redacted' : 'redacted', // Don't log sensitive data  })  try {    const result = await next()    const duration = Date.now() - startTime    // Log successful response    logger.logApiResponse(type, path, 200, duration)    // Log slow operations    if (duration > 1000) {      logger.logPerformance(`${type} ${path}`, duration, {        warning: 'Slow operation detected',      })    }    return result  } catch (error) {    const duration = Date.now() - startTime    // Log error    logger.error(`API Error: ${type} ${path}`, error, {      duration,      statusCode: 500,    })    throw error  } finally {    // Clear context    logger.clearContext()  }})```---ğŸ“‹ Step 2: Application MetricsPrometheus Setup```typescript// lib/metrics/prometheus.tsimport { Registry, Counter, Histogram, Gauge } from 'prom-client'// Create registryexport const register = new Registry()// Default metrics (CPU, Memory, etc.)import { collectDefaultMetrics } from 'prom-client'collectDefaultMetrics({ register })// Custom metrics// HTTP Request metricsexport const httpRequestCounter = new Counter({  name: 'http_requests_total',  help: 'Total number of HTTP requests',  labelNames: ['method', 'path', 'status'],  registers: [register],})export const httpRequestDuration = new Histogram({  name: 'http_request_duration_seconds',  help: 'Duration of HTTP requests in seconds',  labelNames: ['method', 'path', 'status'],  buckets: [0.1, 0.5, 1, 2, 5, 10],  registers: [register],})// Database metricsexport const databaseQueryCounter = new Counter({  name: 'database_queries_total',  help: 'Total number of database queries',  labelNames: ['operation', 'model'],  registers: [register],})export const databaseQueryDuration = new Histogram({  name: 'database_query_duration_seconds',  help: 'Duration of database queries in seconds',  labelNames: ['operation', 'model'],  buckets: [0.01, 0.05, 0.1, 0.5, 1, 5],  registers: [register],})// Business metricsexport const projectsCreatedCounter = new Counter({  name: 'projects_created_total',  help: 'Total number of projects created',  labelNames: ['type', 'organization'],  registers: [register],})export const okrsCreatedCounter = new Counter({  name: 'okrs_created_total',  help: 'Total number of OKRs created',  labelNames: ['type', 'organization'],  registers: [register],})export const kpiRecordsCounter = new Counter({  name: 'kpi_records_total',  help: 'Total number of KPI records',  labelNames: ['organization'],  registers: [register],})// System metricsexport const activeUsersGauge = new Gauge({  name: 'active_users_current',  help: 'Current number of active users',  registers: [register],})export const activeWebSocketConnectionsGauge = new Gauge({  name: 'websocket_connections_current',  help: 'Current number of WebSocket connections',  registers: [register],})// Cache metricsexport const cacheHitsCounter = new Counter({  name: 'cache_hits_total',  help: 'Total number of cache hits',  labelNames: ['cache'],  registers: [register],})export const cacheMissesCounter = new Counter({  name: 'cache_misses_total',  help: 'Total number of cache misses',  labelNames: ['cache'],  registers: [register],})// Error metricsexport const errorCounter = new Counter({  name: 'errors_total',  help: 'Total number of errors',  labelNames: ['type', 'severity'],  registers: [register],})```Metrics API Endpoint```typescript// pages/api/metrics.tsimport { NextApiRequest, NextApiResponse } from 'next'import { register } from '@/lib/metrics/prometheus'export default async function handler(  req: NextApiRequest,  res: NextApiResponse) {  // Basic auth for metrics endpoint  const auth = req.headers.authorization  const expectedAuth = `Basic ${Buffer.from(    `${process.env.METRICS_USERNAME}:${process.env.METRICS_PASSWORD}`  ).toString('base64')}`  if (auth !== expectedAuth) {    res.status(401).json({ error: 'Unauthorized' })    return  }  // Return metrics  res.setHeader('Content-Type', register.contentType)  res.send(await register.metrics())}```Metrics Collection Service```typescript// lib/metrics/collector.tsimport { prisma } from '@/lib/prisma'import {  activeUsersGauge,  projectsCreatedCounter,  okrsCreatedCounter,  kpiRecordsCounter,} from './prometheus'export class MetricsCollector {  private intervalId: NodeJS.Timer | null = null  start() {    // Collect metrics every 60 seconds    this.intervalId = setInterval(() => {      this.collectMetrics()    }, 60000)    // Initial collection    this.collectMetrics()  }  stop() {    if (this.intervalId) {      clearInterval(this.intervalId)      this.intervalId = null    }  }  private async collectMetrics() {    try {      // Active users (logged in last 5 minutes)      const activeUsersCount = await prisma.user.count({        where: {          lastLoginAt: {            gte: new Date(Date.now() - 5 * 60 * 1000),          },        },      })      activeUsersGauge.set(activeUsersCount)      // Projects by organization      const projectsByOrg = await prisma.project.groupBy({        by: ['organizationId', 'projectType'],        _count: true,        where: {          createdAt: {            gte: new Date(Date.now() - 24 * 60 * 60 * 1000), // Last 24h          },        },      })      projectsByOrg.forEach((group) => {        projectsCreatedCounter.inc(          {            type: group.projectType,            organization: group.organizationId,          },          group._count        )      })      // OKRs by organization      const okrsByOrg = await prisma.oKR.groupBy({        by: ['organizationId', 'okrType'],        _count: true,        where: {          createdAt: {            gte: new Date(Date.now() - 24 * 60 * 60 * 1000),          },        },      })      okrsByOrg.forEach((group) => {        okrsCreatedCounter.inc(          {            type: group.okrType,            organization: group.organizationId,          },          group._count        )      })      // KPI records      const kpiRecordsByOrg = await prisma.kPIValue.groupBy({        by: ['organizationId'],        _count: true,        where: {          createdAt: {            gte: new Date(Date.now() - 24 * 60 * 60 * 1000),          },        },      })      kpiRecordsByOrg.forEach((group) => {        kpiRecordsCounter.inc(          { organization: group.organizationId },          group._count        )      })    } catch (error) {      console.error('Error collecting metrics:', error)    }  }}// Singleton instanceexport const metricsCollector = new MetricsCollector()```---ğŸ“‹ Step 3: Error Tracking (Sentry)Sentry Setup```typescript// lib/sentry/config.tsimport * as Sentry from '@sentry/nextjs'export function initSentry() {  Sentry.init({    dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,    environment: process.env.NODE_ENV,    tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,        // Don't send errors in development    enabled: process.env.NODE_ENV === 'production',        // Release tracking    release: process.env.NEXT_PUBLIC_APP_VERSION,        // Integrations    integrations: [      new Sentry.BrowserTracing({        tracingOrigins: ['localhost', /^\//],      }),      new Sentry.Replay({        maskAllText: true,        blockAllMedia: true,      }),    ],        // Performance monitoring    tracesSampler: (samplingContext) => {      // High-priority transactions      if (samplingContext.transactionContext.name?.includes('/api/')) {        return 1.0      }            // Low-priority transactions      if (samplingContext.transactionContext.name?.includes('/static/')) {        return 0.01      }            return 0.1    },        // Error filtering    beforeSend: (event, hint) => {      // Filter out common non-critical errors      const error = hint.originalException            if (error && typeof error === 'object' && 'message' in error) {        const message = String(error.message)                // Ignore network errors        if (message.includes('NetworkError') || message.includes('Failed to fetch')) {          return null        }                // Ignore cancelled requests        if (message.includes('AbortError') || message.includes('cancelled')) {          return null        }      }            return event    },        // Add user context    beforeBreadcrumb: (breadcrumb) => {      // Filter sensitive data from breadcrumbs      if (breadcrumb.category === 'console') {        return null      }      return breadcrumb    },  })}```Error Boundary with Sentry```typescript// components/error/error-boundary.tsximport React from 'react'import * as Sentry from '@sentry/nextjs'import { Button } from '@/components/ui/button'import { AlertTriangle } from 'lucide-react'interface Props {  children: React.ReactNode  fallback?: React.ReactNode}interface State {  hasError: boolean  error?: Error  errorInfo?: React.ErrorInfo}export class ErrorBoundary extends React.Component<Props, State> {  constructor(props: Props) {    super(props)    this.state = { hasError: false }  }  static getDerivedStateFromError(error: Error): State {    return { hasError: true, error }  }  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {    // Log to Sentry    Sentry.captureException(error, {      contexts: {        react: {          componentStack: errorInfo.componentStack,        },      },    })    this.setState({ error, errorInfo })  }  render() {    if (this.state.hasError) {      if (this.props.fallback) {        return this.props.fallback      }      return (        <div className="min-h-screen flex items-center justify-center p-4">          <div className="max-w-md w-full space-y-4 text-center">            <AlertTriangle className="h-16 w-16 text-destructive mx-auto" />            <h1 className="text-2xl font-bold">à¹€à¸à¸´à¸”à¸‚à¹‰à¸­à¸œà¸´à¸”à¸à¸¥à¸²à¸”</h1>            <p className="text-muted-foreground">              à¹€à¸à¸´à¸”à¸‚à¹‰à¸­à¸œà¸´à¸”à¸à¸¥à¸²à¸”à¸—à¸µà¹ˆà¹„à¸¡à¹ˆà¸„à¸²à¸”à¸„à¸´à¸” à¸à¸£à¸¸à¸“à¸²à¸¥à¸­à¸‡à¹ƒà¸«à¸¡à¹ˆà¸­à¸µà¸à¸„à¸£à¸±à¹‰à¸‡            </p>            {process.env.NODE_ENV === 'development' && this.state.error && (              <div className="text-left p-4 bg-muted rounded-lg overflow-auto max-h-64">                <pre className="text-xs">                  {this.state.error.toString()}                  {this.state.errorInfo?.componentStack}                </pre>              </div>            )}            <div className="flex gap-2 justify-center">              <Button                variant="outline"                onClick={() => window.location.reload()}              >                à¹‚à¸«à¸¥à¸”à¸«à¸™à¹‰à¸²à¹ƒà¸«à¸¡à¹ˆ              </Button>              <Button onClick={() => (window.location.href = '/dashboard')}>                à¸à¸¥à¸±à¸šà¸«à¸™à¹‰à¸²à¸«à¸¥à¸±à¸              </Button>            </div>          </div>        </div>      )    }    return this.props.children  }}```---ğŸ“‹ Step 4: Application Performance Monitoring (APM)Performance Monitoring Hook```typescript// hooks/use-performance.tsimport { useEffect, useRef } from 'react'import { logger } from '@/lib/logger'interface PerformanceMetrics {  name: string  duration: number  startTime: number  endTime: number}export function usePerformance(componentName: string) {  const mountTimeRef = useRef<number>(0)  const metricsRef = useRef<PerformanceMetrics[]>([])  useEffect(() => {    mountTimeRef.current = performance.now()    return () => {      const unmountTime = performance.now()      const totalDuration = unmountTime - mountTimeRef.current      // Log component lifecycle performance      logger.logPerformance(`Component ${componentName}`, totalDuration, {        component: componentName,        metrics: metricsRef.current,      })    }  }, [componentName])  const measureOperation = (operationName: string, operation: () => void | Promise<void>) => {    const startTime = performance.now()    const measure = async () => {      try {        await operation()      } finally {        const endTime = performance.now()        const duration = endTime - startTime        metricsRef.current.push({          name: operationName,          duration,          startTime,          endTime,        })        // Log slow operations        if (duration > 1000) {          logger.warn(`Slow operation in ${componentName}: ${operationName}`, {            duration,            component: componentName,            operation: operationName,          })        }      }    }    measure()  }  return { measureOperation }}```Web Vitals Tracking```typescript// lib/analytics/web-vitals.tsimport { getCLS, getFID, getFCP, getLCP, getTTFB, Metric } from 'web-vitals'import { logger } from '@/lib/logger'function sendToAnalytics(metric: Metric) {  // Log to console in development  if (process.env.NODE_ENV === 'development') {    console.log(metric)  }  // Log performance metrics  logger.logPerformance(`Web Vital: ${metric.name}`, metric.value, {    id: metric.id,    delta: metric.delta,    rating: metric.rating,  })  // Send to analytics service  if (typeof window !== 'undefined' && window.gtag) {    window.gtag('event', metric.name, {      event_category: 'Web Vitals',      event_label: metric.id,      value: Math.round(metric.name === 'CLS' ? metric.value * 1000 : metric.value),      non_interaction: true,    })  }}export function reportWebVitals() {  getCLS(sendToAnalytics)  getFID(sendToAnalytics)  getFCP(sendToAnalytics)  getLCP(sendToAnalytics)  getTTFB(sendToAnalytics)}```Performance Observer```typescript// lib/analytics/performance-observer.tsexport class PerformanceObserver {  private observer: PerformanceObserver | null = null  start() {    if (typeof window === 'undefined') return    // Observe long tasks    this.observer = new window.PerformanceObserver((list) => {      for (const entry of list.getEntries()) {        if (entry.duration > 50) {          console.warn('Long Task detected:', {            name: entry.name,            duration: entry.duration,            startTime: entry.startTime,          })          // Log to monitoring          logger.warn('Long Task detected', {            name: entry.name,            duration: entry.duration,            startTime: entry.startTime,          })        }      }    })    try {      this.observer.observe({ entryTypes: ['longtask'] })    } catch (e) {      console.warn('Long Task API not supported')    }  }  stop() {    if (this.observer) {      this.observer.disconnect()      this.observer = null    }  }}export const performanceObserver = new PerformanceObserver()```---ğŸ“‹ Step 5: User Analytics & Session TrackingAnalytics Service```typescript// lib/analytics/service.tsimport { logger } from '@/lib/logger'export interface AnalyticsEvent {  name: string  properties?: Record<string, any>  userId?: string  sessionId?: string  timestamp?: Date}export class AnalyticsService {  private sessionId: string  private userId?: string  constructor() {    this.sessionId = this.generateSessionId()  }  private generateSessionId(): string {    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`  }  setUser(userId: string) {    this.userId = userId  }  // Track page view  trackPageView(path: string, title?: string) {    this.track('page_view', {      path,      title: title || document.title,      referrer: document.referrer,      screenResolution: `${window.screen.width}x${window.screen.height}`,    })  }  // Track custom event  track(eventName: string, properties?: Record<string, any>) {    const event: AnalyticsEvent = {      name: eventName,      properties,      userId: this.userId,      sessionId: this.sessionId,      timestamp: new Date(),    }    // Log event    logger.info(`Analytics Event: ${eventName}`, {      module: 'analytics',      event,    })    // Send to Google Analytics    if (typeof window !== 'undefined' && window.gtag) {      window.gtag('event', eventName, properties)    }    // Send to custom analytics API    this.sendToAPI(event)  }  // Track user actions  trackUserAction(action: string, resource: string, properties?: Record<string, any>) {    this.track(`user_action_${action}`, {      action,      resource,      ...properties,    })  }  // Track business events  trackBusinessEvent(event: string, properties?: Record<string, any>) {    this.track(`business_${event}`, properties)  }  // Track errors  trackError(error: Error, context?: Record<string, any>) {    this.track('error_occurred', {      error: {        name: error.name,        message: error.message,        stack: error.stack,      },      ...context,    })  }  // Track conversion events  trackConversion(type: string, value?: number, properties?: Record<string, any>) {    this.track('conversion', {      type,      value,      ...properties,    })  }  private async sendToAPI(event: AnalyticsEvent) {    try {      await fetch('/api/analytics/track', {        method: 'POST',        headers: { 'Content-Type': 'application/json' },        body: JSON.stringify(event),      })    } catch (error) {      console.error('Failed to send analytics event:', error)    }  }}// Singleton instanceexport const analytics = new AnalyticsService()```Analytics Hook```typescript// hooks/use-analytics.tsimport { useEffect } from 'react'import { useRouter } from 'next/router'import { analytics } from '@/lib/analytics/service'import { useSession } from 'next-auth/react'export function useAnalytics() {  const router = useRouter()  const { data: session } = useSession()  // Track user  useEffect(() => {    if (session?.user?.id) {      analytics.setUser(session.user.id)    }  }, [session])  // Track page views  useEffect(() => {    const handleRouteChange = (url: string) => {      analytics.trackPageView(url)    }    router.events.on('routeChangeComplete', handleRouteChange)    return () => {      router.events.off('routeChangeComplete', handleRouteChange)    }  }, [router])  return {    trackEvent: analytics.track.bind(analytics),    trackUserAction: analytics.trackUserAction.bind(analytics),    trackBusinessEvent: analytics.trackBusinessEvent.bind(analytics),    trackError: analytics.trackError.bind(analytics),    trackConversion: analytics.trackConversion.bind(analytics),  }}```---ğŸ“‹ Step 6: Dashboard & Monitoring UIAdmin Monitoring Dashboard```typescript// pages/admin/monitoring.tsximport { MainLayout } from '@/components/layout/main-layout'import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'import { trpc } from '@/lib/trpc'import { Activity, Database, Users, Zap, AlertTriangle } from 'lucide-react'import {  LineChart,  Line,  AreaChart,  Area,  XAxis,  YAxis,  CartesianGrid,  Tooltip,  ResponsiveContainer,} from 'recharts'export default function MonitoringDashboard() {  const { data: systemMetrics } = trpc.admin.getSystemMetrics.useQuery(undefined, {    refetchInterval: 5000, // Refresh every 5 seconds  })  const { data: errorLogs } = trpc.admin.getErrorLogs.useQuery({    page: 1,    perPage: 10,  })  const { data: performanceMetrics } = trpc.admin.getPerformanceMetrics.useQuery({    timeRange: '1h',  })  return (    <MainLayout      title="System Monitoring"      description="Real-time system health and performance metrics"    >      {/* Overview Stats */}      <div className="grid gap-4 md:grid-cols-4">        <Card>          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">            <CardTitle className="text-sm font-medium">Active Users</CardTitle>            <Users className="h-4 w-4 text-muted-foreground" />          </CardHeader>          <CardContent>            <div className="text-2xl font-bold">{systemMetrics?.activeUsers}</div>            <p className="text-xs text-muted-foreground">              +{systemMetrics?.newUsersToday} today            </p>          </CardContent>        </Card>        <Card>          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">            <CardTitle className="text-sm font-medium">Requests/min</CardTitle>            <Activity className="h-4 w-4 text-muted-foreground" />          </CardHeader>          <CardContent>            <div className="text-2xl font-bold">{systemMetrics?.requestsPerMinute}</div>            <p className="text-xs text-muted-foreground">              Avg response: {systemMetrics?.avgResponseTime}ms            </p>          </CardContent>        </Card>        <Card>          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">            <CardTitle className="text-sm font-medium">Database</CardTitle>            <Database className="h-4 w-4 text-muted-foreground" />          </CardHeader>          <CardContent>            <div className="text-2xl font-bold">              {systemMetrics?.databaseConnections}/100            </div>            <p className="text-xs text-muted-foreground">              Query time: {systemMetrics?.avgQueryTime}ms            </p>          </CardContent>        </Card>        <Card>          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">            <CardTitle className="text-sm font-medium">Errors</CardTitle>            <AlertTriangle className="h-4 w-4 text-muted-foreground" />          </CardHeader>          <CardContent>            <div className="text-2xl font-bold text-red-600">              {systemMetrics?.errorCount}            </div>            <p className="text-xs text-muted-foreground">Last hour</p>          </CardContent>        </Card>      </div>      {/* Charts */}      <Tabs defaultValue="performance" className="space-y-4">        <TabsList>          <TabsTrigger value="performance">Performance</TabsTrigger>          <TabsTrigger value="traffic">Traffic</TabsTrigger>          <TabsTrigger value="errors">Errors</TabsTrigger>          <TabsTrigger value="database">Database</TabsTrigger>        </TabsList>        <TabsContent value="performance" className="space-y-4">          <Card>            <CardHeader>              <CardTitle>Response Time</CardTitle>            </CardHeader>            <CardContent>              <ResponsiveContainer width="100%" height={350}>                <LineChart data={performanceMetrics?.responseTime}>                  <CartesianGrid strokeDasharray="3 3" />                  <XAxis dataKey="timestamp" />                  <YAxis />                  <Tooltip />                  <Line                    type="monotone"                    dataKey="p50"                    stroke="#3b82f6"                    name="P50"                  />                  <Line                    type="monotone"                    dataKey="p95"                    stroke="#f59e0b"                    name="P95"                  />                  <Line                    type="monotone"                    dataKey="p99"                    stroke="#ef4444"                    name="P99"                  />                </LineChart>              </ResponsiveContainer>            </CardContent>          </Card>        </TabsContent>        <TabsContent value="errors" className="space-y-4">          <Card>            <CardHeader>              <CardTitle>Recent Errors</CardTitle>            </CardHeader>            <CardContent>              <div className="space-y-3">                {errorLogs?.data.map((error) => (                  <div                    key={error.id}                    className="flex items-start justify-between p-3 border rounded-lg"                  >                    <div className="flex-1">                      <p className="font-medium text-red-600">{error.message}</p>                      <p className="text-sm text-muted-foreground">                        {error.path} - {new Date(error.timestamp).toLocaleString()}                      </p>                    </div>                    <span className="text-xs text-muted-foreground">                      x{error.count}                    </span>                  </div>                ))}              </div>            </CardContent>          </Card>        </TabsContent>      </Tabs>    </MainLayout>  )}```---âœ… Complete Analytics & Monitoring StackğŸ‰ à¹€à¸ªà¸£à¹‡à¸ˆà¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œ!à¸•à¸´à¸”à¸•à¸±à¹‰à¸‡à¹à¸¥à¹‰à¸§ âœ…Logging System âœ…Winston Logger with rotationStructured loggingContext-aware loggingSecurity loggingMetrics Collection âœ…Prometheus metricsCustom business metricsSystem metricsPerformance metricsError Tracking âœ…Sentry integrationError boundariesError filteringPerformance Monitoring âœ…APM trackingWeb VitalsPerformance ObserverComponent performanceUser Analytics âœ…Event trackingSession trackingConversion trackingBusiness eventsMonitoring Dashboard âœ…Real-time metricsPerformance chartsError logsSystem health---